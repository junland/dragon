To: vim_dev@googlegroups.com
Subject: Patch 8.0.0974
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0974
Problem:    Resetting a string option does not trigger OptionSet. (Rick Howe)
Solution:   Set the origval.
Files:      src/option.c, src/testdir/test_autocmd.vim


*** ../vim-8.0.0973/src/option.c	2017-08-20 15:05:11.620196302 +0200
--- src/option.c	2017-08-20 15:43:07.234071219 +0200
***************
*** 4351,4358 ****
  		       (char_u *)options[opt_idx].fullname, NULL, FALSE, NULL);
  	reset_v_option_vars();
      }
-     vim_free(oldval);
-     vim_free(newval);
  }
  #endif
  
--- 4351,4356 ----
***************
*** 4818,4836 ****
  		    }
  		    else if (opt_idx >= 0)		    /* string */
  		    {
! 			char_u	    *save_arg = NULL;
! 			char_u	    *s = NULL;
! 			char_u	    *oldval = NULL;	/* previous value if *varp */
! 			char_u	    *newval;
! 			char_u	    *origval = NULL;
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
! 			char_u	    *saved_origval = NULL;
! 			char_u	    *saved_newval = NULL;
  #endif
! 			unsigned    newlen;
! 			int	    comma;
! 			int	    bs;
! 			int	    new_value_alloced;	/* new string option
  							   was allocated */
  
  			/* When using ":set opt=val" for a global option
--- 4816,4834 ----
  		    }
  		    else if (opt_idx >= 0)		    /* string */
  		    {
! 			char_u	  *save_arg = NULL;
! 			char_u	  *s = NULL;
! 			char_u	  *oldval = NULL; /* previous value if *varp */
! 			char_u	  *newval;
! 			char_u	  *origval = NULL;
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
! 			char_u	  *saved_origval = NULL;
! 			char_u	  *saved_newval = NULL;
  #endif
! 			unsigned  newlen;
! 			int	  comma;
! 			int	  bs;
! 			int	  new_value_alloced;	/* new string option
  							   was allocated */
  
  			/* When using ":set opt=val" for a global option
***************
*** 4843,4848 ****
--- 4841,4856 ----
  			/* The old value is kept until we are sure that the
  			 * new value is valid. */
  			oldval = *(char_u **)varp;
+ 
+ 			/* When setting the local value of a global
+ 			 * option, the old value may be the global value. */
+ 			if (((int)options[opt_idx].indir & PV_BOTH)
+ 					       && (opt_flags & OPT_LOCAL))
+ 			    origval = *(char_u **)get_varp(
+ 						       &options[opt_idx]);
+ 			else
+ 			    origval = oldval;
+ 
  			if (nextchar == '&')	/* set to default val */
  			{
  			    newval = options[opt_idx].def_val[
***************
*** 4957,4971 ****
  				++arg;
  			    }
  
- 			    /* When setting the local value of a global
- 			     * option, the old value may be the global value. */
- 			    if (((int)options[opt_idx].indir & PV_BOTH)
- 						   && (opt_flags & OPT_LOCAL))
- 				origval = *(char_u **)get_varp(
- 							   &options[opt_idx]);
- 			    else
- 				origval = oldval;
- 
  			    /*
  			     * Copy the new string into allocated memory.
  			     * Can't use set_string_option_direct(), because
--- 4965,4970 ----
***************
*** 5169,5175 ****
  			    new_value_alloced = TRUE;
  			}
  
! 			/* Set the new value. */
  			*(char_u **)(varp) = newval;
  
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
--- 5168,5176 ----
  			    new_value_alloced = TRUE;
  			}
  
! 			/*
! 			 * Set the new value.
! 			 */
  			*(char_u **)(varp) = newval;
  
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
***************
*** 5195,5213 ****
  			errmsg = did_set_string_option(opt_idx, (char_u **)varp,
  				new_value_alloced, oldval, errbuf, opt_flags);
  
- 			/* If error detected, print the error message. */
- 			if (errmsg != NULL)
- 			{
- #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
- 			    vim_free(saved_origval);
- 			    vim_free(saved_newval);
- #endif
- 			    goto skip;
- 			}
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
! 			trigger_optionsset_string(opt_idx, opt_flags,
  						  saved_origval, saved_newval);
  #endif
  		    }
  		    else	    /* key code option */
  		    {
--- 5196,5211 ----
  			errmsg = did_set_string_option(opt_idx, (char_u **)varp,
  				new_value_alloced, oldval, errbuf, opt_flags);
  
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
! 			if (errmsg == NULL)
! 			    trigger_optionsset_string(opt_idx, opt_flags,
  						  saved_origval, saved_newval);
+ 			vim_free(saved_origval);
+ 			vim_free(saved_newval);
  #endif
+ 			/* If error detected, print the error message. */
+ 			if (errmsg != NULL)
+ 			    goto skip;
  		    }
  		    else	    /* key code option */
  		    {
***************
*** 6014,6021 ****
  
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  	/* call autocommand after handling side effects */
! 	trigger_optionsset_string(opt_idx, opt_flags,
  						   saved_oldval, saved_newval);
  #endif
      }
      return r;
--- 6012,6022 ----
  
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  	/* call autocommand after handling side effects */
! 	if (r == NULL)
! 	    trigger_optionsset_string(opt_idx, opt_flags,
  						   saved_oldval, saved_newval);
+ 	vim_free(saved_oldval);
+ 	vim_free(saved_newval);
  #endif
      }
      return r;
*** ../vim-8.0.0973/src/testdir/test_autocmd.vim	2017-08-04 22:36:01.566927258 +0200
--- src/testdir/test_autocmd.vim	2017-08-20 15:42:22.598345858 +0200
***************
*** 548,553 ****
--- 548,566 ----
    call assert_equal([['key', 'invalid', 'invalid1', 'invalid']], g:options)
    call assert_equal(g:opt[0], g:opt[1])
  
+   " 18: Setting string option"
+   let oldval = &tags
+   let g:options=[['tags', oldval, 'tagpath', 'global']]
+   set tags=tagpath
+   call assert_equal([], g:options)
+   call assert_equal(g:opt[0], g:opt[1])
+ 
+   " 1l: Resetting string option"
+   let g:options=[['tags', 'tagpath', oldval, 'global']]
+   set tags&
+   call assert_equal([], g:options)
+   call assert_equal(g:opt[0], g:opt[1])
+ 
    " Cleanup
    au! OptionSet
    for opt in ['nu', 'ai', 'acd', 'ar', 'bs', 'backup', 'cul', 'cp']
*** ../vim-8.0.0973/src/version.c	2017-08-20 15:05:11.624196278 +0200
--- src/version.c	2017-08-20 15:46:30.456820827 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     974,
  /**/

-- 
If your company is not involved in something called "ISO 9000" you probably
have no idea what it is.  If your company _is_ involved in ISO 9000 then you
definitely have no idea what it is.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
