To: vim_dev@googlegroups.com
Subject: Patch 8.0.0898
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0898
Problem:    Can't use the alternate screen in a terminal window.
Solution:   Initialze the alternate screen. (Yasuhiro Matsumoto, closes
            #1957)  Add term_getaltscreen().
Files:      src/libvterm/include/vterm.h, src/terminal.c,
            src/proto/terminal.pro, src/evalfunc.c, runtime/doc/eval.txt


*** ../vim-8.0.0897/src/libvterm/include/vterm.h	2017-07-28 17:04:11.778241455 +0200
--- src/libvterm/include/vterm.h	2017-08-11 16:07:12.671839872 +0200
***************
*** 188,193 ****
--- 188,195 ----
  void vterm_keyboard_end_paste(VTerm *vt);
  
  void vterm_mouse_move(VTerm *vt, int row, int col, VTermModifier mod);
+ /* "button" is 1 for left, 2 for middle, 3 for right.
+  * Button 4 is scroll wheel down, button 5 is scroll wheel up. */
  void vterm_mouse_button(VTerm *vt, int button, int pressed, VTermModifier mod);
  
  /* ------------
***************
*** 302,307 ****
--- 304,312 ----
    int (*settermprop)(VTermProp prop, VTermValue *val, void *user);
    int (*bell)(void *user);
    int (*resize)(int rows, int cols, void *user);
+   /* A line was pushed off the top of the window.
+    * "cells[cols]" contains the cells of that line.
+    * Return value is unused. */
    int (*sb_pushline)(int cols, const VTermScreenCell *cells, void *user);
    int (*sb_popline)(int cols, VTermScreenCell *cells, void *user);
  } VTermScreenCallbacks;
***************
*** 320,325 ****
--- 325,333 ----
  void  vterm_screen_set_unrecognised_fallbacks(VTermScreen *screen, const VTermParserCallbacks *fallbacks, void *user);
  void *vterm_screen_get_unrecognised_fbdata(VTermScreen *screen);
  
+ /* Enable support for using the alternate screen if "altscreen" is non-zero.
+  * Before that switching to the alternate screen won't work.
+  * Calling with "altscreen" zero has no effect. */
  void vterm_screen_enable_altscreen(VTermScreen *screen, int altscreen);
  
  typedef enum {
*** ../vim-8.0.0897/src/terminal.c	2017-08-10 23:15:15.002851689 +0200
--- src/terminal.c	2017-08-11 16:10:21.878500160 +0200
***************
*** 146,151 ****
--- 146,153 ----
  
      VTermPos	tl_cursor_pos;
      int		tl_cursor_visible;
+ 
+     int		tl_using_altscreen;
  };
  
  #define TMODE_ONCE 1	    /* CTRL-\ CTRL-N used */
***************
*** 1316,1321 ****
--- 1318,1328 ----
  	    out_flush();
  	    break;
  
+ 	case VTERM_PROP_ALTSCREEN:
+ 	    /* TODO: do anything else? */
+ 	    term->tl_using_altscreen = value->boolean;
+ 	    break;
+ 
  	default:
  	    break;
      }
***************
*** 1865,1870 ****
--- 1872,1880 ----
  
      /* Required to initialize most things. */
      vterm_screen_reset(screen, 1 /* hard */);
+ 
+     /* Allow using alternate screen. */
+     vterm_screen_enable_altscreen(screen, 1);
  }
  
  /*
***************
*** 1939,1944 ****
--- 1949,1967 ----
  }
  
  /*
+  * "term_getaltscreen(buf)" function
+  */
+     void
+ f_term_getaltscreen(typval_T *argvars, typval_T *rettv)
+ {
+     buf_T	*buf = term_get_buf(argvars);
+ 
+     if (buf == NULL)
+ 	return;
+     rettv->vval.v_number = buf->b_term->tl_using_altscreen;
+ }
+ 
+ /*
   * "term_getattr(attr, name)" function
   */
      void
*** ../vim-8.0.0897/src/proto/terminal.pro	2017-08-08 23:06:40.850032268 +0200
--- src/proto/terminal.pro	2017-08-11 16:10:25.966470715 +0200
***************
*** 17,22 ****
--- 17,23 ----
  int term_get_attr(buf_T *buf, linenr_T lnum, int col);
  char_u *term_get_status_text(term_T *term);
  int set_ref_in_term(int copyID);
+ void f_term_getaltscreen(typval_T *argvars, typval_T *rettv);
  void f_term_getattr(typval_T *argvars, typval_T *rettv);
  void f_term_getcursor(typval_T *argvars, typval_T *rettv);
  void f_term_getjob(typval_T *argvars, typval_T *rettv);
*** ../vim-8.0.0897/src/evalfunc.c	2017-08-08 23:06:40.854032239 +0200
--- src/evalfunc.c	2017-08-11 16:10:47.630314685 +0200
***************
*** 831,836 ****
--- 831,837 ----
  #endif
      {"tempname",	0, 0, f_tempname},
  #ifdef FEAT_TERMINAL
+     {"term_getaltscreen", 1, 1, f_term_getaltscreen},
      {"term_getattr",	2, 2, f_term_getattr},
      {"term_getcursor",	1, 1, f_term_getcursor},
      {"term_getjob",	1, 1, f_term_getjob},
*** ../vim-8.0.0897/runtime/doc/eval.txt	2017-08-10 23:15:14.998851718 +0200
--- runtime/doc/eval.txt	2017-08-11 16:12:49.601436457 +0200
***************
*** 1,4 ****
! *eval.txt*	For Vim version 8.0.  Last change: 2016 Nov 04
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
--- 1,4 ----
! *eval.txt*	For Vim version 8.0.  Last change: 2017 Aug 11
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
***************
*** 1815,1821 ****
  		hit-enter prompt.
  
  					*v:servername* *servername-variable*
! v:servername	The resulting registered |x11-clientserver| name if any.
  		Read-only.
  
  		
--- 1815,1821 ----
  		hit-enter prompt.
  
  					*v:servername* *servername-variable*
! v:servername	The resulting registered |client-server-name| if any.
  		Read-only.
  
  		
***************
*** 2179,2185 ****
  				Number	index in {list} where {expr} appears
  input({prompt} [, {text} [, {completion}]])
  				String	get input from the user
! inputdialog({prompt} [, {text} [, {completion}]]])
  				String	like input() but in a GUI dialog
  inputlist({textlist})		Number	let the user pick from a choice list
  inputrestore()			Number	restore typeahead
--- 2179,2185 ----
  				Number	index in {list} where {expr} appears
  input({prompt} [, {text} [, {completion}]])
  				String	get input from the user
! inputdialog({prompt} [, {text} [, {completion}]])
  				String	like input() but in a GUI dialog
  inputlist({textlist})		Number	let the user pick from a choice list
  inputrestore()			Number	restore typeahead
***************
*** 2369,2374 ****
--- 2369,2375 ----
  tan({expr})			Float	tangent of {expr}
  tanh({expr})			Float	hyperbolic tangent of {expr}
  tempname()			String	name for a temporary file
+ term_getaltscreen({buf})	Number	get the alternate screen flag
  term_getattr({attr}, {what})	Number	get the value of attribute {what}
  term_getcursor({buf})		List	get the cursor position of a terminal
  term_getjob({buf})		Job	get the job associated with a terminal
***************
*** 3397,3402 ****
--- 3398,3404 ----
  		FileType event has been triggered at least once.  Can be used
  		to avoid triggering the FileType event again in the scripts
  		that detect the file type. |FileType|
+ 		Returns |FALSE| when `:setf FALLBACK` was used.
  		When editing another file, the counter is reset, thus this
  		really checks if the FileType event has been triggered for the
  		current buffer.  This allows an autocommand that starts
***************
*** 4212,4225 ****
  			not consumed.  Return zero if no character available.
  
  		Without [expr] and when [expr] is 0 a whole character or
! 		special key is returned.  If it is an 8-bit character, the
  		result is a number.  Use nr2char() to convert it to a String.
  		Otherwise a String is returned with the encoded character.
! 		For a special key it's a sequence of bytes starting with 0x80
! 		(decimal: 128).  This is the same value as the string
! 		"\<Key>", e.g., "\<Left>".  The returned value is also a
! 		String when a modifier (shift, control, alt) was used that is
! 		not included in the character.
  
  		When [expr] is 0 and Esc is typed, there will be a short delay
  		while Vim waits to see if this is the start of an escape
--- 4214,4227 ----
  			not consumed.  Return zero if no character available.
  
  		Without [expr] and when [expr] is 0 a whole character or
! 		special key is returned.  If it is a single character, the
  		result is a number.  Use nr2char() to convert it to a String.
  		Otherwise a String is returned with the encoded character.
! 		For a special key it's a String with a sequence of bytes
! 		starting with 0x80 (decimal: 128).  This is the same value as
! 		the String "\<Key>", e.g., "\<Left>".  The returned value is
! 		also a String when a modifier (shift, control, alt) was used
! 		that is not included in the character.
  
  		When [expr] is 0 and Esc is typed, there will be a short delay
  		while Vim waits to see if this is the start of an escape
***************
*** 5493,5499 ****
  <							*last-position-jump*
  		This autocommand jumps to the last known position in a file
  		just after opening it, if the '" mark is set: >
! 	:au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
  
  line2byte({lnum})					*line2byte()*
  		Return the byte count from the start of the buffer for line
--- 5495,5504 ----
  <							*last-position-jump*
  		This autocommand jumps to the last known position in a file
  		just after opening it, if the '" mark is set: >
!      :au BufReadPost *
! 	 \ if line("'\"") > 1 && line("'\"") <= line("$") && &ft !~# 'commit' 
! 	 \ |   exe "normal! g`\""
! 	 \ | endif
  
  line2byte({lnum})					*line2byte()*
  		Return the byte count from the start of the buffer for line
***************
*** 5915,5921 ****
  		it returns the maximum of all values in the dictionary.
  		If {expr} is neither a list nor a dictionary, or one of the
  		items in {expr} cannot be used as a Number this results in
!                 an error.  An empty |List| or |Dictionary| results in zero.
  
  							*min()*
  min({expr})	Return the minimum value of all items in {expr}.
--- 5920,5926 ----
  		it returns the maximum of all values in the dictionary.
  		If {expr} is neither a list nor a dictionary, or one of the
  		items in {expr} cannot be used as a Number this results in
! 		an error.  An empty |List| or |Dictionary| results in zero.
  
  							*min()*
  min({expr})	Return the minimum value of all items in {expr}.
***************
*** 5923,5929 ****
  		it returns the minimum of all values in the dictionary.
  		If {expr} is neither a list nor a dictionary, or one of the
  		items in {expr} cannot be used as a Number this results in
!                 an error.  An empty |List| or |Dictionary| results in zero.
  
  							*mkdir()* *E739*
  mkdir({name} [, {path} [, {prot}]])
--- 5928,5934 ----
  		it returns the minimum of all values in the dictionary.
  		If {expr} is neither a list nor a dictionary, or one of the
  		items in {expr} cannot be used as a Number this results in
! 		an error.  An empty |List| or |Dictionary| results in zero.
  
  							*mkdir()* *E739*
  mkdir({name} [, {path} [, {prot}]])
***************
*** 6218,6225 ****
  			zero the decimal point is omitted.  When the precision
  			is not specified 6 is used.  A really big number
  			(out of range or dividing by zero) results in "inf"
!                         or "-inf" with %f (INF or -INF with %F).
!                         "0.0 / 0.0" results in "nan" with %f (NAN with %F).
  			Example: >
  				echo printf("%.2f", 12.115)
  <				12.12
--- 6223,6230 ----
  			zero the decimal point is omitted.  When the precision
  			is not specified 6 is used.  A really big number
  			(out of range or dividing by zero) results in "inf"
! 			or "-inf" with %f (INF or -INF with %F).
! 			"0.0 / 0.0" results in "nan" with %f (NAN with %F).
  			Example: >
  				echo printf("%.2f", 12.115)
  <				12.12
***************
*** 7132,7149 ****
  		quotes within {string}.
  		Otherwise it will enclose {string} in single quotes and
  		replace all "'" with "'\''".
  		When the {special} argument is present and it's a non-zero
  		Number or a non-empty String (|non-zero-arg|), then special
  		items such as "!", "%", "#" and "<cword>" will be preceded by
  		a backslash.  This backslash will be removed again by the |:!|
  		command.
  		The "!" character will be escaped (again with a |non-zero-arg|
  		{special}) when 'shell' contains "csh" in the tail.  That is
  		because for csh and tcsh "!" is used for history replacement
  		even when inside single quotes.
! 		The <NL> character is also escaped.  With a |non-zero-arg|
! 		{special} and 'shell' containing "csh" in the tail it's
  		escaped a second time.
  		Example of use with a |:!| command: >
  		    :exe '!dir ' . shellescape(expand('<cfile>'), 1)
  <		This results in a directory listing for the file under the
--- 7137,7158 ----
  		quotes within {string}.
  		Otherwise it will enclose {string} in single quotes and
  		replace all "'" with "'\''".
+ 
  		When the {special} argument is present and it's a non-zero
  		Number or a non-empty String (|non-zero-arg|), then special
  		items such as "!", "%", "#" and "<cword>" will be preceded by
  		a backslash.  This backslash will be removed again by the |:!|
  		command.
+ 
  		The "!" character will be escaped (again with a |non-zero-arg|
  		{special}) when 'shell' contains "csh" in the tail.  That is
  		because for csh and tcsh "!" is used for history replacement
  		even when inside single quotes.
! 
! 		With a |non-zero-arg| {special} the <NL> character is also
! 		escaped.  When 'shell' containing "csh" in the tail it's
  		escaped a second time.
+ 
  		Example of use with a |:!| command: >
  		    :exe '!dir ' . shellescape(expand('<cfile>'), 1)
  <		This results in a directory listing for the file under the
***************
*** 7906,7911 ****
--- 7915,7926 ----
  		For MS-Windows forward slashes are used when the 'shellslash'
  		option is set or when 'shellcmdflag' starts with '-'.
  
+ term_getaltscreen({buf})				*term_getaltscreen()*
+ 		Returns 1 if the terminal of {buf} is using the alternate
+ 		screen.
+ 		{buf} is used as with |term_getsize()|.
+ 		{only available when compiled with the |+terminal| feature}
+ 
  term_getattr({attr}, {what})				*term_getattr()*
  		Given {attr}, a value returned by term_scrape() in the "attr"
  		item, return whether {what} is on.  {what} can be one of:
***************
*** 8574,8584 ****
  			cursor_words    Number of words before cursor position
  					(not in Visual mode)
  			visual_bytes    Number of bytes visually selected
! 			                (only in Visual mode)
  			visual_chars    Number of chars visually selected
! 			                (only in Visual mode)
  			visual_words    Number of chars visually selected
! 			                (only in Visual mode)
  
  
  							*writefile()*
--- 8589,8599 ----
  			cursor_words    Number of words before cursor position
  					(not in Visual mode)
  			visual_bytes    Number of bytes visually selected
! 					(only in Visual mode)
  			visual_chars    Number of chars visually selected
! 					(only in Visual mode)
  			visual_words    Number of chars visually selected
! 					(only in Visual mode)
  
  
  							*writefile()*
***************
*** 10935,10946 ****
  "while 0".  Without the |+eval| feature the "while 0" is an error, which is
  silently ignored, and the command is executed.
  
- The "<CR>" here is a real CR character, type CTRL-V Enter to get it.
- 
- When the |+eval| feature is available the ":" is remapped to add a double
- quote, which has the effect of commenting-out the command.  Without the
- |+eval| feature the nnoremap command is skipped and the command is executed.
- 
  ==============================================================================
  11. The sandbox					*eval-sandbox* *sandbox* *E48*
  
--- 10950,10955 ----
*** ../vim-8.0.0897/src/version.c	2017-08-11 15:45:23.421118761 +0200
--- src/version.c	2017-08-11 16:24:00.160615330 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     898,
  /**/

-- 
A special law prohibits unmarried women from parachuting on Sunday or she
shall risk arrest, fine, and/or jailing.
		[real standing law in Florida, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
