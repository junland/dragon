To: vim_dev@googlegroups.com
Subject: Patch 8.0.0452
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0452
Problem:    Some macros are in lower case.
Solution:   Make a few more macros upper case.
Files:      src/vim.h, src/macros.h, src/evalfunc.c, src/fold.c,
            src/gui_gtk.c, src/gui_gtk_x11.c, src/charset.c, src/diff.c,
            src/edit.c, src/eval.c, src/ex_cmds.c, src/ex_cmds2.c,
            src/ex_docmd.c, src/ex_getln.c, src/fileio.c, src/getchar.c,
            src/gui.c, src/gui_w32.c, src/if_cscope.c, src/mbyte.c,
            src/menu.c, src/message.c, src/misc1.c, src/misc2.c, src/normal.c,
            src/ops.c, src/option.c, src/os_unix.c, src/os_win32.c,
            src/quickfix.c, src/regexp.c, src/regexp_nfa.c, src/screen.c,
            src/search.c, src/spell.c, src/syntax.c, src/tag.c, src/userfunc.c


*** ../vim-8.0.0451/src/vim.h	2017-02-21 21:57:02.475629988 +0100
--- src/vim.h	2017-03-12 20:06:31.553941533 +0100
***************
*** 588,594 ****
  #ifdef FEAT_GETTEXT
  # ifdef DYNAMIC_GETTEXT
  #  define _(x) (*dyn_libintl_gettext)((char *)(x))
! #  define ngettext(x, xs, n) (*dyn_libintl_ngettext)((char *)(x), (char *)(xs), (n))
  #  define N_(x) x
  #  define bindtextdomain(domain, dir) (*dyn_libintl_bindtextdomain)((domain), (dir))
  #  define bind_textdomain_codeset(domain, codeset) (*dyn_libintl_bind_textdomain_codeset)((domain), (codeset))
--- 588,594 ----
  #ifdef FEAT_GETTEXT
  # ifdef DYNAMIC_GETTEXT
  #  define _(x) (*dyn_libintl_gettext)((char *)(x))
! #  define NGETTEXT(x, xs, n) (*dyn_libintl_ngettext)((char *)(x), (char *)(xs), (n))
  #  define N_(x) x
  #  define bindtextdomain(domain, dir) (*dyn_libintl_bindtextdomain)((domain), (dir))
  #  define bind_textdomain_codeset(domain, codeset) (*dyn_libintl_bind_textdomain_codeset)((domain), (codeset))
***************
*** 601,606 ****
--- 601,607 ----
  # else
  #  include <libintl.h>
  #  define _(x) gettext((char *)(x))
+ #  define NGETTEXT(x, xs, n) ngettext((x), (xs), (n))
  #  ifdef gettext_noop
  #   define N_(x) gettext_noop(x)
  #  else
***************
*** 609,615 ****
  # endif
  #else
  # define _(x) ((char *)(x))
! # define ngettext(x, xs, n) (((n) == 1) ? (char *)(x) : (char *)(xs))
  # define N_(x) x
  # ifdef bindtextdomain
  #  undef bindtextdomain
--- 610,616 ----
  # endif
  #else
  # define _(x) ((char *)(x))
! # define NGETTEXT(x, xs, n) (((n) == 1) ? (char *)(x) : (char *)(xs))
  # define N_(x) x
  # ifdef bindtextdomain
  #  undef bindtextdomain
***************
*** 1764,1775 ****
  #define term_str(n)	term_strings[(int)(n)]
  
  /*
-  * vim_iswhite() is used for "^" and the like. It differs from isspace()
-  * because it doesn't include <CR> and <LF> and the like.
-  */
- #define vim_iswhite(x)	((x) == ' ' || (x) == '\t')
- 
- /*
   * EXTERN is only defined in main.c.  That's where global variables are
   * actually defined and initialized.
   */
--- 1765,1770 ----
*** ../vim-8.0.0451/src/macros.h	2017-03-12 19:22:31.740585042 +0100
--- src/macros.h	2017-03-12 20:06:47.897825762 +0100
***************
*** 46,51 ****
--- 46,57 ----
  #define LTOREQ_POS(a, b) (LT_POS(a, b) || EQUAL_POS(a, b))
  
  /*
+  * VIM_ISWHITE() is used for "^" and the like. It differs from isspace()
+  * because it doesn't include <CR> and <LF> and the like.
+  */
+ #define VIM_ISWHITE(x)	((x) == ' ' || (x) == '\t')
+ 
+ /*
   * LINEEMPTY() - return TRUE if the line is empty
   */
  #define LINEEMPTY(p) (*ml_get(p) == NUL)
*** ../vim-8.0.0451/src/evalfunc.c	2017-03-12 18:23:35.841850113 +0100
--- src/evalfunc.c	2017-03-12 19:37:18.842319441 +0100
***************
*** 3534,3540 ****
  	    }
  	}
  	count = (long)(foldend - foldstart + 1);
! 	txt = ngettext("+-%s%3ld line: ", "+-%s%3ld lines: ", count);
  	r = alloc((unsigned)(STRLEN(txt)
  		    + STRLEN(dashes)	    /* for %s */
  		    + 20		    /* for %3ld */
--- 3534,3540 ----
  	    }
  	}
  	count = (long)(foldend - foldstart + 1);
! 	txt = NGETTEXT("+-%s%3ld line: ", "+-%s%3ld lines: ", count);
  	r = alloc((unsigned)(STRLEN(txt)
  		    + STRLEN(dashes)	    /* for %s */
  		    + 20		    /* for %3ld */
*** ../vim-8.0.0451/src/fold.c	2017-03-12 19:22:31.752584957 +0100
--- src/fold.c	2017-03-12 19:42:44.292027348 +0100
***************
*** 1970,1976 ****
  	long count = (long)(lnume - lnum + 1);
  
  	vim_snprintf((char *)buf, FOLD_TEXT_LEN,
! 		     ngettext("+--%3ld line folded ",
  					       "+--%3ld lines folded ", count),
  		     count);
  	text = buf;
--- 1970,1976 ----
  	long count = (long)(lnume - lnum + 1);
  
  	vim_snprintf((char *)buf, FOLD_TEXT_LEN,
! 		     NGETTEXT("+--%3ld line folded ",
  					       "+--%3ld lines folded ", count),
  		     count);
  	text = buf;
***************
*** 1998,2004 ****
      /* Ignore leading and trailing white space in 'commentstring'. */
      cms_start = skipwhite(curbuf->b_p_cms);
      cms_slen = (int)STRLEN(cms_start);
!     while (cms_slen > 0 && vim_iswhite(cms_start[cms_slen - 1]))
  	--cms_slen;
  
      /* locate "%s" in 'commentstring', use the part before and after it. */
--- 1998,2004 ----
      /* Ignore leading and trailing white space in 'commentstring'. */
      cms_start = skipwhite(curbuf->b_p_cms);
      cms_slen = (int)STRLEN(cms_start);
!     while (cms_slen > 0 && VIM_ISWHITE(cms_start[cms_slen - 1]))
  	--cms_slen;
  
      /* locate "%s" in 'commentstring', use the part before and after it. */
***************
*** 2009,2015 ****
  	cms_slen = (int)(cms_end - cms_start);
  
  	/* exclude white space before "%s" */
! 	while (cms_slen > 0 && vim_iswhite(cms_start[cms_slen - 1]))
  	    --cms_slen;
  
  	/* skip "%s" and white space after it */
--- 2009,2015 ----
  	cms_slen = (int)(cms_end - cms_start);
  
  	/* exclude white space before "%s" */
! 	while (cms_slen > 0 && VIM_ISWHITE(cms_start[cms_slen - 1]))
  	    --cms_slen;
  
  	/* skip "%s" and white space after it */
***************
*** 2033,2039 ****
  
  	    /* May remove 'commentstring' start.  Useful when it's a double
  	     * quote and we already removed a double quote. */
! 	    for (p = s; p > str && vim_iswhite(p[-1]); --p)
  		;
  	    if (p >= str + cms_slen
  			   && STRNCMP(p - cms_slen, cms_start, cms_slen) == 0)
--- 2033,2039 ----
  
  	    /* May remove 'commentstring' start.  Useful when it's a double
  	     * quote and we already removed a double quote. */
! 	    for (p = s; p > str && VIM_ISWHITE(p[-1]); --p)
  		;
  	    if (p >= str + cms_slen
  			   && STRNCMP(p - cms_slen, cms_start, cms_slen) == 0)
***************
*** 2058,2064 ****
  	}
  	if (len != 0)
  	{
! 	    while (vim_iswhite(s[len]))
  		++len;
  	    STRMOVE(s, s + len);
  	}
--- 2058,2064 ----
  	}
  	if (len != 0)
  	{
! 	    while (VIM_ISWHITE(s[len]))
  		++len;
  	    STRMOVE(s, s + len);
  	}
*** ../vim-8.0.0451/src/gui_gtk.c	2017-03-12 19:22:31.756584930 +0100
--- src/gui_gtk.c	2017-03-12 19:38:06.909981115 +0100
***************
*** 51,59 ****
  # ifdef _
  #  undef _
  # endif
- # ifdef ngettext
- #  undef ngettext
- # endif
  # ifdef N_
  #  undef N_
  # endif
--- 51,56 ----
*** ../vim-8.0.0451/src/gui_gtk_x11.c	2017-02-23 12:20:30.205696184 +0100
--- src/gui_gtk_x11.c	2017-03-12 19:38:23.781862343 +0100
***************
*** 35,43 ****
  # ifdef _
  #  undef _
  # endif
- # ifdef ngettext
- #  undef ngettext
- # endif
  # ifdef N_
  #  undef N_
  # endif
--- 35,40 ----
*** ../vim-8.0.0451/src/charset.c	2017-03-12 19:22:31.740585042 +0100
--- src/charset.c	2017-03-12 19:39:55.941213424 +0100
***************
*** 1530,1536 ****
  {
      char_u	*p = q;
  
!     while (vim_iswhite(*p)) /* skip to next non-white */
  	++p;
      return p;
  }
--- 1530,1536 ----
  {
      char_u	*p = q;
  
!     while (VIM_ISWHITE(*p)) /* skip to next non-white */
  	++p;
      return p;
  }
*** ../vim-8.0.0451/src/diff.c	2017-03-12 18:23:35.837850143 +0100
--- src/diff.c	2017-03-12 19:40:15.581075100 +0100
***************
*** 1667,1673 ****
      p2 = s2;
      while (*p1 != NUL && *p2 != NUL)
      {
! 	if (vim_iswhite(*p1) && vim_iswhite(*p2))
  	{
  	    p1 = skipwhite(p1);
  	    p2 = skipwhite(p2);
--- 1667,1673 ----
      p2 = s2;
      while (*p1 != NUL && *p2 != NUL)
      {
! 	if (VIM_ISWHITE(*p1) && VIM_ISWHITE(*p2))
  	{
  	    p1 = skipwhite(p1);
  	    p2 = skipwhite(p2);
***************
*** 1994,2001 ****
  	    while (line_org[si_org] != NUL)
  	    {
  		if ((diff_flags & DIFF_IWHITE)
! 			&& vim_iswhite(line_org[si_org])
! 			&& vim_iswhite(line_new[si_new]))
  		{
  		    si_org = (int)(skipwhite(line_org + si_org) - line_org);
  		    si_new = (int)(skipwhite(line_new + si_new) - line_new);
--- 1994,2001 ----
  	    while (line_org[si_org] != NUL)
  	    {
  		if ((diff_flags & DIFF_IWHITE)
! 			&& VIM_ISWHITE(line_org[si_org])
! 			&& VIM_ISWHITE(line_new[si_new]))
  		{
  		    si_org = (int)(skipwhite(line_org + si_org) - line_org);
  		    si_new = (int)(skipwhite(line_new + si_new) - line_new);
***************
*** 2029,2042 ****
  						&& ei_org >= 0 && ei_new >= 0)
  		{
  		    if ((diff_flags & DIFF_IWHITE)
! 			    && vim_iswhite(line_org[ei_org])
! 			    && vim_iswhite(line_new[ei_new]))
  		    {
  			while (ei_org >= *startp
! 					     && vim_iswhite(line_org[ei_org]))
  			    --ei_org;
  			while (ei_new >= si_new
! 					     && vim_iswhite(line_new[ei_new]))
  			    --ei_new;
  		    }
  		    else
--- 2029,2042 ----
  						&& ei_org >= 0 && ei_new >= 0)
  		{
  		    if ((diff_flags & DIFF_IWHITE)
! 			    && VIM_ISWHITE(line_org[ei_org])
! 			    && VIM_ISWHITE(line_new[ei_new]))
  		    {
  			while (ei_org >= *startp
! 					     && VIM_ISWHITE(line_org[ei_org]))
  			    --ei_org;
  			while (ei_new >= si_new
! 					     && VIM_ISWHITE(line_new[ei_new]))
  			    --ei_new;
  		    }
  		    else
***************
*** 2202,2208 ****
      {
  	/* Buffer number or pattern given.  Ignore trailing white space. */
  	p = eap->arg + STRLEN(eap->arg);
! 	while (p > eap->arg && vim_iswhite(p[-1]))
  	    --p;
  	for (i = 0; vim_isdigit(eap->arg[i]) && eap->arg + i < p; ++i)
  	    ;
--- 2202,2208 ----
      {
  	/* Buffer number or pattern given.  Ignore trailing white space. */
  	p = eap->arg + STRLEN(eap->arg);
! 	while (p > eap->arg && VIM_ISWHITE(p[-1]))
  	    --p;
  	for (i = 0; vim_isdigit(eap->arg[i]) && eap->arg + i < p; ++i)
  	    ;
*** ../vim-8.0.0451/src/edit.c	2017-03-12 19:22:31.744585014 +0100
--- src/edit.c	2017-03-12 19:40:49.220838148 +0100
***************
*** 2149,2155 ****
      int	    i;
  
      /* find start of trailing white space */
!     for (i = (int)STRLEN(line) - 1; i >= 0 && vim_iswhite(line[i]); i--)
      {
  	if (State & REPLACE_FLAG)
  	    replace_join(0);	    /* remove a NUL from the replace stack */
--- 2149,2155 ----
      int	    i;
  
      /* find start of trailing white space */
!     for (i = (int)STRLEN(line) - 1; i >= 0 && VIM_ISWHITE(line[i]); i--)
      {
  	if (State & REPLACE_FLAG)
  	    replace_join(0);	    /* remove a NUL from the replace stack */
***************
*** 2358,2364 ****
  	case CTRL_X_OMNI:
  	    /* Command line and Omni completion can work with just about any
  	     * printable character, but do stop at white space. */
! 	    return vim_isprintc(c) && !vim_iswhite(c);
  
  	case CTRL_X_WHOLE_LINE:
  	    /* For while line completion a space can be part of the line. */
--- 2358,2364 ----
  	case CTRL_X_OMNI:
  	    /* Command line and Omni completion can work with just about any
  	     * printable character, but do stop at white space. */
! 	    return vim_isprintc(c) && !VIM_ISWHITE(c);
  
  	case CTRL_X_WHOLE_LINE:
  	    /* For while line completion a space can be part of the line. */
***************
*** 5989,5997 ****
  #endif
  
  #ifdef FEAT_MBYTE
! # define WHITECHAR(cc) (vim_iswhite(cc) && (!enc_utf8 || !utf_iscomposing(utf_ptr2char(ml_get_cursor() + 1))))
  #else
! # define WHITECHAR(cc) vim_iswhite(cc)
  #endif
  
  /*
--- 5989,5997 ----
  #endif
  
  #ifdef FEAT_MBYTE
! # define WHITECHAR(cc) (VIM_ISWHITE(cc) && (!enc_utf8 || !utf_iscomposing(utf_ptr2char(ml_get_cursor() + 1))))
  #else
! # define WHITECHAR(cc) VIM_ISWHITE(cc)
  #endif
  
  /*
***************
*** 6037,6043 ****
       */
      if (textwidth > 0
  	    && (force_format
! 		|| (!vim_iswhite(c)
  		    && !((State & REPLACE_FLAG)
  #ifdef FEAT_VREPLACE
  			&& !(State & VREPLACE_FLAG)
--- 6037,6043 ----
       */
      if (textwidth > 0
  	    && (force_format
! 		|| (!VIM_ISWHITE(c)
  		    && !((State & REPLACE_FLAG)
  #ifdef FEAT_VREPLACE
  			&& !(State & VREPLACE_FLAG)
***************
*** 6094,6100 ****
  		++p;
  	    middle_len = copy_option_part(&p, lead_end, COM_MAX_LEN, ",");
  	    /* Don't count trailing white space for middle_len */
! 	    while (middle_len > 0 && vim_iswhite(lead_end[middle_len - 1]))
  		--middle_len;
  
  	    /* Find the end-comment string */
--- 6094,6100 ----
  		++p;
  	    middle_len = copy_option_part(&p, lead_end, COM_MAX_LEN, ",");
  	    /* Don't count trailing white space for middle_len */
! 	    while (middle_len > 0 && VIM_ISWHITE(lead_end[middle_len - 1]))
  		--middle_len;
  
  	    /* Find the end-comment string */
***************
*** 6104,6110 ****
  
  	    /* Skip white space before the cursor */
  	    i = curwin->w_cursor.col;
! 	    while (--i >= 0 && vim_iswhite(line[i]))
  		;
  	    i++;
  
--- 6104,6110 ----
  
  	    /* Skip white space before the cursor */
  	    i = curwin->w_cursor.col;
! 	    while (--i >= 0 && VIM_ISWHITE(line[i]))
  		;
  	    i++;
  
***************
*** 6293,6299 ****
  	    )
      {
  	cc = gchar_cursor();
! 	if (vim_iswhite(cc))
  	{
  	    save_char = cc;
  	    pchar_cursor('x');
--- 6293,6299 ----
  	    )
      {
  	cc = gchar_cursor();
! 	if (VIM_ISWHITE(cc))
  	{
  	    save_char = cc;
  	    pchar_cursor('x');
***************
*** 7031,7043 ****
  	    {
  		dec_cursor();
  		cc = gchar_cursor();
! 		if (!vim_iswhite(cc))
  		    curwin->w_cursor = tpos;
  	    }
  
  	    auto_format(TRUE, FALSE);
  
! 	    if (vim_iswhite(cc))
  	    {
  		if (gchar_cursor() != NUL)
  		    inc_cursor();
--- 7031,7043 ----
  	    {
  		dec_cursor();
  		cc = gchar_cursor();
! 		if (!VIM_ISWHITE(cc))
  		    curwin->w_cursor = tpos;
  	    }
  
  	    auto_format(TRUE, FALSE);
  
! 	    if (VIM_ISWHITE(cc))
  	    {
  		if (gchar_cursor() != NUL)
  		    inc_cursor();
***************
*** 7073,7079 ****
  		if (gchar_cursor() == NUL && curwin->w_cursor.col > 0)
  		    --curwin->w_cursor.col;
  		cc = gchar_cursor();
! 		if (!vim_iswhite(cc))
  		    break;
  		if (del_char(TRUE) == FAIL)
  		    break;  /* should not happen */
--- 7073,7079 ----
  		if (gchar_cursor() == NUL && curwin->w_cursor.col > 0)
  		    --curwin->w_cursor.col;
  		cc = gchar_cursor();
! 		if (!VIM_ISWHITE(cc))
  		    break;
  		if (del_char(TRUE) == FAIL)
  		    break;  /* should not happen */
***************
*** 7223,7229 ****
  	{
  	    char_u  *ptr;
  
! 	    for (ptr = ml_get_curline(); vim_iswhite(*ptr)
  			       && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr)
  		++curwin->w_cursor.col;
  	}
--- 7223,7229 ----
  	{
  	    char_u  *ptr;
  
! 	    for (ptr = ml_get_curline(); VIM_ISWHITE(*ptr)
  			       && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr)
  		++curwin->w_cursor.col;
  	}
***************
*** 9169,9175 ****
  
  	    /* delete characters until we are at or before want_vcol */
  	    while (vcol > want_vcol
! 		    && (cc = *(ml_get_cursor() - 1), vim_iswhite(cc)))
  		ins_bs_one(&vcol);
  
  	    /* insert extra spaces until we are at want_vcol */
--- 9169,9175 ----
  
  	    /* delete characters until we are at or before want_vcol */
  	    while (vcol > want_vcol
! 		    && (cc = *(ml_get_cursor() - 1), VIM_ISWHITE(cc)))
  		ins_bs_one(&vcol);
  
  	    /* insert extra spaces until we are at want_vcol */
***************
*** 10056,10062 ****
  
  	/* Find first white before the cursor */
  	fpos = curwin->w_cursor;
! 	while (fpos.col > 0 && vim_iswhite(ptr[-1]))
  	{
  	    --fpos.col;
  	    --ptr;
--- 10056,10062 ----
  
  	/* Find first white before the cursor */
  	fpos = curwin->w_cursor;
! 	while (fpos.col > 0 && VIM_ISWHITE(ptr[-1]))
  	{
  	    --fpos.col;
  	    --ptr;
***************
*** 10077,10083 ****
  
  	/* Use as many TABs as possible.  Beware of 'breakindent', 'showbreak'
  	 * and 'linebreak' adding extra virtual columns. */
! 	while (vim_iswhite(*ptr))
  	{
  	    i = lbr_chartabsize(NULL, (char_u *)"\t", vcol);
  	    if (vcol + i > want_vcol)
--- 10077,10083 ----
  
  	/* Use as many TABs as possible.  Beware of 'breakindent', 'showbreak'
  	 * and 'linebreak' adding extra virtual columns. */
! 	while (VIM_ISWHITE(*ptr))
  	{
  	    i = lbr_chartabsize(NULL, (char_u *)"\t", vcol);
  	    if (vcol + i > want_vcol)
***************
*** 10456,10462 ****
  	    ptr = ml_get(pos->lnum);
  	    i = pos->col;
  	    if (i > 0)		/* skip blanks before '{' */
! 		while (--i > 0 && vim_iswhite(ptr[i]))
  		    ;
  	    curwin->w_cursor.lnum = pos->lnum;
  	    curwin->w_cursor.col = i;
--- 10456,10462 ----
  	    ptr = ml_get(pos->lnum);
  	    i = pos->col;
  	    if (i > 0)		/* skip blanks before '{' */
! 		while (--i > 0 && VIM_ISWHITE(ptr[i]))
  		    ;
  	    curwin->w_cursor.lnum = pos->lnum;
  	    curwin->w_cursor.col = i;
*** ../vim-8.0.0451/src/eval.c	2017-03-12 19:22:31.744585014 +0100
--- src/eval.c	2017-03-12 19:41:04.900727690 +0100
***************
*** 1516,1522 ****
  	if (error || eap->skip)
  	{
  	    arg = find_name_end(arg, NULL, NULL, FNE_INCL_BR | FNE_CHECK_START);
! 	    if (!vim_iswhite(*arg) && !ends_excmd(*arg))
  	    {
  		emsg_severe = TRUE;
  		EMSG(_(e_trailing));
--- 1516,1522 ----
  	if (error || eap->skip)
  	{
  	    arg = find_name_end(arg, NULL, NULL, FNE_INCL_BR | FNE_CHECK_START);
! 	    if (!VIM_ISWHITE(*arg) && !ends_excmd(*arg))
  	    {
  		emsg_severe = TRUE;
  		EMSG(_(e_trailing));
***************
*** 1856,1862 ****
      if (expr_start != NULL)
      {
  	/* Don't expand the name when we already know there is an error. */
! 	if (unlet && !vim_iswhite(*p) && !ends_excmd(*p)
  						    && *p != '[' && *p != '.')
  	{
  	    EMSG(_(e_trailing));
--- 1856,1862 ----
      if (expr_start != NULL)
      {
  	/* Don't expand the name when we already know there is an error. */
! 	if (unlet && !VIM_ISWHITE(*p) && !ends_excmd(*p)
  						    && *p != '[' && *p != '.')
  	{
  	    EMSG(_(e_trailing));
***************
*** 2449,2455 ****
  	return fi;
  
      expr = skipwhite(expr);
!     if (expr[0] != 'i' || expr[1] != 'n' || !vim_iswhite(expr[2]))
      {
  	EMSG(_("E690: Missing \"in\" after :for"));
  	return fi;
--- 2449,2455 ----
  	return fi;
  
      expr = skipwhite(expr);
!     if (expr[0] != 'i' || expr[1] != 'n' || !VIM_ISWHITE(expr[2]))
      {
  	EMSG(_("E690: Missing \"in\" after :for"));
  	return fi;
***************
*** 2552,2558 ****
  	    {
  		xp->xp_pattern = p;
  		MB_PTR_BACK(arg, p);
! 		if (vim_iswhite(*p))
  		    break;
  	    }
  	    return;
--- 2552,2558 ----
  	    {
  		xp->xp_pattern = p;
  		MB_PTR_BACK(arg, p);
! 		if (VIM_ISWHITE(*p))
  		    break;
  	    }
  	    return;
***************
*** 2698,2704 ****
  							     FNE_CHECK_START);
  	if (lv.ll_name == NULL)
  	    error = TRUE;	    /* error but continue parsing */
! 	if (name_end == NULL || (!vim_iswhite(*name_end)
  						   && !ends_excmd(*name_end)))
  	{
  	    if (name_end != NULL)
--- 2698,2704 ----
  							     FNE_CHECK_START);
  	if (lv.ll_name == NULL)
  	    error = TRUE;	    /* error but continue parsing */
! 	if (name_end == NULL || (!VIM_ISWHITE(*name_end)
  						   && !ends_excmd(*name_end)))
  	{
  	    if (name_end != NULL)
***************
*** 6866,6872 ****
  		|| (**arg == '.' && rettv->v_type == VAR_DICT)
  		|| (**arg == '(' && (!evaluate || rettv->v_type == VAR_FUNC
  					    || rettv->v_type == VAR_PARTIAL)))
! 	    && !vim_iswhite(*(*arg - 1)))
      {
  	if (**arg == '(')
  	{
--- 6866,6872 ----
  		|| (**arg == '.' && rettv->v_type == VAR_DICT)
  		|| (**arg == '(' && (!evaluate || rettv->v_type == VAR_FUNC
  					    || rettv->v_type == VAR_PARTIAL)))
! 	    && !VIM_ISWHITE(*(*arg - 1)))
      {
  	if (**arg == '(')
  	{
*** ../vim-8.0.0451/src/ex_cmds.c	2017-03-12 19:22:31.748584985 +0100
--- src/ex_cmds.c	2017-03-12 19:41:20.520617646 +0100
***************
*** 256,262 ****
  
      /* find the character after the last non-blank character */
      for (last = first + STRLEN(first);
! 				last > first && vim_iswhite(last[-1]); --last)
  	;
      save = *last;
      *last = NUL;
--- 256,262 ----
  
      /* find the character after the last non-blank character */
      for (last = first + STRLEN(first);
! 				last > first && VIM_ISWHITE(last[-1]); --last)
  	;
      save = *last;
      *last = NUL;
***************
*** 400,406 ****
  
      for (p = eap->arg; *p != NUL; ++p)
      {
! 	if (vim_iswhite(*p))
  	    ;
  	else if (*p == 'i')
  	    sort_ic = TRUE;
--- 400,406 ----
  
      for (p = eap->arg; *p != NUL; ++p)
      {
! 	if (VIM_ISWHITE(*p))
  	    ;
  	else if (*p == 'i')
  	    sort_ic = TRUE;
***************
*** 683,689 ****
  	did_undo = FALSE;
  	for (;;)
  	{
! 	    if (vim_iswhite(ptr[col]))
  	    {
  		if (!got_tab && num_spaces == 0)
  		{
--- 683,689 ----
  	did_undo = FALSE;
  	for (;;)
  	{
! 	    if (VIM_ISWHITE(ptr[col]))
  	    {
  		if (!got_tab && num_spaces == 0)
  		{
***************
*** 4807,4813 ****
  	which_pat = RE_SUBST;	/* use last substitute regexp */
  
  				/* new pattern and substitution */
!     if (eap->cmd[0] == 's' && *cmd != NUL && !vim_iswhite(*cmd)
  		&& vim_strchr((char_u *)"0123456789cegriIp|\"", *cmd) == NULL)
      {
  				/* don't accept alphanumeric for separator */
--- 4807,4813 ----
  	which_pat = RE_SUBST;	/* use last substitute regexp */
  
  				/* new pattern and substitution */
!     if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)
  		&& vim_strchr((char_u *)"0123456789cegriIp|\"", *cmd) == NULL)
      {
  				/* don't accept alphanumeric for separator */
***************
*** 6225,6231 ****
  
      /* remove trailing blanks */
      p = arg + STRLEN(arg) - 1;
!     while (p > arg && vim_iswhite(*p) && p[-1] != '\\')
  	*p-- = NUL;
  
  #ifdef FEAT_MULTI_LANG
--- 6225,6231 ----
  
      /* remove trailing blanks */
      p = arg + STRLEN(arg) - 1;
!     while (p > arg && VIM_ISWHITE(*p) && p[-1] != '\\')
  	*p-- = NUL;
  
  #ifdef FEAT_MULTI_LANG
***************
*** 6809,6815 ****
  	{
  	    line = ml_get_buf(curbuf, lnum, FALSE);
  	    len = (int)STRLEN(line);
! 	    if (in_example && len > 0 && !vim_iswhite(line[0]))
  	    {
  		/* End of example: non-white or '<' in first column. */
  		if (line[0] == '<')
--- 6809,6815 ----
  	{
  	    line = ml_get_buf(curbuf, lnum, FALSE);
  	    len = (int)STRLEN(line);
! 	    if (in_example && len > 0 && !VIM_ISWHITE(line[0]))
  	    {
  		/* End of example: non-white or '<' in first column. */
  		if (line[0] == '<')
***************
*** 7421,7427 ****
      int		add_help_tags = FALSE;
  
      /* Check for ":helptags ++t {dir}". */
!     if (STRNCMP(eap->arg, "++t", 3) == 0 && vim_iswhite(eap->arg[3]))
      {
  	add_help_tags = TRUE;
  	eap->arg = skipwhite(eap->arg + 3);
--- 7421,7427 ----
      int		add_help_tags = FALSE;
  
      /* Check for ":helptags ++t {dir}". */
!     if (STRNCMP(eap->arg, "++t", 3) == 0 && VIM_ISWHITE(eap->arg[3]))
      {
  	add_help_tags = TRUE;
  	eap->arg = skipwhite(eap->arg + 3);
***************
*** 7754,7760 ****
  	if (VIM_ISDIGIT(*arg))
  	{
  	    id = getdigits(&arg);
! 	    if (!vim_iswhite(*arg) && *arg != NUL)
  	    {
  		id = -1;
  		arg = arg1;
--- 7754,7760 ----
  	if (VIM_ISDIGIT(*arg))
  	{
  	    id = getdigits(&arg);
! 	    if (!VIM_ISWHITE(*arg) && *arg != NUL)
  	    {
  		id = -1;
  		arg = arg1;
*** ../vim-8.0.0451/src/ex_cmds2.c	2017-03-12 19:22:31.748584985 +0100
--- src/ex_cmds2.c	2017-03-12 19:41:30.540547052 +0100
***************
*** 5183,5189 ****
       * Allow abbreviation, but require at least 3 characters to avoid
       * confusion with a two letter language name "me" or "ct". */
      p = skiptowhite(eap->arg);
!     if ((*p == NUL || vim_iswhite(*p)) && p - eap->arg >= 3)
      {
  	if (STRNICMP(eap->arg, "messages", p - eap->arg) == 0)
  	{
--- 5183,5189 ----
       * Allow abbreviation, but require at least 3 characters to avoid
       * confusion with a two letter language name "me" or "ct". */
      p = skiptowhite(eap->arg);
!     if ((*p == NUL || VIM_ISWHITE(*p)) && p - eap->arg >= 3)
      {
  	if (STRNICMP(eap->arg, "messages", p - eap->arg) == 0)
  	{
*** ../vim-8.0.0451/src/ex_docmd.c	2017-03-12 19:22:31.748584985 +0100
--- src/ex_docmd.c	2017-03-12 19:41:57.552356727 +0100
***************
*** 2013,2019 ****
  			if (save_msg_silent == -1)
  			    save_msg_silent = msg_silent;
  			++msg_silent;
! 			if (*ea.cmd == '!' && !vim_iswhite(ea.cmd[-1]))
  			{
  			    /* ":silent!", but not "silent !cmd" */
  			    ea.cmd = skipwhite(ea.cmd + 1);
--- 2013,2019 ----
  			if (save_msg_silent == -1)
  			    save_msg_silent = msg_silent;
  			++msg_silent;
! 			if (*ea.cmd == '!' && !VIM_ISWHITE(ea.cmd[-1]))
  			{
  			    /* ":silent!", but not "silent !cmd" */
  			    ea.cmd = skipwhite(ea.cmd + 1);
***************
*** 2771,2777 ****
       */
      if ((ea.argt & COUNT) && VIM_ISDIGIT(*ea.arg)
  	    && (!(ea.argt & BUFNAME) || *(p = skipdigits(ea.arg)) == NUL
! 							  || vim_iswhite(*p)))
      {
  	n = getdigits(&ea.arg);
  	ea.arg = skipwhite(ea.arg);
--- 2771,2777 ----
       */
      if ((ea.argt & COUNT) && VIM_ISDIGIT(*ea.arg)
  	    && (!(ea.argt & BUFNAME) || *(p = skipdigits(ea.arg)) == NUL
! 							  || VIM_ISWHITE(*p)))
      {
  	n = getdigits(&ea.arg);
  	ea.arg = skipwhite(ea.arg);
***************
*** 2939,2945 ****
  	else
  	{
  	    p = ea.arg + STRLEN(ea.arg);
! 	    while (p > ea.arg && vim_iswhite(p[-1]))
  		--p;
  	}
  	ea.line2 = buflist_findpat(ea.arg, p, (ea.argt & BUFUNL) != 0,
--- 2939,2945 ----
  	else
  	{
  	    p = ea.arg + STRLEN(ea.arg);
! 	    while (p > ea.arg && VIM_ISWHITE(p[-1]))
  		--p;
  	}
  	ea.line2 = buflist_findpat(ea.arg, p, (ea.argt & BUFUNL) != 0,
***************
*** 3757,3763 ****
  	    }
  	    /* An argument can contain just about everything, except
  	     * characters that end the command and white space. */
! 	    else if (c == '|' || c == '\n' || c == '"' || (vim_iswhite(c)
  #ifdef SPACE_IN_FILENAME
  					 && (!(ea.argt & NOSPC) || usefilter)
  #endif
--- 3757,3763 ----
  	    }
  	    /* An argument can contain just about everything, except
  	     * characters that end the command and white space. */
! 	    else if (c == '|' || c == '\n' || c == '"' || (VIM_ISWHITE(c)
  #ifdef SPACE_IN_FILENAME
  					 && (!(ea.argt & NOSPC) || usefilter)
  #endif
***************
*** 5136,5142 ****
  			/* skip escaped characters */
  			if (p[1] && (*p == '\\' || *p == Ctrl_V))
  			    ++p;
! 			else if (vim_iswhite(*p))
  			{
  			    *errormsgp = (char_u *)_("E172: Only one file name allowed");
  			    return FAIL;
--- 5136,5142 ----
  			/* skip escaped characters */
  			if (p[1] && (*p == '\\' || *p == Ctrl_V))
  			    ++p;
! 			else if (VIM_ISWHITE(*p))
  			{
  			    *errormsgp = (char_u *)_("E172: Only one file name allowed");
  			    return FAIL;
***************
*** 6336,6342 ****
      if (ASCII_ISALPHA(*p))
  	while (ASCII_ISALNUM(*p))
  	    ++p;
!     if (!ends_excmd(*p) && !vim_iswhite(*p))
      {
  	EMSG(_("E182: Invalid command name"));
  	return;
--- 6336,6342 ----
      if (ASCII_ISALPHA(*p))
  	while (ASCII_ISALNUM(*p))
  	    ++p;
!     if (!ends_excmd(*p) && !VIM_ISWHITE(*p))
      {
  	EMSG(_("E182: Invalid command name"));
  	return;
***************
*** 6464,6470 ****
  	    len += 2;
  	    p += 2;
  	}
! 	else if (p[0] == '\\' && vim_iswhite(p[1]))
  	{
  	    len += 1;
  	    p += 2;
--- 6464,6470 ----
  	    len += 2;
  	    p += 2;
  	}
! 	else if (p[0] == '\\' && VIM_ISWHITE(p[1]))
  	{
  	    len += 1;
  	    p += 2;
***************
*** 6474,6480 ****
  	    len += 2;
  	    p += 1;
  	}
! 	else if (vim_iswhite(*p))
  	{
  	    p = skipwhite(p);
  	    if (*p == NUL)
--- 6474,6480 ----
  	    len += 2;
  	    p += 1;
  	}
! 	else if (VIM_ISWHITE(*p))
  	{
  	    p = skipwhite(p);
  	    if (*p == NUL)
***************
*** 6512,6518 ****
  	    *q++ = '\\';
  	    p += 2;
  	}
! 	else if (p[0] == '\\' && vim_iswhite(p[1]))
  	{
  	    *q++ = p[1];
  	    p += 2;
--- 6512,6518 ----
  	    *q++ = '\\';
  	    p += 2;
  	}
! 	else if (p[0] == '\\' && VIM_ISWHITE(p[1]))
  	{
  	    *q++ = p[1];
  	    p += 2;
***************
*** 6522,6528 ****
  	    *q++ = '\\';
  	    *q++ = *p++;
  	}
! 	else if (vim_iswhite(*p))
  	{
  	    p = skipwhite(p);
  	    if (*p == NUL)
--- 6522,6528 ----
  	    *q++ = '\\';
  	    *q++ = *p++;
  	}
! 	else if (VIM_ISWHITE(*p))
  	{
  	    p = skipwhite(p);
  	    if (*p == NUL)
***************
*** 7078,7084 ****
      {
  	char_u	*err = value;
  
! 	for (i = 0; err[i] != NUL && !vim_iswhite(err[i]); i++)
  	    ;
  	err[i] = NUL;
  	EMSG2(_("E180: Invalid address type value: %s"), err);
--- 7078,7084 ----
      {
  	char_u	*err = value;
  
! 	for (i = 0; err[i] != NUL && !VIM_ISWHITE(err[i]); i++)
  	    ;
  	err[i] = NUL;
  	EMSG2(_("E180: Invalid address type value: %s"), err);
***************
*** 12264,12270 ****
      if (ends_excmd(*eap->arg))
  	end = eap->arg;
      else if ((STRNICMP(eap->arg, "none", 4) == 0
! 		&& (vim_iswhite(eap->arg[4]) || ends_excmd(eap->arg[4]))))
  	end = eap->arg + 4;
      else
      {
--- 12264,12270 ----
      if (ends_excmd(*eap->arg))
  	end = eap->arg;
      else if ((STRNICMP(eap->arg, "none", 4) == 0
! 		&& (VIM_ISWHITE(eap->arg[4]) || ends_excmd(eap->arg[4]))))
  	end = eap->arg + 4;
      else
      {
*** ../vim-8.0.0451/src/ex_getln.c	2017-03-12 19:22:31.752584957 +0100
--- src/ex_getln.c	2017-03-12 19:42:14.276238880 +0100
***************
*** 6027,6033 ****
  		if (p == NULL)
  		    break;
  		++p;
! 		for (i = 0; p[i] && !vim_iswhite(p[i]); ++i)
  		    if (p[i] == '\\' && p[i + 1])
  			++i;
  		STRMOVE(p, p + i);
--- 6027,6033 ----
  		if (p == NULL)
  		    break;
  		++p;
! 		for (i = 0; p[i] && !VIM_ISWHITE(p[i]); ++i)
  		    if (p[i] == '\\' && p[i + 1])
  			++i;
  		STRMOVE(p, p + i);
*** ../vim-8.0.0451/src/fileio.c	2017-03-12 19:22:31.752584957 +0100
--- src/fileio.c	2017-03-12 19:42:32.656109355 +0100
***************
*** 8163,8169 ****
      int		len;
  
      /* the event name ends with end of line, '|', a blank or a comma */
!     for (p = start; *p && !vim_iswhite(*p) && *p != ',' && *p != '|'; ++p)
  	;
      for (i = 0; event_names[i].name != NULL; ++i)
      {
--- 8163,8169 ----
      int		len;
  
      /* the event name ends with end of line, '|', a blank or a comma */
!     for (p = start; *p && !VIM_ISWHITE(*p) && *p != ',' && *p != '|'; ++p)
  	;
      for (i = 0; event_names[i].name != NULL; ++i)
      {
***************
*** 8206,8212 ****
  
      if (*arg == '*')
      {
! 	if (arg[1] && !vim_iswhite(arg[1]))
  	{
  	    EMSG2(_("E215: Illegal character after *: %s"), arg);
  	    return NULL;
--- 8206,8212 ----
  
      if (*arg == '*')
      {
! 	if (arg[1] && !VIM_ISWHITE(arg[1]))
  	{
  	    EMSG2(_("E215: Illegal character after *: %s"), arg);
  	    return NULL;
***************
*** 8215,8221 ****
      }
      else
      {
! 	for (pat = arg; *pat && *pat != '|' && !vim_iswhite(*pat); pat = p)
  	{
  	    if ((int)event_name2nr(pat, &p) >= (int)NUM_EVENTS)
  	    {
--- 8215,8221 ----
      }
      else
      {
! 	for (pat = arg; *pat && *pat != '|' && !VIM_ISWHITE(*pat); pat = p)
  	{
  	    if ((int)event_name2nr(pat, &p) >= (int)NUM_EVENTS)
  	    {
***************
*** 8394,8400 ****
  	 * Scan over the pattern.  Put a NUL at the end.
  	 */
  	cmd = pat;
! 	while (*cmd && (!vim_iswhite(*cmd) || cmd[-1] == '\\'))
  	    cmd++;
  	if (*cmd)
  	    *cmd++ = NUL;
--- 8394,8400 ----
  	 * Scan over the pattern.  Put a NUL at the end.
  	 */
  	cmd = pat;
! 	while (*cmd && (!VIM_ISWHITE(*cmd) || cmd[-1] == '\\'))
  	    cmd++;
  	if (*cmd)
  	    *cmd++ = NUL;
***************
*** 8420,8426 ****
  	 * Check for "nested" flag.
  	 */
  	cmd = skipwhite(cmd);
! 	if (*cmd != NUL && STRNCMP(cmd, "nested", 6) == 0 && vim_iswhite(cmd[6]))
  	{
  	    nested = TRUE;
  	    cmd = skipwhite(cmd + 6);
--- 8420,8426 ----
  	 * Check for "nested" flag.
  	 */
  	cmd = skipwhite(cmd);
! 	if (*cmd != NUL && STRNCMP(cmd, "nested", 6) == 0 && VIM_ISWHITE(cmd[6]))
  	{
  	    nested = TRUE;
  	    cmd = skipwhite(cmd + 6);
***************
*** 8463,8469 ****
      }
      else
      {
! 	while (*arg && *arg != '|' && !vim_iswhite(*arg))
  	    if (do_autocmd_event(event_name2nr(arg, &arg), pat,
  					nested,	cmd, forceit, group) == FAIL)
  		break;
--- 8463,8469 ----
      }
      else
      {
! 	while (*arg && *arg != '|' && !VIM_ISWHITE(*arg))
  	    if (do_autocmd_event(event_name2nr(arg, &arg), pat,
  					nested,	cmd, forceit, group) == FAIL)
  		break;
***************
*** 8488,8494 ****
      char_u	*arg = *argp;
      int		group = AUGROUP_ALL;
  
!     for (p = arg; *p && !vim_iswhite(*p) && *p != '|'; ++p)
  	;
      if (p > arg)
      {
--- 8488,8494 ----
      char_u	*arg = *argp;
      int		group = AUGROUP_ALL;
  
!     for (p = arg; *p && !VIM_ISWHITE(*p) && *p != '|'; ++p)
  	;
      if (p > arg)
      {
***************
*** 8800,8806 ****
      /*
       * Loop over the events.
       */
!     while (*arg && !vim_iswhite(*arg))
  	if (apply_autocmds_group(event_name2nr(arg, &arg),
  				      fname, NULL, TRUE, group, curbuf, NULL))
  	    nothing_done = FALSE;
--- 8800,8806 ----
      /*
       * Loop over the events.
       */
!     while (*arg && !VIM_ISWHITE(*arg))
  	if (apply_autocmds_group(event_name2nr(arg, &arg),
  				      fname, NULL, TRUE, group, curbuf, NULL))
  	    nothing_done = FALSE;
***************
*** 9916,9929 ****
      if (group == AUGROUP_ERROR)
  	return NULL;
      /* If there only is a group name that's what we expand. */
!     if (*arg == NUL && group != AUGROUP_ALL && !vim_iswhite(arg[-1]))
      {
  	arg = p;
  	group = AUGROUP_ALL;
      }
  
      /* skip over event name */
!     for (p = arg; *p != NUL && !vim_iswhite(*p); ++p)
  	if (*p == ',')
  	    arg = p + 1;
      if (*p == NUL)
--- 9916,9929 ----
      if (group == AUGROUP_ERROR)
  	return NULL;
      /* If there only is a group name that's what we expand. */
!     if (*arg == NUL && group != AUGROUP_ALL && !VIM_ISWHITE(arg[-1]))
      {
  	arg = p;
  	group = AUGROUP_ALL;
      }
  
      /* skip over event name */
!     for (p = arg; *p != NUL && !VIM_ISWHITE(*p); ++p)
  	if (*p == ',')
  	    arg = p + 1;
      if (*p == NUL)
***************
*** 9937,9943 ****
  
      /* skip over pattern */
      arg = skipwhite(p);
!     while (*arg && (!vim_iswhite(*arg) || arg[-1] == '\\'))
  	arg++;
      if (*arg)
  	return arg;			    /* expand (next) command */
--- 9937,9943 ----
  
      /* skip over pattern */
      arg = skipwhite(p);
!     while (*arg && (!VIM_ISWHITE(*arg) || arg[-1] == '\\'))
  	arg++;
      if (*arg)
  	return arg;			    /* expand (next) command */
*** ../vim-8.0.0451/src/getchar.c	2017-03-02 23:05:45.545710576 +0100
--- src/getchar.c	2017-03-12 19:42:53.691961099 +0100
***************
*** 2651,2657 ****
  				ptr = ml_get_curline();
  				while (col < curwin->w_cursor.col)
  				{
! 				    if (!vim_iswhite(ptr[col]))
  					curwin->w_wcol = vcol;
  				    vcol += lbr_chartabsize(ptr, ptr + col,
  							       (colnr_T)vcol);
--- 2651,2657 ----
  				ptr = ml_get_curline();
  				while (col < curwin->w_cursor.col)
  				{
! 				    if (!VIM_ISWHITE(ptr[col]))
  					curwin->w_wcol = vcol;
  				    vcol += lbr_chartabsize(ptr, ptr + col,
  							       (colnr_T)vcol);
***************
*** 3324,3330 ****
       */
      p = keys;
      do_backslash = (vim_strchr(p_cpo, CPO_BSLASH) == NULL);
!     while (*p && (maptype == 1 || !vim_iswhite(*p)))
      {
  	if ((p[0] == Ctrl_V || (do_backslash && p[0] == '\\')) &&
  								  p[1] != NUL)
--- 3324,3330 ----
       */
      p = keys;
      do_backslash = (vim_strchr(p_cpo, CPO_BSLASH) == NULL);
!     while (*p && (maptype == 1 || !VIM_ISWHITE(*p)))
      {
  	if ((p[0] == Ctrl_V || (do_backslash && p[0] == '\\')) &&
  								  p[1] != NUL)
***************
*** 3429,3435 ****
  			}
  	    /* An abbreviation cannot contain white space. */
  	    for (n = 0; n < len; ++n)
! 		if (vim_iswhite(keys[n]))
  		{
  		    retval = 1;
  		    goto theend;
--- 3429,3435 ----
  			}
  	    /* An abbreviation cannot contain white space. */
  	    for (n = 0; n < len; ++n)
! 		if (VIM_ISWHITE(keys[n]))
  		{
  		    retval = 1;
  		    goto theend;
***************
*** 5043,5049 ****
  	 * interpreted as the start of a special key name.
  	 * A space in the lhs of a :map needs a CTRL-V.
  	 */
! 	if (what == 2 && (vim_iswhite(c) || c == '"' || c == '\\'))
  	{
  	    if (putc('\\', fd) < 0)
  		return FAIL;
--- 5043,5049 ----
  	 * interpreted as the start of a special key name.
  	 * A space in the lhs of a :map needs a CTRL-V.
  	 */
! 	if (what == 2 && (VIM_ISWHITE(c) || c == '"' || c == '\\'))
  	{
  	    if (putc('\\', fd) < 0)
  		return FAIL;
*** ../vim-8.0.0451/src/gui.c	2017-03-12 19:22:31.752584957 +0100
--- src/gui.c	2017-03-12 19:43:05.047881060 +0100
***************
*** 4967,4973 ****
       */
      if (arg[0] == '-'
  	    && (arg[1] == 'f' || arg[1] == 'b')
! 	    && (arg[2] == NUL || vim_iswhite(arg[2])))
      {
  	gui.dofork = (arg[1] == 'b');
  	eap->arg = skipwhite(eap->arg + 2);
--- 4967,4973 ----
       */
      if (arg[0] == '-'
  	    && (arg[1] == 'f' || arg[1] == 'b')
! 	    && (arg[2] == NUL || VIM_ISWHITE(arg[2])))
      {
  	gui.dofork = (arg[1] == 'b');
  	eap->arg = skipwhite(eap->arg + 2);
*** ../vim-8.0.0451/src/gui_w32.c	2017-02-01 13:43:32.530844971 +0100
--- src/gui_w32.c	2017-03-12 19:43:15.891804627 +0100
***************
*** 7112,7118 ****
  #else
  	    l = 1;
  #endif
! 	    if (l == 1 && vim_iswhite(*pend)
  					&& textWidth > maxDialogWidth * 3 / 4)
  		last_white = pend;
  	    textWidth += GetTextWidthEnc(hdc, pend, l);
--- 7112,7118 ----
  #else
  	    l = 1;
  #endif
! 	    if (l == 1 && VIM_ISWHITE(*pend)
  					&& textWidth > maxDialogWidth * 3 / 4)
  		last_white = pend;
  	    textWidth += GetTextWidthEnc(hdc, pend, l);
***************
*** 8581,8586 ****
--- 8581,8587 ----
  gui_mch_post_balloon(BalloonEval *beval, char_u *mesg)
  {
      POINT   pt;
+ 
      // TRACE0("gui_mch_post_balloon {{{");
      if (beval->showState == ShS_SHOWING)
  	return;
***************
*** 8588,8595 ****
      ScreenToClient(s_textArea, &pt);
  
      if (abs(beval->x - pt.x) < 3 && abs(beval->y - pt.y) < 3)
- 	/* cursor is still here */
      {
  	gui_mch_disable_beval_area(cur_beval);
  	beval->showState = ShS_SHOWING;
  	make_tooltip(beval, (char *)mesg, pt);
--- 8589,8596 ----
      ScreenToClient(s_textArea, &pt);
  
      if (abs(beval->x - pt.x) < 3 && abs(beval->y - pt.y) < 3)
      {
+ 	/* cursor is still here */
  	gui_mch_disable_beval_area(cur_beval);
  	beval->showState = ShS_SHOWING;
  	make_tooltip(beval, (char *)mesg, pt);
*** ../vim-8.0.0451/src/if_cscope.c	2017-03-05 17:43:10.616245604 +0100
--- src/if_cscope.c	2017-03-12 19:43:26.727728246 +0100
***************
*** 781,787 ****
       * they may want to use the leading white space. */
      pat = pattern;
      if (search != 4 && search != 6)
! 	while vim_iswhite(*pat)
  	    ++pat;
  
      if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
--- 781,787 ----
       * they may want to use the leading white space. */
      pat = pattern;
      if (search != 4 && search != 6)
! 	while VIM_ISWHITE(*pat)
  	    ++pat;
  
      if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
*** ../vim-8.0.0451/src/mbyte.c	2017-03-12 19:22:31.756584930 +0100
--- src/mbyte.c	2017-03-12 19:43:39.155640639 +0100
***************
*** 886,892 ****
  {
      if (MB_BYTE2LEN(p[0]) == 1)
      {
! 	if (p[0] == NUL || vim_iswhite(p[0]))
  	    return 0;
  	if (vim_iswordc_buf(p[0], buf))
  	    return 2;
--- 886,892 ----
  {
      if (MB_BYTE2LEN(p[0]) == 1)
      {
! 	if (p[0] == NUL || VIM_ISWHITE(p[0]))
  	    return 0;
  	if (vim_iswordc_buf(p[0], buf))
  	    return 2;
*** ../vim-8.0.0451/src/menu.c	2017-03-12 19:22:31.756584930 +0100
--- src/menu.c	2017-03-12 19:44:24.191323136 +0100
***************
*** 167,175 ****
      for (p = arg; *p; ++p)
  	if (!VIM_ISDIGIT(*p) && *p != '.')
  	    break;
!     if (vim_iswhite(*p))
      {
! 	for (i = 0; i < MENUDEPTH && !vim_iswhite(*arg); ++i)
  	{
  	    pri_tab[i] = getdigits(&arg);
  	    if (pri_tab[i] == 0)
--- 167,175 ----
      for (p = arg; *p; ++p)
  	if (!VIM_ISDIGIT(*p) && *p != '.')
  	    break;
!     if (VIM_ISWHITE(*p))
      {
! 	for (i = 0; i < MENUDEPTH && !VIM_ISWHITE(*arg); ++i)
  	{
  	    pri_tab[i] = getdigits(&arg);
  	    if (pri_tab[i] == 0)
***************
*** 193,204 ****
      /*
       * Check for "disable" or "enable" argument.
       */
!     if (STRNCMP(arg, "enable", 6) == 0 && vim_iswhite(arg[6]))
      {
  	enable = TRUE;
  	arg = skipwhite(arg + 6);
      }
!     else if (STRNCMP(arg, "disable", 7) == 0 && vim_iswhite(arg[7]))
      {
  	enable = FALSE;
  	arg = skipwhite(arg + 7);
--- 193,204 ----
      /*
       * Check for "disable" or "enable" argument.
       */
!     if (STRNCMP(arg, "enable", 6) == 0 && VIM_ISWHITE(arg[6]))
      {
  	enable = TRUE;
  	arg = skipwhite(arg + 6);
      }
!     else if (STRNCMP(arg, "disable", 7) == 0 && VIM_ISWHITE(arg[7]))
      {
  	enable = FALSE;
  	arg = skipwhite(arg + 7);
***************
*** 1219,1242 ****
  	if (!VIM_ISDIGIT(*p) && *p != '.')
  	    break;
  
!     if (!vim_iswhite(*p))
      {
  	if (STRNCMP(arg, "enable", 6) == 0
! 		&& (arg[6] == NUL ||  vim_iswhite(arg[6])))
  	    p = arg + 6;
  	else if (STRNCMP(arg, "disable", 7) == 0
! 		&& (arg[7] == NUL || vim_iswhite(arg[7])))
  	    p = arg + 7;
  	else
  	    p = arg;
      }
  
!     while (*p != NUL && vim_iswhite(*p))
  	++p;
  
      arg = after_dot = p;
  
!     for (; *p && !vim_iswhite(*p); ++p)
      {
  	if ((*p == '\\' || *p == Ctrl_V) && p[1] != NUL)
  	    p++;
--- 1219,1242 ----
  	if (!VIM_ISDIGIT(*p) && *p != '.')
  	    break;
  
!     if (!VIM_ISWHITE(*p))
      {
  	if (STRNCMP(arg, "enable", 6) == 0
! 		&& (arg[6] == NUL ||  VIM_ISWHITE(arg[6])))
  	    p = arg + 6;
  	else if (STRNCMP(arg, "disable", 7) == 0
! 		&& (arg[7] == NUL || VIM_ISWHITE(arg[7])))
  	    p = arg + 7;
  	else
  	    p = arg;
      }
  
!     while (*p != NUL && VIM_ISWHITE(*p))
  	++p;
  
      arg = after_dot = p;
  
!     for (; *p && !VIM_ISWHITE(*p); ++p)
      {
  	if ((*p == '\\' || *p == Ctrl_V) && p[1] != NUL)
  	    p++;
***************
*** 1247,1253 ****
      /* ":tearoff" and ":popup" only use menus, not entries */
      expand_menus = !((*cmd == 't' && cmd[1] == 'e') || *cmd == 'p');
      expand_emenu = (*cmd == 'e');
!     if (expand_menus && vim_iswhite(*p))
  	return NULL;	/* TODO: check for next command? */
      if (*p == NUL)		/* Complete the menu name */
      {
--- 1247,1253 ----
      /* ":tearoff" and ":popup" only use menus, not entries */
      expand_menus = !((*cmd == 't' && cmd[1] == 'e') || *cmd == 'p');
      expand_emenu = (*cmd == 'e');
!     if (expand_menus && VIM_ISWHITE(*p))
  	return NULL;	/* TODO: check for next command? */
      if (*p == NUL)		/* Complete the menu name */
      {
***************
*** 2432,2438 ****
      static char_u *
  menu_skip_part(char_u *p)
  {
!     while (*p != NUL && *p != '.' && !vim_iswhite(*p))
      {
  	if ((*p == '\\' || *p == Ctrl_V) && p[1] != NUL)
  	    ++p;
--- 2432,2438 ----
      static char_u *
  menu_skip_part(char_u *p)
  {
!     while (*p != NUL && *p != '.' && !VIM_ISWHITE(*p))
      {
  	if ((*p == '\\' || *p == Ctrl_V) && p[1] != NUL)
  	    ++p;
***************
*** 2500,2506 ****
  {
      char_u	*arg = arg_start;
  
!     while (*arg && !vim_iswhite(*arg))
      {
  	if ((*arg == '\\' || *arg == Ctrl_V) && arg[1] != NUL)
  	    arg++;
--- 2500,2506 ----
  {
      char_u	*arg = arg_start;
  
!     while (*arg && !VIM_ISWHITE(*arg))
      {
  	if ((*arg == '\\' || *arg == Ctrl_V) && arg[1] != NUL)
  	    arg++;
*** ../vim-8.0.0451/src/message.c	2017-03-12 19:22:31.756584930 +0100
--- src/message.c	2017-03-12 19:44:33.539257226 +0100
***************
*** 1789,1795 ****
      if (list && lcs_trail)
      {
  	trail = s + STRLEN(s);
! 	while (trail > s && vim_iswhite(trail[-1]))
  	    --trail;
      }
  
--- 1789,1795 ----
      if (list && lcs_trail)
      {
  	trail = s + STRLEN(s);
! 	while (trail > s && VIM_ISWHITE(trail[-1]))
  	    --trail;
      }
  
*** ../vim-8.0.0451/src/misc1.c	2017-03-12 19:22:31.760584901 +0100
--- src/misc1.c	2017-03-12 19:45:05.715030341 +0100
***************
*** 139,145 ****
  	    ind_done = 0;
  
  	    /* count as many characters as we can use */
! 	    while (todo > 0 && vim_iswhite(*p))
  	    {
  		if (*p == TAB)
  		{
--- 139,145 ----
  	    ind_done = 0;
  
  	    /* count as many characters as we can use */
! 	    while (todo > 0 && VIM_ISWHITE(*p))
  	    {
  		if (*p == TAB)
  		{
***************
*** 202,208 ****
      }
  
      /* Return if the indent is OK already. */
!     if (!doit && !vim_iswhite(*p) && !(flags & SIN_INSERT))
  	return FALSE;
  
      /* Allocate memory for the new line. */
--- 202,208 ----
      }
  
      /* Return if the indent is OK already. */
!     if (!doit && !VIM_ISWHITE(*p) && !(flags & SIN_INSERT))
  	return FALSE;
  
      /* Allocate memory for the new line. */
***************
*** 234,240 ****
  
  	/* Skip over any additional white space (useful when newindent is less
  	 * than old) */
! 	while (vim_iswhite(*p))
  	    ++p;
  
      }
--- 234,240 ----
  
  	/* Skip over any additional white space (useful when newindent is less
  	 * than old) */
! 	while (VIM_ISWHITE(*p))
  	    ++p;
  
      }
***************
*** 258,264 ****
  	    p = oldline;
  	    ind_done = 0;
  
! 	    while (todo > 0 && vim_iswhite(*p))
  	    {
  		if (*p == TAB)
  		{
--- 258,264 ----
  	    p = oldline;
  	    ind_done = 0;
  
! 	    while (todo > 0 && VIM_ISWHITE(*p))
  	    {
  		if (*p == TAB)
  		{
***************
*** 357,363 ****
  	s = src;
  
  	/* Count/copy the usable portion of the source line */
! 	while (todo > 0 && vim_iswhite(*s))
  	{
  	    if (*s == TAB)
  	    {
--- 357,363 ----
  	s = src;
  
  	/* Count/copy the usable portion of the source line */
! 	while (todo > 0 && VIM_ISWHITE(*s))
  	{
  	    if (*s == TAB)
  	    {
***************
*** 820,826 ****
  		{
  		    /* Find last non-blank in line */
  		    p = ptr + STRLEN(ptr) - 1;
! 		    while (p > ptr && vim_iswhite(*p))
  			--p;
  		    last_char = *p;
  
--- 820,826 ----
  		{
  		    /* Find last non-blank in line */
  		    p = ptr + STRLEN(ptr) - 1;
! 		    while (p > ptr && VIM_ISWHITE(*p))
  			--p;
  		    last_char = *p;
  
***************
*** 831,837 ****
  		    {
  			if (p > ptr)
  			    --p;
! 			while (p > ptr && vim_iswhite(*p))
  			    --p;
  		    }
  		    /*
--- 831,837 ----
  		    {
  			if (p > ptr)
  			    --p;
! 			while (p > ptr && VIM_ISWHITE(*p))
  			    --p;
  		    }
  		    /*
***************
*** 1020,1026 ****
  		     * comment leader, then put a space after the middle
  		     * comment leader on the next line.
  		     */
! 		    if (!vim_iswhite(saved_line[lead_len - 1])
  			    && ((p_extra != NULL
  				    && (int)curwin->w_cursor.col == lead_len)
  				|| (p_extra == NULL
--- 1020,1026 ----
  		     * comment leader, then put a space after the middle
  		     * comment leader on the next line.
  		     */
! 		    if (!VIM_ISWHITE(saved_line[lead_len - 1])
  			    && ((p_extra != NULL
  				    && (int)curwin->w_cursor.col == lead_len)
  				|| (p_extra == NULL
***************
*** 1124,1130 ****
  		    {
  			/* find last non-white in the leader to line up with */
  			for (p = leader + lead_len - 1; p > leader
! 						      && vim_iswhite(*p); --p)
  			    ;
  			++p;
  
--- 1124,1130 ----
  		    {
  			/* find last non-white in the leader to line up with */
  			for (p = leader + lead_len - 1; p > leader
! 						      && VIM_ISWHITE(*p); --p)
  			    ;
  			++p;
  
***************
*** 1180,1186 ****
  			    }
  			    else
  #endif
! 			    if (!vim_iswhite(*p))
  				*p = ' ';
  			}
  		    }
--- 1180,1186 ----
  			    }
  			    else
  #endif
! 			    if (!VIM_ISWHITE(*p))
  				*p = ' ';
  			}
  		    }
***************
*** 1217,1223 ****
  			 * leader by spaces.  Keep Tabs, the indent must
  			 * remain the same. */
  			for (p += lead_repl_len; p < leader + lead_len; ++p)
! 			    if (!vim_iswhite(*p))
  			    {
  				/* Don't put a space before a TAB. */
  				if (p + 1 < leader + lead_len && p[1] == TAB)
--- 1217,1223 ----
  			 * leader by spaces.  Keep Tabs, the indent must
  			 * remain the same. */
  			for (p += lead_repl_len; p < leader + lead_len; ++p)
! 			    if (!VIM_ISWHITE(*p))
  			    {
  				/* Don't put a space before a TAB. */
  				if (p + 1 < leader + lead_len && p[1] == TAB)
***************
*** 1282,1288 ****
  
  		    /* If the leader ends in white space, don't add an
  		     * extra space */
! 		    if (lead_len > 0 && vim_iswhite(leader[lead_len - 1]))
  			extra_space = FALSE;
  		    leader[lead_len] = NUL;
  		}
--- 1282,1288 ----
  
  		    /* If the leader ends in white space, don't add an
  		     * extra space */
! 		    if (lead_len > 0 && VIM_ISWHITE(leader[lead_len - 1]))
  			extra_space = FALSE;
  		    leader[lead_len] = NUL;
  		}
***************
*** 1305,1311 ****
  #endif
  					   )
  		{
! 		    while (lead_len && vim_iswhite(*leader))
  		    {
  			--lead_len;
  			--newcol;
--- 1305,1311 ----
  #endif
  					   )
  		{
! 		    while (lead_len && VIM_ISWHITE(*leader))
  		    {
  			--lead_len;
  			--newcol;
***************
*** 1680,1686 ****
      char_u	*saved_flags = NULL;
  
      result = i = 0;
!     while (vim_iswhite(line[i]))    /* leading white space is ignored */
  	++i;
  
      /*
--- 1680,1686 ----
      char_u	*saved_flags = NULL;
  
      result = i = 0;
!     while (VIM_ISWHITE(line[i]))    /* leading white space is ignored */
  	++i;
  
      /*
***************
*** 1725,1735 ****
  	     * When string starts with white space, must have some white space
  	     * (but the amount does not need to match, there might be a mix of
  	     * TABs and spaces). */
! 	    if (vim_iswhite(string[0]))
  	    {
! 		if (i == 0 || !vim_iswhite(line[i - 1]))
  		    continue;  /* missing white space */
! 		while (vim_iswhite(string[0]))
  		    ++string;
  	    }
  	    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)
--- 1725,1735 ----
  	     * When string starts with white space, must have some white space
  	     * (but the amount does not need to match, there might be a mix of
  	     * TABs and spaces). */
! 	    if (VIM_ISWHITE(string[0]))
  	    {
! 		if (i == 0 || !VIM_ISWHITE(line[i - 1]))
  		    continue;  /* missing white space */
! 		while (VIM_ISWHITE(string[0]))
  		    ++string;
  	    }
  	    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)
***************
*** 1740,1746 ****
  	    /* When 'b' flag used, there must be white space or an
  	     * end-of-line after the string in the line. */
  	    if (vim_strchr(part_buf, COM_BLANK) != NULL
! 			   && !vim_iswhite(line[i + j]) && line[i + j] != NUL)
  		continue;
  
  	    /* We have found a match, stop searching unless this is a middle
--- 1740,1746 ----
  	    /* When 'b' flag used, there must be white space or an
  	     * end-of-line after the string in the line. */
  	    if (vim_strchr(part_buf, COM_BLANK) != NULL
! 			   && !VIM_ISWHITE(line[i + j]) && line[i + j] != NUL)
  		continue;
  
  	    /* We have found a match, stop searching unless this is a middle
***************
*** 1785,1791 ****
  	result = i;
  
  	/* Include any trailing white space. */
! 	while (vim_iswhite(line[i]))
  	    ++i;
  
  	if (include_space)
--- 1785,1791 ----
  	result = i;
  
  	/* Include any trailing white space. */
! 	while (VIM_ISWHITE(line[i]))
  	    ++i;
  
  	if (include_space)
***************
*** 1853,1863 ****
  	     * (but the amount does not need to match, there might be a mix of
  	     * TABs and spaces).
  	     */
! 	    if (vim_iswhite(string[0]))
  	    {
! 		if (i == 0 || !vim_iswhite(line[i - 1]))
  		    continue;
! 		while (vim_iswhite(string[0]))
  		    ++string;
  	    }
  	    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)
--- 1853,1863 ----
  	     * (but the amount does not need to match, there might be a mix of
  	     * TABs and spaces).
  	     */
! 	    if (VIM_ISWHITE(string[0]))
  	    {
! 		if (i == 0 || !VIM_ISWHITE(line[i - 1]))
  		    continue;
! 		while (VIM_ISWHITE(string[0]))
  		    ++string;
  	    }
  	    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)
***************
*** 1870,1876 ****
  	     * end-of-line after the string in the line.
  	     */
  	    if (vim_strchr(part_buf, COM_BLANK) != NULL
! 		    && !vim_iswhite(line[i + j]) && line[i + j] != NUL)
  	    {
  		continue;
  	    }
--- 1870,1876 ----
  	     * end-of-line after the string in the line.
  	     */
  	    if (vim_strchr(part_buf, COM_BLANK) != NULL
! 		    && !VIM_ISWHITE(line[i + j]) && line[i + j] != NUL)
  	    {
  		continue;
  	    }
***************
*** 1907,1913 ****
  	     * the comment leader correctly.
  	     */
  
! 	    while (vim_iswhite(*com_leader))
  		++com_leader;
  	    len1 = (int)STRLEN(com_leader);
  
--- 1907,1913 ----
  	     * the comment leader correctly.
  	     */
  
! 	    while (VIM_ISWHITE(*com_leader))
  		++com_leader;
  	    len1 = (int)STRLEN(com_leader);
  
***************
*** 1920,1926 ****
  		    continue;
  		string = vim_strchr(part_buf2, ':');
  		++string;
! 		while (vim_iswhite(*string))
  		    ++string;
  		len2 = (int)STRLEN(string);
  		if (len2 == 0)
--- 1920,1926 ----
  		    continue;
  		string = vim_strchr(part_buf2, ':');
  		++string;
! 		while (VIM_ISWHITE(*string))
  		    ++string;
  		len2 = (int)STRLEN(string);
  		if (len2 == 0)
***************
*** 2694,2700 ****
      char_u	*ptr;
      colnr_T	col;
  
!     for (col = 0, ptr = ml_get_curline(); vim_iswhite(*ptr); ++col)
  	++ptr;
      if (col >= curwin->w_cursor.col + extra)
  	return TRUE;
--- 2694,2700 ----
      char_u	*ptr;
      colnr_T	col;
  
!     for (col = 0, ptr = ml_get_curline(); VIM_ISWHITE(*ptr); ++col)
  	++ptr;
      if (col >= curwin->w_cursor.col + extra)
  	return TRUE;
***************
*** 5777,5783 ****
  	p = cin_skipcomment(skipwhite(s + 9));
  	while (*p != NUL)
  	{
! 	    if (vim_iswhite(*p))
  	    {
  		has_name = TRUE; /* found end of a name */
  		p = cin_skipcomment(skipwhite(p));
--- 5777,5783 ----
  	p = cin_skipcomment(skipwhite(s + 9));
  	while (*p != NUL)
  	{
! 	    if (VIM_ISWHITE(*p))
  	    {
  		has_name = TRUE; /* found end of a name */
  		p = cin_skipcomment(skipwhite(p));
***************
*** 5825,5831 ****
  	p = cin_skipcomment(skipwhite(s + 6));
  	while (*p != NUL)
  	{
! 	    if (vim_iswhite(*p))
  	    {
  		p = cin_skipcomment(skipwhite(p));
  	    }
--- 5825,5831 ----
  	p = cin_skipcomment(skipwhite(s + 6));
  	while (*p != NUL)
  	{
! 	    if (VIM_ISWHITE(*p))
  	    {
  		p = cin_skipcomment(skipwhite(p));
  	    }
***************
*** 5976,5990 ****
  	    || (len == 6 && STRNCMP(p, "signed", 6) == 0))
      {
  	s = skipwhite(p + len);
! 	if ((STRNCMP(s, "int", 3) == 0 && vim_iswhite(s[3]))
! 		|| (STRNCMP(s, "long", 4) == 0 && vim_iswhite(s[4]))
! 		|| (STRNCMP(s, "short", 5) == 0 && vim_iswhite(s[5]))
! 		|| (STRNCMP(s, "char", 4) == 0 && vim_iswhite(s[4])))
  	    p = s;
      }
      for (len = 0; vim_isIDc(p[len]); ++len)
  	;
!     if (len == 0 || !vim_iswhite(p[len]) || cin_nocode(p))
  	return 0;
  
      p = skipwhite(p + len);
--- 5976,5990 ----
  	    || (len == 6 && STRNCMP(p, "signed", 6) == 0))
      {
  	s = skipwhite(p + len);
! 	if ((STRNCMP(s, "int", 3) == 0 && VIM_ISWHITE(s[3]))
! 		|| (STRNCMP(s, "long", 4) == 0 && VIM_ISWHITE(s[4]))
! 		|| (STRNCMP(s, "short", 5) == 0 && VIM_ISWHITE(s[5]))
! 		|| (STRNCMP(s, "char", 4) == 0 && VIM_ISWHITE(s[4])))
  	    p = s;
      }
      for (len = 0; vim_isIDc(p[len]); ++len)
  	;
!     if (len == 0 || !VIM_ISWHITE(p[len]) || cin_nocode(p))
  	return 0;
  
      p = skipwhite(p + len);
***************
*** 6356,6362 ****
  
      if (offset-- < 2)
  	return 0;
!     while (offset > 2 && vim_iswhite(line[offset]))
  	--offset;
  
      offset -= 1;
--- 6356,6362 ----
  
      if (offset-- < 2)
  	return 0;
!     while (offset > 2 && VIM_ISWHITE(line[offset]))
  	--offset;
  
      offset -= 1;
***************
*** 7602,7608 ****
  		    else
  		    {
  			col = our_paren_pos.col + 1;
! 			while (vim_iswhite(l[col]))
  			    col++;
  			if (l[col] != NUL)	/* In case of trailing space */
  			    our_paren_pos.col = col;
--- 7602,7608 ----
  		    else
  		    {
  			col = our_paren_pos.col + 1;
! 			while (VIM_ISWHITE(l[col]))
  			    col++;
  			if (l[col] != NUL)	/* In case of trailing space */
  			    our_paren_pos.col = col;
***************
*** 9449,9455 ****
  		    amount++;
  		    firsttry = amount;
  
! 		    while (vim_iswhite(*that))
  		    {
  			amount += lbr_chartabsize(line, that, (colnr_T)amount);
  			++that;
--- 9449,9455 ----
  		    amount++;
  		    firsttry = amount;
  
! 		    while (VIM_ISWHITE(*that))
  		    {
  			amount += lbr_chartabsize(line, that, (colnr_T)amount);
  			++that;
***************
*** 9472,9478 ****
  				    && (*that < '0' || *that > '9')))
  			{
  			    while (*that
! 				    && (!vim_iswhite(*that)
  					|| quotecount
  					|| parencount)
  				    && (!((*that == '(' || *that == '[')
--- 9472,9478 ----
  				    && (*that < '0' || *that > '9')))
  			{
  			    while (*that
! 				    && (!VIM_ISWHITE(*that)
  					|| quotecount
  					|| parencount)
  				    && (!((*that == '(' || *that == '[')
***************
*** 9495,9501 ****
  						line, &that, (colnr_T)amount);
  			    }
  			}
! 			while (vim_iswhite(*that))
  			{
  			    amount += lbr_chartabsize(
  						 line, that, (colnr_T)amount);
--- 9495,9501 ----
  						line, &that, (colnr_T)amount);
  			    }
  			}
! 			while (VIM_ISWHITE(*that))
  			{
  			    amount += lbr_chartabsize(
  						 line, that, (colnr_T)amount);
*** ../vim-8.0.0451/src/misc2.c	2017-03-12 19:22:31.740585042 +0100
--- src/misc2.c	2017-03-12 19:45:22.646910936 +0100
***************
*** 1702,1708 ****
      char_u	*q;
  
      q = ptr + STRLEN(ptr);
!     while (--q > ptr && vim_iswhite(q[0]) && q[-1] != '\\' && q[-1] != Ctrl_V)
  	*q = NUL;
  }
  
--- 1702,1708 ----
      char_u	*q;
  
      q = ptr + STRLEN(ptr);
!     while (--q > ptr && VIM_ISWHITE(q[0]) && q[-1] != '\\' && q[-1] != Ctrl_V)
  	*q = NUL;
  }
  
*** ../vim-8.0.0451/src/normal.c	2017-03-12 18:23:35.853850026 +0100
--- src/normal.c	2017-03-12 19:45:37.818803935 +0100
***************
*** 3090,3096 ****
  		 * not a word character, try finding a match and select a (),
  		 * {}, [], #if/#endif, etc. block. */
  		end_visual = curwin->w_cursor;
! 		while (gc = gchar_pos(&end_visual), vim_iswhite(gc))
  		    inc(&end_visual);
  		if (oap != NULL)
  		    oap->motion_type = MCHAR;
--- 3090,3096 ----
  		 * not a word character, try finding a match and select a (),
  		 * {}, [], #if/#endif, etc. block. */
  		end_visual = curwin->w_cursor;
! 		while (gc = gchar_pos(&end_visual), VIM_ISWHITE(gc))
  		    inc(&end_visual);
  		if (oap != NULL)
  		    oap->motion_type = MCHAR;
***************
*** 3467,3473 ****
  	else
  #endif
  	    while (ptr[col] != NUL
! 		    && (i == 0 ? !vim_iswordc(ptr[col]) : vim_iswhite(ptr[col]))
  # if defined(FEAT_BEVAL)
  		    && (!(find_type & FIND_EVAL) || ptr[col] != ']')
  # endif
--- 3467,3473 ----
  	else
  #endif
  	    while (ptr[col] != NUL
! 		    && (i == 0 ? !vim_iswordc(ptr[col]) : VIM_ISWHITE(ptr[col]))
  # if defined(FEAT_BEVAL)
  		    && (!(find_type & FIND_EVAL) || ptr[col] != ']')
  # endif
***************
*** 3524,3530 ****
  	    while (col > 0
  		    && ((i == 0
  			    ? vim_iswordc(ptr[col - 1])
! 			    : (!vim_iswhite(ptr[col - 1])
  				&& (!(find_type & FIND_IDENT)
  				    || !vim_iswordc(ptr[col - 1]))))
  #if defined(FEAT_BEVAL)
--- 3524,3530 ----
  	    while (col > 0
  		    && ((i == 0
  			    ? vim_iswordc(ptr[col - 1])
! 			    : (!VIM_ISWHITE(ptr[col - 1])
  				&& (!(find_type & FIND_IDENT)
  				    || !vim_iswordc(ptr[col - 1]))))
  #if defined(FEAT_BEVAL)
***************
*** 3588,3594 ****
      else
  #endif
  	while ((i == 0 ? vim_iswordc(ptr[col])
! 		       : (ptr[col] != NUL && !vim_iswhite(ptr[col])))
  # if defined(FEAT_BEVAL)
  		    || ((find_type & FIND_EVAL)
  			&& col <= (int)startcol
--- 3588,3594 ----
      else
  #endif
  	while ((i == 0 ? vim_iswordc(ptr[col])
! 		       : (ptr[col] != NUL && !VIM_ISWHITE(ptr[col])))
  # if defined(FEAT_BEVAL)
  		    || ((find_type & FIND_EVAL)
  			&& col <= (int)startcol
***************
*** 8109,8115 ****
  	{
  	    do
  		i = gchar_cursor();
! 	    while (vim_iswhite(i) && oneright() == OK);
  	}
  	curwin->w_set_curswant = TRUE;
  	break;
--- 8109,8115 ----
  	{
  	    do
  		i = gchar_cursor();
! 	    while (VIM_ISWHITE(i) && oneright() == OK);
  	}
  	curwin->w_set_curswant = TRUE;
  	break;
***************
*** 8133,8139 ****
  
  	    /* Decrease the cursor column until it's on a non-blank. */
  	    while (curwin->w_cursor.col > 0
! 				    && vim_iswhite(ptr[curwin->w_cursor.col]))
  		--curwin->w_cursor.col;
  	    curwin->w_set_curswant = TRUE;
  	    adjust_for_sel(cap);
--- 8133,8139 ----
  
  	    /* Decrease the cursor column until it's on a non-blank. */
  	    while (curwin->w_cursor.col > 0
! 				    && VIM_ISWHITE(ptr[curwin->w_cursor.col]))
  		--curwin->w_cursor.col;
  	    curwin->w_set_curswant = TRUE;
  	    adjust_for_sel(cap);
***************
*** 8716,8722 ****
  	n = gchar_cursor();
  	if (n != NUL)			/* not an empty line */
  	{
! 	    if (vim_iswhite(n))
  	    {
  		/*
  		 * Reproduce a funny Vi behaviour: "cw" on a blank only
--- 8716,8722 ----
  	n = gchar_cursor();
  	if (n != NUL)			/* not an empty line */
  	{
! 	    if (VIM_ISWHITE(n))
  	    {
  		/*
  		 * Reproduce a funny Vi behaviour: "cw" on a blank only
*** ../vim-8.0.0451/src/ops.c	2017-03-12 19:22:31.760584901 +0100
--- src/ops.c	2017-03-12 19:45:52.330701583 +0100
***************
*** 429,435 ****
  #endif
  		++bd.textstart;
  	}
! 	for ( ; vim_iswhite(*bd.textstart); )
  	{
  	    /* TODO: is passing bd.textstart for start of the line OK? */
  	    incr = lbr_chartabsize_adv(bd.textstart, &bd.textstart,
--- 429,435 ----
  #endif
  		++bd.textstart;
  	}
! 	for ( ; VIM_ISWHITE(*bd.textstart); )
  	{
  	    /* TODO: is passing bd.textstart for start of the line OK? */
  	    incr = lbr_chartabsize_adv(bd.textstart, &bd.textstart,
***************
*** 491,497 ****
  	/* The character's column is in "bd.start_vcol".  */
  	non_white_col = bd.start_vcol;
  
! 	while (vim_iswhite(*non_white))
  	{
  	    incr = lbr_chartabsize_adv(bd.textstart, &non_white, non_white_col);
  	    non_white_col += incr;
--- 491,497 ----
  	/* The character's column is in "bd.start_vcol".  */
  	non_white_col = bd.start_vcol;
  
! 	while (VIM_ISWHITE(*non_white))
  	{
  	    incr = lbr_chartabsize_adv(bd.textstart, &non_white, non_white_col);
  	    non_white_col += incr;
***************
*** 4655,4672 ****
      line1 = vim_strsave(ml_get(lnum));
      if (line1 != NULL)
      {
! 	for (idx1 = 0; vim_iswhite(line1[idx1]); ++idx1)
  	    ;
  	line2 = ml_get(lnum + 1);
  	for (idx2 = 0; idx2 < leader2_len; ++idx2)
  	{
! 	    if (!vim_iswhite(line2[idx2]))
  	    {
  		if (line1[idx1++] != line2[idx2])
  		    break;
  	    }
  	    else
! 		while (vim_iswhite(line1[idx1]))
  		    ++idx1;
  	}
  	vim_free(line1);
--- 4655,4672 ----
      line1 = vim_strsave(ml_get(lnum));
      if (line1 != NULL)
      {
! 	for (idx1 = 0; VIM_ISWHITE(line1[idx1]); ++idx1)
  	    ;
  	line2 = ml_get(lnum + 1);
  	for (idx2 = 0; idx2 < leader2_len; ++idx2)
  	{
! 	    if (!VIM_ISWHITE(line2[idx2]))
  	    {
  		if (line1[idx1++] != line2[idx2])
  		    break;
  	    }
  	    else
! 		while (VIM_ISWHITE(line1[idx1]))
  		    ++idx1;
  	}
  	vim_free(line1);
***************
*** 5092,5101 ****
  
      if (*s == NUL)
  	return FALSE;
!     /* Don't use STRLEN() inside vim_iswhite(), SAS/C complains: "macro
       * invocation may call function multiple times". */
      l = STRLEN(s) - 1;
!     return vim_iswhite(s[l]);
  }
  
  /*
--- 5092,5101 ----
  
      if (*s == NUL)
  	return FALSE;
!     /* Don't use STRLEN() inside VIM_ISWHITE(), SAS/C complains: "macro
       * invocation may call function multiple times". */
      l = STRLEN(s) - 1;
!     return VIM_ISWHITE(s[l]);
  }
  
  /*
***************
*** 5250,5256 ****
  	incr = lbr_chartabsize(line, pstart, (colnr_T)bdp->start_vcol);
  	bdp->start_vcol += incr;
  #ifdef FEAT_VISUALEXTRA
! 	if (vim_iswhite(*pstart))
  	{
  	    bdp->pre_whitesp += incr;
  	    bdp->pre_whitesp_c++;
--- 5250,5256 ----
  	incr = lbr_chartabsize(line, pstart, (colnr_T)bdp->start_vcol);
  	bdp->start_vcol += incr;
  #ifdef FEAT_VISUALEXTRA
! 	if (VIM_ISWHITE(*pstart))
  	{
  	    bdp->pre_whitesp += incr;
  	    bdp->pre_whitesp_c++;
*** ../vim-8.0.0451/src/option.c	2017-03-12 19:22:31.760584901 +0100
--- src/option.c	2017-03-12 19:46:25.118470310 +0100
***************
*** 4438,4444 ****
  	    afterchar = arg[len];
  
  	    /* skip white space, allow ":set ai  ?" */
! 	    while (vim_iswhite(arg[len]))
  		++len;
  
  	    adding = FALSE;
--- 4438,4444 ----
  	    afterchar = arg[len];
  
  	    /* skip white space, allow ":set ai  ?" */
! 	    while (VIM_ISWHITE(arg[len]))
  		++len;
  
  	    adding = FALSE;
***************
*** 4562,4568 ****
  		    }
  		}
  		if (vim_strchr((char_u *)"?!&<", nextchar) != NULL
! 			&& arg[1] != NUL && !vim_iswhite(arg[1]))
  		{
  		    errmsg = e_trailing;
  		    goto skip;
--- 4562,4568 ----
  		    }
  		}
  		if (vim_strchr((char_u *)"?!&<", nextchar) != NULL
! 			&& arg[1] != NUL && !VIM_ISWHITE(arg[1]))
  		{
  		    errmsg = e_trailing;
  		    goto skip;
***************
*** 4620,4626 ****
  			(void)show_one_termcode(key_name, p, TRUE);
  		}
  		if (nextchar != '?'
! 			&& nextchar != NUL && !vim_iswhite(afterchar))
  		    errmsg = e_trailing;
  	    }
  	    else
--- 4620,4626 ----
  			(void)show_one_termcode(key_name, p, TRUE);
  		}
  		if (nextchar != '?'
! 			&& nextchar != NUL && !VIM_ISWHITE(afterchar))
  		    errmsg = e_trailing;
  	    }
  	    else
***************
*** 4660,4666 ****
  			 * ":set invopt": invert
  			 * ":set opt" or ":set noopt": set or reset
  			 */
! 			if (nextchar != NUL && !vim_iswhite(afterchar))
  			{
  			    errmsg = e_trailing;
  			    goto skip;
--- 4660,4666 ----
  			 * ":set invopt": invert
  			 * ":set opt" or ":set noopt": set or reset
  			 */
! 			if (nextchar != NUL && !VIM_ISWHITE(afterchar))
  			{
  			    errmsg = e_trailing;
  			    goto skip;
***************
*** 4714,4720 ****
  				    || (long *)varp == &p_wcm)
  				&& (*arg == '<'
  				    || *arg == '^'
! 				    || (*arg != NUL && (!arg[1] || vim_iswhite(arg[1]))
  					&& !VIM_ISDIGIT(*arg))))
  			{
  			    value = string_to_key(arg);
--- 4714,4721 ----
  				    || (long *)varp == &p_wcm)
  				&& (*arg == '<'
  				    || *arg == '^'
! 				    || (*arg != NUL
! 					&& (!arg[1] || VIM_ISWHITE(arg[1]))
  					&& !VIM_ISDIGIT(*arg))))
  			{
  			    value = string_to_key(arg);
***************
*** 4730,4736 ****
  			     * hex numbers. */
  			    vim_str2nr(arg, NULL, &i, STR2NR_ALL,
  							     &value, NULL, 0);
! 			    if (arg[i] != NUL && !vim_iswhite(arg[i]))
  			    {
  				errmsg = e_invarg;
  				goto skip;
--- 4731,4737 ----
  			     * hex numbers. */
  			    vim_str2nr(arg, NULL, &i, STR2NR_ALL,
  							     &value, NULL, 0);
! 			    if (arg[i] != NUL && !VIM_ISWHITE(arg[i]))
  			    {
  				errmsg = e_invarg;
  				goto skip;
***************
*** 4922,4928 ****
  			     * do remove it for "\\\\machine\\path".
  			     * The reverse is found in ExpandOldSetting().
  			     */
! 			    while (*arg && !vim_iswhite(*arg))
  			    {
  				if (*arg == '\\' && arg[1] != NUL
  #ifdef BACKSLASH_IN_FILENAME
--- 4923,4929 ----
  			     * do remove it for "\\\\machine\\path".
  			     * The reverse is found in ExpandOldSetting().
  			     */
! 			    while (*arg && !VIM_ISWHITE(*arg))
  			    {
  				if (*arg == '\\' && arg[1] != NUL
  #ifdef BACKSLASH_IN_FILENAME
***************
*** 5162,5168 ****
  			else
  			{
  			    ++arg; /* jump to after the '=' or ':' */
! 			    for (p = arg; *p && !vim_iswhite(*p); ++p)
  				if (*p == '\\' && p[1] != NUL)
  				    ++p;
  			    nextchar = *p;
--- 5163,5169 ----
  			else
  			{
  			    ++arg; /* jump to after the '=' or ':' */
! 			    for (p = arg; *p && !VIM_ISWHITE(*p); ++p)
  				if (*p == '\\' && p[1] != NUL)
  				    ++p;
  			    nextchar = *p;
***************
*** 5190,5196 ****
  	     */
  	    for (i = 0; i < 2 ; ++i)
  	    {
! 		while (*arg != NUL && !vim_iswhite(*arg))
  		    if (*arg++ == '\\' && *arg != NUL)
  			++arg;
  		arg = skipwhite(arg);
--- 5191,5197 ----
  	     */
  	    for (i = 0; i < 2 ; ++i)
  	    {
! 		while (*arg != NUL && !VIM_ISWHITE(*arg))
  		    if (*arg++ == '\\' && *arg != NUL)
  			++arg;
  		arg = skipwhite(arg);
*** ../vim-8.0.0451/src/os_unix.c	2017-03-12 19:22:31.760584901 +0100
--- src/os_unix.c	2017-03-12 19:46:38.422376460 +0100
***************
*** 6139,6145 ****
  	STRCAT(command, pat[0] + 1);		/* exclude first backtick */
  	p = command + STRLEN(command) - 1;
  	*p-- = ')';				/* remove last backtick */
! 	while (p > command && vim_iswhite(*p))
  	    --p;
  	if (*p == '&')				/* remove trailing '&' */
  	{
--- 6139,6145 ----
  	STRCAT(command, pat[0] + 1);		/* exclude first backtick */
  	p = command + STRLEN(command) - 1;
  	*p-- = ')';				/* remove last backtick */
! 	while (p > command && VIM_ISWHITE(*p))
  	    --p;
  	if (*p == '&')				/* remove trailing '&' */
  	{
*** ../vim-8.0.0451/src/os_win32.c	2017-03-12 19:22:31.764584873 +0100
--- src/os_win32.c	2017-03-12 19:46:48.730303742 +0100
***************
*** 4706,4712 ****
  	if (*cmdbase == '(')
  	    ++cmdbase;
  
! 	if ((STRNICMP(cmdbase, "start", 5) == 0) && vim_iswhite(cmdbase[5]))
  	{
  	    STARTUPINFO		si;
  	    PROCESS_INFORMATION	pi;
--- 4706,4712 ----
  	if (*cmdbase == '(')
  	    ++cmdbase;
  
! 	if ((STRNICMP(cmdbase, "start", 5) == 0) && VIM_ISWHITE(cmdbase[5]))
  	{
  	    STARTUPINFO		si;
  	    PROCESS_INFORMATION	pi;
***************
*** 4724,4737 ****
  
  	    cmdbase = skipwhite(cmdbase + 5);
  	    if ((STRNICMP(cmdbase, "/min", 4) == 0)
! 		    && vim_iswhite(cmdbase[4]))
  	    {
  		cmdbase = skipwhite(cmdbase + 4);
  		si.dwFlags = STARTF_USESHOWWINDOW;
  		si.wShowWindow = SW_SHOWMINNOACTIVE;
  	    }
  	    else if ((STRNICMP(cmdbase, "/b", 2) == 0)
! 		    && vim_iswhite(cmdbase[2]))
  	    {
  		cmdbase = skipwhite(cmdbase + 2);
  		flags = CREATE_NO_WINDOW;
--- 4724,4737 ----
  
  	    cmdbase = skipwhite(cmdbase + 5);
  	    if ((STRNICMP(cmdbase, "/min", 4) == 0)
! 		    && VIM_ISWHITE(cmdbase[4]))
  	    {
  		cmdbase = skipwhite(cmdbase + 4);
  		si.dwFlags = STARTF_USESHOWWINDOW;
  		si.wShowWindow = SW_SHOWMINNOACTIVE;
  	    }
  	    else if ((STRNICMP(cmdbase, "/b", 2) == 0)
! 		    && VIM_ISWHITE(cmdbase[2]))
  	    {
  		cmdbase = skipwhite(cmdbase + 2);
  		flags = CREATE_NO_WINDOW;
*** ../vim-8.0.0451/src/quickfix.c	2017-03-05 17:43:10.624245543 +0100
--- src/quickfix.c	2017-03-12 19:47:01.534213411 +0100
***************
*** 2608,2614 ****
  	{
  	    buf[i] = ' ';
  	    while (*++p != NUL)
! 		if (!vim_iswhite(*p) && *p != '\n')
  		    break;
  	}
  	else
--- 2608,2614 ----
  	{
  	    buf[i] = ' ';
  	    while (*++p != NUL)
! 		if (!VIM_ISWHITE(*p) && *p != '\n')
  		    break;
  	}
  	else
*** ../vim-8.0.0451/src/regexp.c	2017-03-12 19:22:31.764584873 +0100
--- src/regexp.c	2017-03-12 19:47:11.222145059 +0100
***************
*** 4523,4536 ****
  	    break;
  
  	  case WHITE:
! 	    if (!vim_iswhite(c))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
  	    break;
  
  	  case NWHITE:
! 	    if (c == NUL || vim_iswhite(c))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
--- 4523,4536 ----
  	    break;
  
  	  case WHITE:
! 	    if (!VIM_ISWHITE(c))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
  	    break;
  
  	  case NWHITE:
! 	    if (c == NUL || VIM_ISWHITE(c))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
*** ../vim-8.0.0451/src/regexp_nfa.c	2017-03-12 19:22:31.764584873 +0100
--- src/regexp_nfa.c	2017-03-12 19:47:21.098075381 +0100
***************
*** 6351,6362 ****
  		break;
  
  	    case NFA_WHITE:	/*  \s	*/
! 		result = vim_iswhite(curc);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NWHITE:	/*  \S	*/
! 		result = curc != NUL && !vim_iswhite(curc);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
--- 6351,6362 ----
  		break;
  
  	    case NFA_WHITE:	/*  \s	*/
! 		result = VIM_ISWHITE(curc);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NWHITE:	/*  \S	*/
! 		result = curc != NUL && !VIM_ISWHITE(curc);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
*** ../vim-8.0.0451/src/screen.c	2017-03-12 19:22:31.768584844 +0100
--- src/screen.c	2017-03-12 19:47:32.297996356 +0100
***************
*** 3371,3377 ****
  	if (lcs_trail)
  	{
  	    trailcol = (colnr_T)STRLEN(ptr);
! 	    while (trailcol > (colnr_T)0 && vim_iswhite(ptr[trailcol - 1]))
  		--trailcol;
  	    trailcol += (colnr_T) (ptr - line);
  	}
--- 3371,3377 ----
  	if (lcs_trail)
  	{
  	    trailcol = (colnr_T)STRLEN(ptr);
! 	    while (trailcol > (colnr_T)0 && VIM_ISWHITE(ptr[trailcol - 1]))
  		--trailcol;
  	    trailcol += (colnr_T) (ptr - line);
  	}
***************
*** 4577,4583 ****
  # else
  		    c_extra = ' ';
  # endif
! 		    if (vim_iswhite(c))
  		    {
  #ifdef FEAT_CONCEAL
  			if (c == TAB)
--- 4577,4583 ----
  # else
  		    c_extra = ' ';
  # endif
! 		    if (VIM_ISWHITE(c))
  		    {
  #ifdef FEAT_CONCEAL
  			if (c == TAB)
*** ../vim-8.0.0451/src/search.c	2017-03-12 19:22:31.768584844 +0100
--- src/search.c	2017-03-12 19:47:52.145856304 +0100
***************
*** 3276,3282 ****
      while (decl(posp) != -1)
      {
  	c = gchar_pos(posp);
! 	if (!vim_iswhite(c))
  	{
  	    incl(posp);
  	    break;
--- 3276,3282 ----
      while (decl(posp) != -1)
      {
  	c = gchar_pos(posp);
! 	if (!VIM_ISWHITE(c))
  	{
  	    incl(posp);
  	    break;
***************
*** 3515,3521 ****
  	    while (LT_POS(pos, curwin->w_cursor))
  	    {
  		c = gchar_pos(&pos);
! 		if (!vim_iswhite(c))
  		{
  		    at_start_sent = FALSE;
  		    break;
--- 3515,3521 ----
  	    while (LT_POS(pos, curwin->w_cursor))
  	    {
  		c = gchar_pos(&pos);
! 		if (!VIM_ISWHITE(c))
  		{
  		    at_start_sent = FALSE;
  		    break;
***************
*** 3538,3544 ****
  		if (at_start_sent)
  		    find_first_blank(&curwin->w_cursor);
  		c = gchar_cursor();
! 		if (!at_start_sent || (!include && !vim_iswhite(c)))
  		    findsent(BACKWARD, 1L);
  		at_start_sent = !at_start_sent;
  	    }
--- 3538,3544 ----
  		if (at_start_sent)
  		    find_first_blank(&curwin->w_cursor);
  		c = gchar_cursor();
! 		if (!at_start_sent || (!include && !VIM_ISWHITE(c)))
  		    findsent(BACKWARD, 1L);
  		at_start_sent = !at_start_sent;
  	    }
***************
*** 3561,3567 ****
  		while (LT_POS(pos, curwin->w_cursor))
  		{
  		    c = gchar_pos(&pos);
! 		    if (!vim_iswhite(c))
  		    {
  			at_start_sent = TRUE;
  			break;
--- 3561,3567 ----
  		while (LT_POS(pos, curwin->w_cursor))
  		{
  		    c = gchar_pos(&pos);
! 		    if (!VIM_ISWHITE(c))
  		    {
  			at_start_sent = TRUE;
  			break;
***************
*** 3587,3593 ****
       * If the cursor started on a blank, check if it is just before the start
       * of the next sentence.
       */
!     while (c = gchar_pos(&pos), vim_iswhite(c))	/* vim_iswhite() is a macro */
  	incl(&pos);
      if (EQUAL_POS(pos, curwin->w_cursor))
      {
--- 3587,3593 ----
       * If the cursor started on a blank, check if it is just before the start
       * of the next sentence.
       */
!     while (c = gchar_pos(&pos), VIM_ISWHITE(c))	/* VIM_ISWHITE() is a macro */
  	incl(&pos);
      if (EQUAL_POS(pos, curwin->w_cursor))
      {
***************
*** 3623,3633 ****
  	if (start_blank)
  	{
  	    find_first_blank(&curwin->w_cursor);
! 	    c = gchar_pos(&curwin->w_cursor);	/* vim_iswhite() is a macro */
! 	    if (vim_iswhite(c))
  		decl(&curwin->w_cursor);
  	}
! 	else if (c = gchar_cursor(), !vim_iswhite(c))
  	    find_first_blank(&start_pos);
      }
  
--- 3623,3633 ----
  	if (start_blank)
  	{
  	    find_first_blank(&curwin->w_cursor);
! 	    c = gchar_pos(&curwin->w_cursor);	/* VIM_ISWHITE() is a macro */
! 	    if (VIM_ISWHITE(c))
  		decl(&curwin->w_cursor);
  	}
! 	else if (c = gchar_cursor(), !VIM_ISWHITE(c))
  	    find_first_blank(&start_pos);
      }
  
***************
*** 3974,3980 ****
       */
      inc_cursor();
      p = ml_get_cursor();
!     for (cp = p; *cp != NUL && *cp != '>' && !vim_iswhite(*cp); MB_PTR_ADV(cp))
  	;
      len = (int)(cp - p);
      if (len == 0)
--- 3974,3980 ----
       */
      inc_cursor();
      p = ml_get_cursor();
!     for (cp = p; *cp != NUL && *cp != '>' && !VIM_ISWHITE(*cp); MB_PTR_ADV(cp))
  	;
      len = (int)(cp - p);
      if (len == 0)
***************
*** 4496,4506 ****
       * the starting quote. */
      if (include)
      {
! 	if (vim_iswhite(line[col_end + 1]))
! 	    while (vim_iswhite(line[col_end + 1]))
  		++col_end;
  	else
! 	    while (col_start > 0 && vim_iswhite(line[col_start - 1]))
  		--col_start;
      }
  
--- 4496,4506 ----
       * the starting quote. */
      if (include)
      {
! 	if (VIM_ISWHITE(line[col_end + 1]))
! 	    while (VIM_ISWHITE(line[col_end + 1]))
  		++col_end;
  	else
! 	    while (col_start > 0 && VIM_ISWHITE(line[col_start - 1]))
  		--col_start;
      }
  
*** ../vim-8.0.0451/src/spell.c	2017-03-12 19:22:31.768584844 +0100
--- src/spell.c	2017-03-12 19:48:09.069736877 +0100
***************
*** 4528,4534 ****
  
  	    fword_ends = (fword[sp->ts_fidx] == NUL
  			   || (soundfold
! 			       ? vim_iswhite(fword[sp->ts_fidx])
  			       : !spell_iswordp(fword + sp->ts_fidx, curwin)));
  	    tword[sp->ts_twordlen] = NUL;
  
--- 4528,4534 ----
  
  	    fword_ends = (fword[sp->ts_fidx] == NUL
  			   || (soundfold
! 			       ? VIM_ISWHITE(fword[sp->ts_fidx])
  			       : !spell_iswordp(fword + sp->ts_fidx, curwin)));
  	    tword[sp->ts_twordlen] = NUL;
  
***************
*** 6231,6237 ****
  	 * sounds like "t h" while "the" sounds like "@".  Avoid that by
  	 * removing the space.  Don't do it when the good word also contains a
  	 * space. */
! 	if (vim_iswhite(su->su_badptr[su->su_badlen])
  					 && *skiptowhite(stp->st_word) == NUL)
  	    for (p = fword; *(p = skiptowhite(p)) != NUL; )
  		STRMOVE(p, p + 1);
--- 6231,6237 ----
  	 * sounds like "t h" while "the" sounds like "@".  Avoid that by
  	 * removing the space.  Don't do it when the good word also contains a
  	 * space. */
! 	if (VIM_ISWHITE(su->su_badptr[su->su_badlen])
  					 && *skiptowhite(stp->st_word) == NUL)
  	    for (p = fword; *(p = skiptowhite(p)) != NUL; )
  		STRMOVE(p, p + 1);
***************
*** 7106,7112 ****
  	for (s = inword; *s != NUL; )
  	{
  	    c = mb_cptr2char_adv(&s);
! 	    if (enc_utf8 ? utf_class(c) == 0 : vim_iswhite(c))
  		c = ' ';
  	    else if (c < 256)
  		c = slang->sl_sal_first[c];
--- 7106,7112 ----
  	for (s = inword; *s != NUL; )
  	{
  	    c = mb_cptr2char_adv(&s);
! 	    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))
  		c = ' ';
  	    else if (c < 256)
  		c = slang->sl_sal_first[c];
***************
*** 7147,7153 ****
  	/* The sl_sal_first[] table contains the translation. */
  	for (s = inword; (c = *s) != NUL; ++s)
  	{
! 	    if (vim_iswhite(c))
  		c = ' ';
  	    else
  		c = slang->sl_sal_first[c];
--- 7147,7153 ----
  	/* The sl_sal_first[] table contains the translation. */
  	for (s = inword; (c = *s) != NUL; ++s)
  	{
! 	    if (VIM_ISWHITE(c))
  		c = ' ';
  	    else
  		c = slang->sl_sal_first[c];
***************
*** 7185,7191 ****
  	t = word;
  	while (*s != NUL)
  	{
! 	    if (vim_iswhite(*s))
  	    {
  		*t++ = ' ';
  		s = skipwhite(s);
--- 7185,7191 ----
  	t = word;
  	while (*s != NUL)
  	{
! 	    if (VIM_ISWHITE(*s))
  	    {
  		*t++ = ' ';
  		s = skipwhite(s);
***************
*** 7409,7415 ****
  		}
  	    }
  	}
! 	else if (vim_iswhite(c))
  	{
  	    c = ' ';
  	    k = 1;
--- 7409,7415 ----
  		}
  	    }
  	}
! 	else if (VIM_ISWHITE(c))
  	{
  	    c = ' ';
  	    k = 1;
***************
*** 7474,7480 ****
  	c = mb_cptr2char_adv(&s);
  	if (slang->sl_rem_accents)
  	{
! 	    if (enc_utf8 ? utf_class(c) == 0 : vim_iswhite(c))
  	    {
  		if (did_white)
  		    continue;
--- 7474,7480 ----
  	c = mb_cptr2char_adv(&s);
  	if (slang->sl_rem_accents)
  	{
! 	    if (enc_utf8 ? utf_class(c) == 0 : VIM_ISWHITE(c))
  	    {
  		if (did_white)
  		    continue;
***************
*** 7715,7721 ****
  		}
  	    }
  	}
! 	else if (vim_iswhite(c))
  	{
  	    c = ' ';
  	    k = 1;
--- 7715,7721 ----
  		}
  	    }
  	}
! 	else if (VIM_ISWHITE(c))
  	{
  	    c = ' ';
  	    k = 1;
*** ../vim-8.0.0451/src/syntax.c	2017-03-12 19:22:31.772584816 +0100
--- src/syntax.c	2017-03-12 19:48:26.453614196 +0100
***************
*** 2308,2314 ****
  	    {
  		line = syn_getcurline();
  		if (((current_next_flags & HL_SKIPWHITE)
! 			    && vim_iswhite(line[current_col]))
  			|| ((current_next_flags & HL_SKIPEMPTY)
  			    && *line == NUL))
  		    break;
--- 2308,2314 ----
  	    {
  		line = syn_getcurline();
  		if (((current_next_flags & HL_SKIPWHITE)
! 			    && VIM_ISWHITE(line[current_col]))
  			|| ((current_next_flags & HL_SKIPEMPTY)
  			    && *line == NUL))
  		    break;
***************
*** 4631,4637 ****
  	    for (i = 0, len = 0; p[i] != NUL; i += 2, ++len)
  		if (arg[len] != p[i] && arg[len] != p[i + 1])
  		    break;
! 	    if (p[i] == NUL && (vim_iswhite(arg[len])
  				    || (flagtab[fidx].argtype > 0
  					 ? arg[len] == '='
  					 : ends_excmd(arg[len]))))
--- 4631,4637 ----
  	    for (i = 0, len = 0; p[i] != NUL; i += 2, ++len)
  		if (arg[len] != p[i] && arg[len] != p[i + 1])
  		    break;
! 	    if (p[i] == NUL && (VIM_ISWHITE(arg[len])
  				    || (flagtab[fidx].argtype > 0
  					 ? arg[len] == '='
  					 : ends_excmd(arg[len]))))
***************
*** 4905,4911 ****
  		if (rest == NULL || ends_excmd(*rest))
  		    break;
  		/* Copy the keyword, removing backslashes, and add a NUL. */
! 		while (*rest != NUL && !vim_iswhite(*rest))
  		{
  		    if (*rest == '\\' && rest[1] != NUL)
  			++rest;
--- 4905,4911 ----
  		if (rest == NULL || ends_excmd(*rest))
  		    break;
  		/* Copy the keyword, removing backslashes, and add a NUL. */
! 		while (*rest != NUL && !VIM_ISWHITE(*rest))
  		{
  		    if (*rest == '\\' && rest[1] != NUL)
  			++rest;
***************
*** 5156,5162 ****
  
  	/* must be a pattern or matchgroup then */
  	key_end = rest;
! 	while (*key_end && !vim_iswhite(*key_end) && *key_end != '=')
  	    ++key_end;
  	vim_free(key);
  	key = vim_strnsave_up(rest, (int)(key_end - rest));
--- 5156,5162 ----
  
  	/* must be a pattern or matchgroup then */
  	key_end = rest;
! 	while (*key_end && !VIM_ISWHITE(*key_end) && *key_end != '=')
  	    ++key_end;
  	vim_free(key);
  	key = vim_strnsave_up(rest, (int)(key_end - rest));
***************
*** 5640,5658 ****
  	for (;;)
  	{
  	    if (STRNICMP(rest, "add", 3) == 0
! 		    && (vim_iswhite(rest[3]) || rest[3] == '='))
  	    {
  		opt_len = 3;
  		list_op = CLUSTER_ADD;
  	    }
  	    else if (STRNICMP(rest, "remove", 6) == 0
! 		    && (vim_iswhite(rest[6]) || rest[6] == '='))
  	    {
  		opt_len = 6;
  		list_op = CLUSTER_SUBTRACT;
  	    }
  	    else if (STRNICMP(rest, "contains", 8) == 0
! 			&& (vim_iswhite(rest[8]) || rest[8] == '='))
  	    {
  		opt_len = 8;
  		list_op = CLUSTER_REPLACE;
--- 5640,5658 ----
  	for (;;)
  	{
  	    if (STRNICMP(rest, "add", 3) == 0
! 		    && (VIM_ISWHITE(rest[3]) || rest[3] == '='))
  	    {
  		opt_len = 3;
  		list_op = CLUSTER_ADD;
  	    }
  	    else if (STRNICMP(rest, "remove", 6) == 0
! 		    && (VIM_ISWHITE(rest[6]) || rest[6] == '='))
  	    {
  		opt_len = 6;
  		list_op = CLUSTER_SUBTRACT;
  	    }
  	    else if (STRNICMP(rest, "contains", 8) == 0
! 			&& (VIM_ISWHITE(rest[8]) || rest[8] == '='))
  	    {
  		opt_len = 8;
  		list_op = CLUSTER_REPLACE;
***************
*** 5793,5799 ****
  	}
      } while (idx >= 0);
  
!     if (!ends_excmd(*end) && !vim_iswhite(*end))
      {
  	EMSG2(_("E402: Garbage after pattern: %s"), arg);
  	return NULL;
--- 5793,5799 ----
  	}
      } while (idx >= 0);
  
!     if (!ends_excmd(*end) && !VIM_ISWHITE(*end))
      {
  	EMSG2(_("E402: Garbage after pattern: %s"), arg);
  	return NULL;
***************
*** 6014,6020 ****
  	count = 0;
  	while (!ends_excmd(*p))
  	{
! 	    for (end = p; *end && !vim_iswhite(*end) && *end != ','; ++end)
  		;
  	    name = alloc((int)(end - p + 3));	    /* leave room for "^$" */
  	    if (name == NULL)
--- 6014,6020 ----
  	count = 0;
  	while (!ends_excmd(*p))
  	{
! 	    for (end = p; *end && !VIM_ISWHITE(*end) && *end != ','; ++end)
  		;
  	    name = alloc((int)(end - p + 3));	    /* leave room for "^$" */
  	    if (name == NULL)
***************
*** 7466,7472 ****
  	 * Isolate the key ("term", "ctermfg", "ctermbg", "font", "guifg" or
  	 * "guibg").
  	 */
! 	while (*linep && !vim_iswhite(*linep) && *linep != '=')
  	    ++linep;
  	vim_free(key);
  	key = vim_strnsave_up(key_start, (int)(linep - key_start));
--- 7466,7472 ----
  	 * Isolate the key ("term", "ctermfg", "ctermbg", "font", "guifg" or
  	 * "guibg").
  	 */
! 	while (*linep && !VIM_ISWHITE(*linep) && *linep != '=')
  	    ++linep;
  	vim_free(key);
  	key = vim_strnsave_up(key_start, (int)(linep - key_start));
***************
*** 9721,9727 ****
  	    attr = 0;
  	    for ( ; *p && *p != ','; ++p)	    /* parse upto comma */
  	    {
! 		if (vim_iswhite(*p))		    /* ignore white space */
  		    continue;
  
  		if (attr > HL_ALL)  /* Combination with ':' is not allowed. */
--- 9721,9727 ----
  	    attr = 0;
  	    for ( ; *p && *p != ','; ++p)	    /* parse upto comma */
  	    {
! 		if (VIM_ISWHITE(*p))		    /* ignore white space */
  		    continue;
  
  		if (attr > HL_ALL)  /* Combination with ':' is not allowed. */
*** ../vim-8.0.0451/src/tag.c	2017-03-12 19:22:31.772584816 +0100
--- src/tag.c	2017-03-12 19:48:37.325537466 +0100
***************
*** 2005,2011 ****
  #endif
  			if (	   fnamencmp(lbuf, tagp.fname, p - lbuf) == 0
  #ifdef FEAT_TAG_ANYWHITE
! 				&& vim_iswhite(tagp.fname[p - lbuf])
  #else
  				&& tagp.fname[p - lbuf] == TAB
  #endif
--- 2005,2011 ----
  #endif
  			if (	   fnamencmp(lbuf, tagp.fname, p - lbuf) == 0
  #ifdef FEAT_TAG_ANYWHITE
! 				&& VIM_ISWHITE(tagp.fname[p - lbuf])
  #else
  				&& tagp.fname[p - lbuf] == TAB
  #endif
***************
*** 3932,3938 ****
  		    else if (STRNCMP(p, "file:", 5) == 0)
  			/* skip "file:" (static tag) */
  			p += 4;
! 		    else if (!vim_iswhite(*p))
  		    {
  			char_u	*s, *n;
  			int	len;
--- 3932,3938 ----
  		    else if (STRNCMP(p, "file:", 5) == 0)
  			/* skip "file:" (static tag) */
  			p += 4;
! 		    else if (!VIM_ISWHITE(*p))
  		    {
  			char_u	*s, *n;
  			int	len;
*** ../vim-8.0.0451/src/userfunc.c	2017-02-02 22:59:22.583226973 +0100
--- src/userfunc.c	2017-03-12 19:48:45.981476374 +0100
***************
*** 2104,2110 ****
  	else
  	{
  	    /* skip ':' and blanks*/
! 	    for (p = theline; vim_iswhite(*p) || *p == ':'; ++p)
  		;
  
  	    /* Check for "endfunction". */
--- 2104,2110 ----
  	else
  	{
  	    /* skip ':' and blanks*/
! 	    for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)
  		;
  
  	    /* Check for "endfunction". */
*** ../vim-8.0.0451/src/version.c	2017-03-12 19:22:31.772584816 +0100
--- src/version.c	2017-03-12 20:06:05.106128862 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     452,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
102. When filling out your driver's license application, you give
     your IP address.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
