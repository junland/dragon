To: vim_dev@googlegroups.com
Subject: Patch 8.0.0680
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0680 (after 8.0.0612)
Problem:    Plugins in start packages are sourced twice. (mseplowitz)
Solution:   Use the unmodified runtime path when loading plugins (test by Ingo
            Karkat, closes #1801)
Files:      src/testdir/test_startup.vim, src/main.c, src/ex_cmds2.c,
            src/proto/ex_cmds2.pro


*** ../vim-8.0.0679/src/testdir/test_startup.vim	2017-06-04 17:47:38.229528087 +0200
--- src/testdir/test_startup.vim	2017-06-27 14:37:22.398040984 +0200
***************
*** 23,50 ****
  	\ 'set guioptions+=M',
  	\ 'let $HOME = "/does/not/exist"',
  	\ 'set loadplugins',
! 	\ 'set rtp=Xhere,Xafter',
  	\ 'set packpath=Xhere,Xafter',
  	\ 'set nomore',
  	\ ]
    let after = [
  	\ 'redir! > Xtestout',
  	\ 'scriptnames',
  	\ 'redir END',
  	\ 'quit',
  	\ ]
    call mkdir('Xhere/plugin', 'p')
!   call writefile(['let done = 1'], 'Xhere/plugin/here.vim')
    call mkdir('Xhere/pack/foo/start/foobar/plugin', 'p')
!   call writefile(['let done = 1'], 'Xhere/pack/foo/start/foobar/plugin/foo.vim')
  
    call mkdir('Xafter/plugin', 'p')
!   call writefile(['let done = 1'], 'Xafter/plugin/later.vim')
  
    if RunVim(before, after, '')
  
      let lines = readfile('Xtestout')
!     let expected = ['Xbefore.vim', 'here.vim', 'foo.vim', 'later.vim', 'Xafter.vim']
      let found = []
      for line in lines
        for one in expected
--- 23,56 ----
  	\ 'set guioptions+=M',
  	\ 'let $HOME = "/does/not/exist"',
  	\ 'set loadplugins',
! 	\ 'set rtp=Xhere,Xafter,Xanother',
  	\ 'set packpath=Xhere,Xafter',
  	\ 'set nomore',
+ 	\ 'let g:sequence = ""',
  	\ ]
    let after = [
  	\ 'redir! > Xtestout',
  	\ 'scriptnames',
  	\ 'redir END',
+ 	\ 'redir! > Xsequence',
+ 	\ 'echo g:sequence',
+ 	\ 'redir END',
  	\ 'quit',
  	\ ]
    call mkdir('Xhere/plugin', 'p')
!   call writefile(['let g:sequence .= "here "'], 'Xhere/plugin/here.vim')
!   call mkdir('Xanother/plugin', 'p')
!   call writefile(['let g:sequence .= "another "'], 'Xanother/plugin/another.vim')
    call mkdir('Xhere/pack/foo/start/foobar/plugin', 'p')
!   call writefile(['let g:sequence .= "pack "'], 'Xhere/pack/foo/start/foobar/plugin/foo.vim')
  
    call mkdir('Xafter/plugin', 'p')
!   call writefile(['let g:sequence .= "after "'], 'Xafter/plugin/later.vim')
  
    if RunVim(before, after, '')
  
      let lines = readfile('Xtestout')
!     let expected = ['Xbefore.vim', 'here.vim', 'another.vim', 'foo.vim', 'later.vim', 'Xafter.vim']
      let found = []
      for line in lines
        for one in expected
***************
*** 56,63 ****
--- 62,73 ----
      call assert_equal(expected, found)
    endif
  
+   call assert_equal('here another pack after', substitute(join(readfile('Xsequence', 1), ''), '\s\+$', '', ''))
+ 
    call delete('Xtestout')
+   call delete('Xsequence')
    call delete('Xhere', 'rf')
+   call delete('Xanother', 'rf')
    call delete('Xafter', 'rf')
  endfunc
  
*** ../vim-8.0.0679/src/main.c	2017-06-09 21:35:43.337681146 +0200
--- src/main.c	2017-06-27 14:31:07.968926240 +0200
***************
*** 449,466 ****
       */
      if (p_lpl)
      {
  	/* First add all package directories to 'runtimepath', so that their
  	 * autoload directories can be found.  Only if not done already with a
! 	 * :packloadall command. */
  	if (!did_source_packages)
  	    add_pack_start_dirs();
  
  # ifdef VMS	/* Somehow VMS doesn't handle the "**". */
! 	source_runtime((char_u *)"plugin/*.vim", DIP_ALL | DIP_NOAFTER);
  # else
! 	source_runtime((char_u *)"plugin/**/*.vim", DIP_ALL | DIP_NOAFTER);
  # endif
  	TIME_MSG("loading plugins");
  
  	/* Only source "start" packages if not done already with a :packloadall
  	 * command. */
--- 449,476 ----
       */
      if (p_lpl)
      {
+ 	char_u *rtp_copy = NULL;
+ 
  	/* First add all package directories to 'runtimepath', so that their
  	 * autoload directories can be found.  Only if not done already with a
! 	 * :packloadall command.
! 	 * Make a copy of 'runtimepath', so that source_runtime does not use
! 	 * the pack directories. */
  	if (!did_source_packages)
+ 	{
+ 	    rtp_copy = vim_strsave(p_rtp);
  	    add_pack_start_dirs();
+ 	}
  
+ 	source_in_path(rtp_copy == NULL ? p_rtp : rtp_copy,
  # ifdef VMS	/* Somehow VMS doesn't handle the "**". */
! 		(char_u *)"plugin/*.vim",
  # else
! 		(char_u *)"plugin/**/*.vim",
  # endif
+ 		DIP_ALL | DIP_NOAFTER);
  	TIME_MSG("loading plugins");
+ 	vim_free(rtp_copy);
  
  	/* Only source "start" packages if not done already with a :packloadall
  	 * command. */
*** ../vim-8.0.0679/src/ex_cmds2.c	2017-06-24 16:03:02.751998272 +0200
--- src/ex_cmds2.c	2017-06-27 14:29:44.281571141 +0200
***************
*** 3286,3304 ****
  }
  
  /*
-  * Source the file "name" from all directories in 'runtimepath'.
-  * "name" can contain wildcards.
-  * When "flags" has DIP_ALL: source all files, otherwise only the first one.
-  *
-  * return FAIL when no file could be sourced, OK otherwise.
-  */
-     int
- source_runtime(char_u *name, int flags)
- {
-     return do_in_runtimepath(name, flags, source_callback, NULL);
- }
- 
- /*
   * Find the file "name" in all directories in "path" and invoke
   * "callback(fname, cookie)".
   * "name" can contain wildcards.
--- 3286,3291 ----
***************
*** 3435,3452 ****
  }
  
  /*
!  * Find "name" in 'runtimepath'.  When found, invoke the callback function for
   * it: callback(fname, "cookie")
   * When "flags" has DIP_ALL repeat for all matches, otherwise only the first
   * one is used.
   * Returns OK when at least one match found, FAIL otherwise.
   *
!  * If "name" is NULL calls callback for each entry in runtimepath. Cookie is
   * passed by reference in this case, setting it to NULL indicates that callback
   * has done its job.
   */
!     int
! do_in_runtimepath(
      char_u	*name,
      int		flags,
      void	(*callback)(char_u *fname, void *ck),
--- 3422,3440 ----
  }
  
  /*
!  * Find "name" in "path".  When found, invoke the callback function for
   * it: callback(fname, "cookie")
   * When "flags" has DIP_ALL repeat for all matches, otherwise only the first
   * one is used.
   * Returns OK when at least one match found, FAIL otherwise.
   *
!  * If "name" is NULL calls callback for each entry in "path". Cookie is
   * passed by reference in this case, setting it to NULL indicates that callback
   * has done its job.
   */
!     static int
! do_in_path_and_pp(
!     char_u	*path,
      char_u	*name,
      int		flags,
      void	(*callback)(char_u *fname, void *ck),
***************
*** 3459,3465 ****
      char	*opt_dir = "pack/*/opt/*/%s";
  
      if ((flags & DIP_NORTP) == 0)
! 	done = do_in_path(p_rtp, name, flags, callback, cookie);
  
      if ((done == FAIL || (flags & DIP_ALL)) && (flags & DIP_START))
      {
--- 3447,3453 ----
      char	*opt_dir = "pack/*/opt/*/%s";
  
      if ((flags & DIP_NORTP) == 0)
! 	done = do_in_path(path, name, flags, callback, cookie);
  
      if ((done == FAIL || (flags & DIP_ALL)) && (flags & DIP_START))
      {
***************
*** 3487,3492 ****
--- 3475,3516 ----
  }
  
  /*
+  * Just like do_in_path_and_pp(), using 'runtimepath' for "path".
+  */
+     int
+ do_in_runtimepath(
+     char_u	*name,
+     int		flags,
+     void	(*callback)(char_u *fname, void *ck),
+     void	*cookie)
+ {
+     return do_in_path_and_pp(p_rtp, name, flags, callback, cookie);
+ }
+ 
+ /*
+  * Source the file "name" from all directories in 'runtimepath'.
+  * "name" can contain wildcards.
+  * When "flags" has DIP_ALL: source all files, otherwise only the first one.
+  *
+  * return FAIL when no file could be sourced, OK otherwise.
+  */
+     int
+ source_runtime(char_u *name, int flags)
+ {
+     return source_in_path(p_rtp, name, flags);
+ }
+ 
+ /*
+  * Just like source_runtime(), but use "path" instead of 'runtimepath'.
+  */
+     int
+ source_in_path(char_u *path, char_u *name, int flags)
+ {
+     return do_in_path_and_pp(path, name, flags, source_callback, NULL);
+ }
+ 
+ 
+ /*
   * Expand wildcards in "pat" and invoke do_source() for each match.
   */
      static void
*** ../vim-8.0.0679/src/proto/ex_cmds2.pro	2017-06-04 17:47:38.225528115 +0200
--- src/proto/ex_cmds2.pro	2017-06-27 14:29:42.173587386 +0200
***************
*** 69,77 ****
  void ex_listdo(exarg_T *eap);
  void ex_compiler(exarg_T *eap);
  void ex_runtime(exarg_T *eap);
- int source_runtime(char_u *name, int flags);
  int do_in_path(char_u *path, char_u *name, int flags, void (*callback)(char_u *fname, void *ck), void *cookie);
  int do_in_runtimepath(char_u *name, int flags, void (*callback)(char_u *fname, void *ck), void *cookie);
  void add_pack_start_dirs(void);
  void load_start_packages(void);
  void ex_packloadall(exarg_T *eap);
--- 69,78 ----
  void ex_listdo(exarg_T *eap);
  void ex_compiler(exarg_T *eap);
  void ex_runtime(exarg_T *eap);
  int do_in_path(char_u *path, char_u *name, int flags, void (*callback)(char_u *fname, void *ck), void *cookie);
  int do_in_runtimepath(char_u *name, int flags, void (*callback)(char_u *fname, void *ck), void *cookie);
+ int source_runtime(char_u *name, int flags);
+ int source_in_path(char_u *path, char_u *name, int flags);
  void add_pack_start_dirs(void);
  void load_start_packages(void);
  void ex_packloadall(exarg_T *eap);
*** ../vim-8.0.0679/src/version.c	2017-06-26 09:59:30.573041754 +0200
--- src/version.c	2017-06-27 14:37:36.877929410 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     680,
  /**/

-- 
Where do you want to crash today?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
