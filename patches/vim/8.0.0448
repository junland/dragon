To: vim_dev@googlegroups.com
Subject: Patch 8.0.0448
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0448
Problem:    Some macros are in lower case, which can be confusing.
Solution:   Make a few lower case macros upper case.
Files:      src/macros.h, src/buffer.c, src/charset.c, src/ops.c, src/diff.c,
            src/edit.c, src/evalfunc.c, src/ex_cmds.c, src/ex_getln.c,
            src/fileio.c, src/fold.c, src/gui.c, src/gui_beval.c, src/main.c,
            src/mark.c, src/misc1.c, src/move.c, src/normal.c,
            src/option.c, src/popupmnu.c, src/regexp.c, src/screen.c,
            src/search.c, src/spell.c, src/tag.c, src/ui.c, src/undo.c,
	    src/version.c, src/workshop.c, src/if_perl.xs



*** ../vim-8.0.0447/src/macros.h	2016-11-06 14:17:13.182972857 +0100
--- src/macros.h	2017-03-12 18:10:53.595395697 +0100
***************
*** 11,56 ****
   */
  
  /*
!  * pchar(lp, c) - put character 'c' at position 'lp'
   */
! #define pchar(lp, c) (*(ml_get_buf(curbuf, (lp).lnum, TRUE) + (lp).col) = (c))
  
  /*
   * Position comparisons
   */
  #ifdef FEAT_VIRTUALEDIT
! # define lt(a, b) (((a).lnum != (b).lnum) \
  		   ? (a).lnum < (b).lnum \
  		   : (a).col != (b).col \
  		       ? (a).col < (b).col \
  		       : (a).coladd < (b).coladd)
! # define ltp(a, b) (((a)->lnum != (b)->lnum) \
  		   ? (a)->lnum < (b)->lnum \
  		   : (a)->col != (b)->col \
  		       ? (a)->col < (b)->col \
  		       : (a)->coladd < (b)->coladd)
! # define equalpos(a, b) (((a).lnum == (b).lnum) && ((a).col == (b).col) && ((a).coladd == (b).coladd))
! # define clearpos(a) {(a)->lnum = 0; (a)->col = 0; (a)->coladd = 0;}
  #else
! # define lt(a, b) (((a).lnum != (b).lnum) \
  		   ? ((a).lnum < (b).lnum) : ((a).col < (b).col))
! # define ltp(a, b) (((a)->lnum != (b)->lnum) \
  		   ? ((a)->lnum < (b)->lnum) : ((a)->col < (b)->col))
! # define equalpos(a, b) (((a).lnum == (b).lnum) && ((a).col == (b).col))
! # define clearpos(a) {(a)->lnum = 0; (a)->col = 0;}
  #endif
  
! #define ltoreq(a, b) (lt(a, b) || equalpos(a, b))
  
  /*
!  * lineempty() - return TRUE if the line is empty
   */
! #define lineempty(p) (*ml_get(p) == NUL)
  
  /*
!  * bufempty() - return TRUE if the current buffer is empty
   */
! #define bufempty() (curbuf->b_ml.ml_line_count == 1 && *ml_get((linenr_T)1) == NUL)
  
  /*
   * toupper() and tolower() that use the current locale.
--- 11,56 ----
   */
  
  /*
!  * PCHAR(lp, c) - put character 'c' at position 'lp'
   */
! #define PCHAR(lp, c) (*(ml_get_buf(curbuf, (lp).lnum, TRUE) + (lp).col) = (c))
  
  /*
   * Position comparisons
   */
  #ifdef FEAT_VIRTUALEDIT
! # define LT_POS(a, b) (((a).lnum != (b).lnum) \
  		   ? (a).lnum < (b).lnum \
  		   : (a).col != (b).col \
  		       ? (a).col < (b).col \
  		       : (a).coladd < (b).coladd)
! # define LT_POSP(a, b) (((a)->lnum != (b)->lnum) \
  		   ? (a)->lnum < (b)->lnum \
  		   : (a)->col != (b)->col \
  		       ? (a)->col < (b)->col \
  		       : (a)->coladd < (b)->coladd)
! # define EQUAL_POS(a, b) (((a).lnum == (b).lnum) && ((a).col == (b).col) && ((a).coladd == (b).coladd))
! # define CLEAR_POS(a) {(a)->lnum = 0; (a)->col = 0; (a)->coladd = 0;}
  #else
! # define LT_POS(a, b) (((a).lnum != (b).lnum) \
  		   ? ((a).lnum < (b).lnum) : ((a).col < (b).col))
! # define LT_POSP(a, b) (((a)->lnum != (b)->lnum) \
  		   ? ((a)->lnum < (b)->lnum) : ((a)->col < (b)->col))
! # define EQUAL_POS(a, b) (((a).lnum == (b).lnum) && ((a).col == (b).col))
! # define CLEAR_POS(a) {(a)->lnum = 0; (a)->col = 0;}
  #endif
  
! #define LTOREQ_POS(a, b) (LT_POS(a, b) || EQUAL_POS(a, b))
  
  /*
!  * LINEEMPTY() - return TRUE if the line is empty
   */
! #define LINEEMPTY(p) (*ml_get(p) == NUL)
  
  /*
!  * BUFEMPTY() - return TRUE if the current buffer is empty
   */
! #define BUFEMPTY() (curbuf->b_ml.ml_line_count == 1 && *ml_get((linenr_T)1) == NUL)
  
  /*
   * toupper() and tolower() that use the current locale.
*** ../vim-8.0.0447/src/buffer.c	2017-03-05 17:43:10.616245604 +0100
--- src/buffer.c	2017-03-12 18:08:25.288475574 +0100
***************
*** 111,117 ****
      {
  	/* Set or reset 'modified' before executing autocommands, so that
  	 * it can be changed there. */
! 	if (!readonlymode && !bufempty())
  	    changed();
  	else if (retval == OK)
  	    unchanged(curbuf, FALSE);
--- 111,117 ----
      {
  	/* Set or reset 'modified' before executing autocommands, so that
  	 * it can be changed there. */
! 	if (!readonlymode && !BUFEMPTY())
  	    changed();
  	else if (retval == OK)
  	    unchanged(curbuf, FALSE);
***************
*** 1959,1965 ****
  	    && curbuf != NULL
  	    && curbuf->b_ffname == NULL
  	    && curbuf->b_nwindows <= 1
! 	    && (curbuf->b_ml.ml_mfp == NULL || bufempty()))
      {
  	buf = curbuf;
  #ifdef FEAT_AUTOCMD
--- 1959,1965 ----
  	    && curbuf != NULL
  	    && curbuf->b_ffname == NULL
  	    && curbuf->b_nwindows <= 1
! 	    && (curbuf->b_ml.ml_mfp == NULL || BUFEMPTY()))
      {
  	buf = curbuf;
  #ifdef FEAT_AUTOCMD
***************
*** 2334,2340 ****
  	/* If 'switchbuf' contains "split", "vsplit" or "newtab" and the
  	 * current buffer isn't empty: open new tab or window */
  	if (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))
! 							       && !bufempty())
  	{
  	    if (swb_flags & SWB_NEWTAB)
  		tabpage_new();
--- 2334,2340 ----
  	/* If 'switchbuf' contains "split", "vsplit" or "newtab" and the
  	 * current buffer isn't empty: open new tab or window */
  	if (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))
! 							       && !BUFEMPTY())
  	{
  	    if (swb_flags & SWB_NEWTAB)
  		tabpage_new();
***************
*** 5017,5023 ****
  #ifdef FEAT_WINDOWS
      /* ":drop all" should re-use an empty window to avoid "--remote-tab"
       * leaving an empty tab page when executed locally. */
!     if (keep_tabs && bufempty() && curbuf->b_nwindows == 1
  			    && curbuf->b_ffname == NULL && !curbuf->b_changed)
  	use_firstwin = TRUE;
  #endif
--- 5017,5023 ----
  #ifdef FEAT_WINDOWS
      /* ":drop all" should re-use an empty window to avoid "--remote-tab"
       * leaving an empty tab page when executed locally. */
!     if (keep_tabs && BUFEMPTY() && curbuf->b_nwindows == 1
  			    && curbuf->b_ffname == NULL && !curbuf->b_changed)
  	use_firstwin = TRUE;
  #endif
*** ../vim-8.0.0447/src/charset.c	2017-02-05 15:10:47.743484042 +0100
--- src/charset.c	2017-03-12 18:00:43.599849485 +0100
***************
*** 1403,1409 ****
  		&& (State & NORMAL)
  		&& !wp->w_p_list
  		&& !virtual_active()
! 		&& !(VIsual_active && (*p_sel == 'e' || ltoreq(*pos, VIsual)))
  		)
  	    *cursor = vcol + incr - 1;	    /* cursor at end */
  	else
--- 1403,1410 ----
  		&& (State & NORMAL)
  		&& !wp->w_p_list
  		&& !virtual_active()
! 		&& !(VIsual_active
! 				&& (*p_sel == 'e' || LTOREQ_POS(*pos, VIsual)))
  		)
  	    *cursor = vcol + incr - 1;	    /* cursor at end */
  	else
***************
*** 1496,1502 ****
  {
      colnr_T	from1, from2, to1, to2;
  
!     if (ltp(pos1, pos2))
      {
  	getvvcol(wp, pos1, &from1, NULL, &to1);
  	getvvcol(wp, pos2, &from2, NULL, &to2);
--- 1497,1503 ----
  {
      colnr_T	from1, from2, to1, to2;
  
!     if (LT_POSP(pos1, pos2))
      {
  	getvvcol(wp, pos1, &from1, NULL, &to1);
  	getvvcol(wp, pos2, &from2, NULL, &to2);
*** ../vim-8.0.0447/src/ops.c	2017-03-05 18:02:59.999101021 +0100
--- src/ops.c	2017-03-12 18:09:38.955939134 +0100
***************
*** 2190,2196 ****
  	else if (!oap->inclusive)
  	    dec(&(oap->end));
  
! 	while (ltoreq(curwin->w_cursor, oap->end))
  	{
  	    n = gchar_cursor();
  	    if (n != NUL)
--- 2190,2196 ----
  	else if (!oap->inclusive)
  	    dec(&(oap->end));
  
! 	while (LTOREQ_POS(curwin->w_cursor, oap->end))
  	{
  	    n = gchar_cursor();
  	    if (n != NUL)
***************
*** 2229,2235 ****
  			    getvpos(&oap->end, end_vcol);
  		    }
  #endif
! 		    pchar(curwin->w_cursor, c);
  		}
  	    }
  #ifdef FEAT_VIRTUALEDIT
--- 2229,2235 ----
  			    getvpos(&oap->end, end_vcol);
  		    }
  #endif
! 		    PCHAR(curwin->w_cursor, c);
  		}
  	    }
  #ifdef FEAT_VIRTUALEDIT
***************
*** 2248,2254 ****
  		curwin->w_cursor.col -= (virtcols + 1);
  		for (; virtcols >= 0; virtcols--)
  		{
! 		    pchar(curwin->w_cursor, c);
  		    if (inc(&curwin->w_cursor) == -1)
  			break;
  		}
--- 2248,2254 ----
  		curwin->w_cursor.col -= (virtcols + 1);
  		for (; virtcols >= 0; virtcols--)
  		{
! 		    PCHAR(curwin->w_cursor, c);
  		    if (inc(&curwin->w_cursor) == -1)
  			break;
  		}
***************
*** 2338,2344 ****
  		did_change |= swapchars(oap->op_type, &pos,
  				pos.lnum == oap->end.lnum ? oap->end.col + 1:
  					   (int)STRLEN(ml_get_pos(&pos)));
! 		if (ltoreq(oap->end, pos) || inc(&pos) == -1)
  		    break;
  	    }
  	if (did_change)
--- 2338,2344 ----
  		did_change |= swapchars(oap->op_type, &pos,
  				pos.lnum == oap->end.lnum ? oap->end.col + 1:
  					   (int)STRLEN(ml_get_pos(&pos)));
! 		if (LTOREQ_POS(oap->end, pos) || inc(&pos) == -1)
  		    break;
  	    }
  	if (did_change)
***************
*** 2490,2496 ****
  	}
  	else
  #endif
! 	    pchar(*pos, nc);
  	return TRUE;
      }
      return FALSE;
--- 2490,2496 ----
  	}
  	else
  #endif
! 	    PCHAR(*pos, nc);
  	return TRUE;
      }
      return FALSE;
***************
*** 2575,2581 ****
  	    check_cursor_col();
  
  	    /* Works just like an 'i'nsert on the next character. */
! 	    if (!lineempty(curwin->w_cursor.lnum)
  		    && oap->start_vcol != oap->end_vcol)
  		inc_cursor();
  	}
--- 2575,2581 ----
  	    check_cursor_col();
  
  	    /* Works just like an 'i'nsert on the next character. */
! 	    if (!LINEEMPTY(curwin->w_cursor.lnum)
  		    && oap->start_vcol != oap->end_vcol)
  		inc_cursor();
  	}
***************
*** 2588,2594 ****
       * have been converted to a tab as well, the column of the cursor
       * might have actually been reduced, so need to adjust here. */
      if (t1.lnum == curbuf->b_op_start_orig.lnum
! 	    && lt(curbuf->b_op_start_orig, t1))
  	oap->start = curbuf->b_op_start_orig;
  
      /* If user has moved off this line, we don't know what to do, so do
--- 2588,2594 ----
       * have been converted to a tab as well, the column of the cursor
       * might have actually been reduced, so need to adjust here. */
      if (t1.lnum == curbuf->b_op_start_orig.lnum
! 	    && LT_POS(curbuf->b_op_start_orig, t1))
  	oap->start = curbuf->b_op_start_orig;
  
      /* If user has moved off this line, we don't know what to do, so do
***************
*** 2735,2741 ****
      else if (op_delete(oap) == FAIL)
  	return FALSE;
  
!     if ((l > curwin->w_cursor.col) && !lineempty(curwin->w_cursor.lnum)
  							 && !virtual_op)
  	inc_cursor();
  
--- 2735,2741 ----
      else if (op_delete(oap) == FAIL)
  	return FALSE;
  
!     if ((l > curwin->w_cursor.col) && !LINEEMPTY(curwin->w_cursor.lnum)
  							 && !virtual_op)
  	inc_cursor();
  
***************
*** 3519,3525 ****
  	    ++lnum;
  	/* In an empty buffer the empty line is going to be replaced, include
  	 * it in the saved lines. */
! 	if ((bufempty() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)
  	    goto end;
  #ifdef FEAT_FOLDING
  	if (dir == FORWARD)
--- 3519,3525 ----
  	    ++lnum;
  	/* In an empty buffer the empty line is going to be replaced, include
  	 * it in the saved lines. */
! 	if ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)
  	    goto end;
  #ifdef FEAT_FOLDING
  	if (dir == FORWARD)
***************
*** 4936,4942 ****
  		    && prev_is_end_par
  		    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
  	    {
! 		if (do_second_indent && !lineempty(curwin->w_cursor.lnum + 1))
  		{
  #ifdef FEAT_COMMENTS
  		    if (leader_len == 0 && next_leader_len == 0)
--- 4936,4942 ----
  		    && prev_is_end_par
  		    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
  	    {
! 		if (do_second_indent && !LINEEMPTY(curwin->w_cursor.lnum + 1))
  		{
  #ifdef FEAT_COMMENTS
  		    if (leader_len == 0 && next_leader_len == 0)
***************
*** 7237,7243 ****
  
  	if (VIsual_active)
  	{
! 	    if (lt(VIsual, curwin->w_cursor))
  	    {
  		min_pos = VIsual;
  		max_pos = curwin->w_cursor;
--- 7237,7243 ----
  
  	if (VIsual_active)
  	{
! 	    if (LT_POS(VIsual, curwin->w_cursor))
  	    {
  		min_pos = VIsual;
  		max_pos = curwin->w_cursor;
*** ../vim-8.0.0447/src/diff.c	2017-03-11 19:21:49.230723995 +0100
--- src/diff.c	2017-03-12 18:08:48.364307530 +0100
***************
*** 2333,2339 ****
  		    end_skip = 0;
  	    }
  
! 	    buf_empty = bufempty();
  	    added = 0;
  	    for (i = 0; i < count; ++i)
  	    {
--- 2333,2339 ----
  		    end_skip = 0;
  	    }
  
! 	    buf_empty = BUFEMPTY();
  	    added = 0;
  	    for (i = 0; i < count; ++i)
  	    {
*** ../vim-8.0.0447/src/edit.c	2017-03-09 18:19:58.157107877 +0100
--- src/edit.c	2017-03-12 18:08:55.384256409 +0100
***************
*** 408,414 ****
  	 * the "A" command, thus set State to avoid that. Also check that the
  	 * line number is still valid (lines may have been deleted).
  	 * Do not restore if v:char was set to a non-empty string. */
! 	if (!equalpos(curwin->w_cursor, save_cursor)
  # ifdef FEAT_EVAL
  		&& *get_vim_var_str(VV_CHAR) == NUL
  # endif
--- 408,414 ----
  	 * the "A" command, thus set State to avoid that. Also check that the
  	 * line number is still valid (lines may have been deleted).
  	 * Do not restore if v:char was set to a non-empty string. */
! 	if (!EQUAL_POS(curwin->w_cursor, save_cursor)
  # ifdef FEAT_EVAL
  		&& *get_vim_var_str(VV_CHAR) == NUL
  # endif
***************
*** 1631,1637 ****
  # endif
  		)
  # ifdef FEAT_AUTOCMD
! 	&& !equalpos(last_cursormoved, curwin->w_cursor)
  # endif
  # ifdef FEAT_INS_EXPAND
  	&& !pum_visible()
--- 1631,1637 ----
  # endif
  		)
  # ifdef FEAT_AUTOCMD
! 	&& !EQUAL_POS(last_cursormoved, curwin->w_cursor)
  # endif
  # ifdef FEAT_INS_EXPAND
  	&& !pum_visible()
***************
*** 4130,4136 ****
      }
      curwin->w_cursor = pos;	/* restore the cursor position */
      validate_cursor();
!     if (!equalpos(curwin->w_cursor, pos))
      {
  	EMSG(_(e_compldel));
  	goto theend;
--- 4130,4136 ----
      }
      curwin->w_cursor = pos;	/* restore the cursor position */
      validate_cursor();
!     if (!EQUAL_POS(curwin->w_cursor, pos))
      {
  	EMSG(_(e_compldel));
  	goto theend;
***************
*** 5408,5414 ****
  	    }
  	    curwin->w_cursor = pos;	/* restore the cursor position */
  	    validate_cursor();
! 	    if (!equalpos(curwin->w_cursor, pos))
  	    {
  		EMSG(_(e_compldel));
  		return FAIL;
--- 5408,5414 ----
  	    }
  	    curwin->w_cursor = pos;	/* restore the cursor position */
  	    validate_cursor();
! 	    if (!EQUAL_POS(curwin->w_cursor, pos))
  	    {
  		EMSG(_(e_compldel));
  		return FAIL;
***************
*** 8947,8953 ****
       * can't backup past starting point unless 'backspace' > 1
       * can backup to a previous line if 'backspace' == 0
       */
!     if (       bufempty()
  	    || (
  #ifdef FEAT_RIGHTLEFT
  		!revins_on &&
--- 8947,8953 ----
       * can't backup past starting point unless 'backspace' > 1
       * can backup to a previous line if 'backspace' == 0
       */
!     if (       BUFEMPTY()
  	    || (
  #ifdef FEAT_RIGHTLEFT
  		!revins_on &&
***************
*** 9462,9468 ****
      }
  # endif
  
!     if (!equalpos(curwin->w_cursor, tpos))
      {
  	start_arrow(&tpos);
  # ifdef FEAT_CINDENT
--- 9462,9468 ----
      }
  # endif
  
!     if (!EQUAL_POS(curwin->w_cursor, tpos))
      {
  	start_arrow(&tpos);
  # ifdef FEAT_CINDENT
*** ../vim-8.0.0447/src/evalfunc.c	2017-03-09 18:19:58.161107848 +0100
--- src/evalfunc.c	2017-03-12 18:04:52.098030950 +0100
***************
*** 9552,9571 ****
  
      save_cursor = curwin->w_cursor;
      pos = curwin->w_cursor;
!     clearpos(&firstpos);
!     clearpos(&foundpos);
      pat = pat3;
      for (;;)
      {
  	n = searchit(curwin, curbuf, &pos, dir, pat, 1L,
  					   options, RE_SEARCH, lnum_stop, &tm);
! 	if (n == FAIL || (firstpos.lnum != 0 && equalpos(pos, firstpos)))
  	    /* didn't find it or found the first match again: FAIL */
  	    break;
  
  	if (firstpos.lnum == 0)
  	    firstpos = pos;
! 	if (equalpos(pos, foundpos))
  	{
  	    /* Found the same position again.  Can happen with a pattern that
  	     * has "\zs" at the end and searching backwards.  Advance one
--- 9552,9571 ----
  
      save_cursor = curwin->w_cursor;
      pos = curwin->w_cursor;
!     CLEAR_POS(&firstpos);
!     CLEAR_POS(&foundpos);
      pat = pat3;
      for (;;)
      {
  	n = searchit(curwin, curbuf, &pos, dir, pat, 1L,
  					   options, RE_SEARCH, lnum_stop, &tm);
! 	if (n == FAIL || (firstpos.lnum != 0 && EQUAL_POS(pos, firstpos)))
  	    /* didn't find it or found the first match again: FAIL */
  	    break;
  
  	if (firstpos.lnum == 0)
  	    firstpos = pos;
! 	if (EQUAL_POS(pos, foundpos))
  	{
  	    /* Found the same position again.  Can happen with a pattern that
  	     * has "\zs" at the end and searching backwards.  Advance one
*** ../vim-8.0.0447/src/ex_cmds.c	2017-02-26 14:00:03.852862844 +0100
--- src/ex_cmds.c	2017-03-12 17:57:57.817063790 +0100
***************
*** 851,874 ****
       * their final destination at the new text position -- webb
       */
      last_line = curbuf->b_ml.ml_line_count;
!     mark_adjust(line1, line2, last_line - line2, 0L);
!     changed_lines(last_line - num_lines + 1, 0, last_line + 1, num_lines);
      if (dest >= line2)
      {
! 	mark_adjust(line2 + 1, dest, -num_lines, 0L);
  	curbuf->b_op_start.lnum = dest - num_lines + 1;
  	curbuf->b_op_end.lnum = dest;
      }
      else
      {
! 	mark_adjust(dest + 1, line1 - 1, num_lines, 0L);
  	curbuf->b_op_start.lnum = dest + 1;
  	curbuf->b_op_end.lnum = dest + num_lines;
      }
      curbuf->b_op_start.col = curbuf->b_op_end.col = 0;
!     mark_adjust(last_line - num_lines + 1, last_line,
  					     -(last_line - dest - extra), 0L);
-     changed_lines(last_line - num_lines + 1, 0, last_line + 1, -extra);
  
      /*
       * Now we delete the original text -- webb
--- 851,891 ----
       * their final destination at the new text position -- webb
       */
      last_line = curbuf->b_ml.ml_line_count;
!     mark_adjust_nofold(line1, line2, last_line - line2, 0L);
      if (dest >= line2)
      {
! 	mark_adjust_nofold(line2 + 1, dest, -num_lines, 0L);
! #ifdef FEAT_FOLDING
! 	win_T	    *win;
! 	tabpage_T   *tp;
! 
! 	FOR_ALL_TAB_WINDOWS(tp, win) {
! 	    if (win->w_buffer == curbuf)
! 		foldSwapRange(&win->w_folds, line1, line2, dest + 1,
! 			dest + num_lines);
! 	}
! #endif
  	curbuf->b_op_start.lnum = dest - num_lines + 1;
  	curbuf->b_op_end.lnum = dest;
      }
      else
      {
! 	mark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L);
! #ifdef FEAT_FOLDING
! 	win_T	    *win;
! 	tabpage_T   *tp;
! 
! 	FOR_ALL_TAB_WINDOWS(tp, win) {
! 	    if (win->w_buffer == curbuf)
! 		foldSwapRange(&win->w_folds, dest + 1, line1 - 1, line1, line2);
! 	}
! #endif
  	curbuf->b_op_start.lnum = dest + 1;
  	curbuf->b_op_end.lnum = dest + num_lines;
      }
      curbuf->b_op_start.col = curbuf->b_op_end.col = 0;
!     mark_adjust_nofold(last_line - num_lines + 1, last_line,
  					     -(last_line - dest - extra), 0L);
  
      /*
       * Now we delete the original text -- webb
***************
*** 4211,4217 ****
  
  	/* If autocommands change the cursor position or topline, we should
  	 * keep it.  Also when it moves within a line. */
! 	if (!equalpos(curwin->w_cursor, orig_pos))
  	{
  	    newlnum = curwin->w_cursor.lnum;
  	    newcol = curwin->w_cursor.col;
--- 4228,4234 ----
  
  	/* If autocommands change the cursor position or topline, we should
  	 * keep it.  Also when it moves within a line. */
! 	if (!EQUAL_POS(curwin->w_cursor, orig_pos))
  	{
  	    newlnum = curwin->w_cursor.lnum;
  	    newcol = curwin->w_cursor.col;
*** ../vim-8.0.0447/src/ex_getln.c	2017-02-26 14:00:03.852862844 +0100
--- src/ex_getln.c	2017-03-12 18:04:55.590005409 +0100
***************
*** 234,240 ****
  
      ccline.overstrike = FALSE;		    /* always start in insert mode */
  #ifdef FEAT_SEARCH_EXTRA
!     clearpos(&match_end);
      save_cursor = curwin->w_cursor;	    /* may be restored later */
      search_start = curwin->w_cursor;
      old_curswant = curwin->w_curswant;
--- 234,240 ----
  
      ccline.overstrike = FALSE;		    /* always start in insert mode */
  #ifdef FEAT_SEARCH_EXTRA
!     CLEAR_POS(&match_end);
      save_cursor = curwin->w_cursor;	    /* may be restored later */
      search_start = curwin->w_cursor;
      old_curswant = curwin->w_curswant;
***************
*** 1479,1485 ****
  		    if (did_incsearch)
  		    {
  			curwin->w_cursor = match_end;
! 			if (!equalpos(curwin->w_cursor, search_start))
  			{
  			    c = gchar_cursor();
  			    /* If 'ignorecase' and 'smartcase' are set and the
--- 1479,1485 ----
  		    if (did_incsearch)
  		    {
  			curwin->w_cursor = match_end;
! 			if (!EQUAL_POS(curwin->w_cursor, search_start))
  			{
  			    c = gchar_cursor();
  			    /* If 'ignorecase' and 'smartcase' are set and the
***************
*** 1707,1713 ****
  			    search_start = t;
  			    (void)decl(&search_start);
  			}
! 			if (lt(t, search_start) && c == Ctrl_G)
  			{
  			    /* wrap around */
  			    search_start = t;
--- 1707,1713 ----
  			    search_start = t;
  			    (void)decl(&search_start);
  			}
! 			if (LT_POS(t, search_start) && c == Ctrl_G)
  			{
  			    /* wrap around */
  			    search_start = t;
***************
*** 2007,2013 ****
  	    curwin->w_cursor = save_cursor;
  	else
  	{
! 	    if (!equalpos(save_cursor, search_start))
  	    {
  		/* put the '" mark at the original position */
  		curwin->w_cursor = save_cursor;
--- 2007,2013 ----
  	    curwin->w_cursor = save_cursor;
  	else
  	{
! 	    if (!EQUAL_POS(save_cursor, search_start))
  	    {
  		/* put the '" mark at the original position */
  		curwin->w_cursor = save_cursor;
*** ../vim-8.0.0447/src/fileio.c	2017-02-25 14:59:29.906090427 +0100
--- src/fileio.c	2017-03-12 18:09:15.736108210 +0100
***************
*** 7118,7124 ****
  	 * the old contents.  Can't use memory only, the file might be
  	 * too big.  Use a hidden buffer to move the buffer contents to.
  	 */
! 	if (bufempty() || saved == FAIL)
  	    savebuf = NULL;
  	else
  	{
--- 7118,7124 ----
  	 * the old contents.  Can't use memory only, the file might be
  	 * too big.  Use a hidden buffer to move the buffer contents to.
  	 */
! 	if (BUFEMPTY() || saved == FAIL)
  	    savebuf = NULL;
  	else
  	{
***************
*** 7161,7167 ****
  		{
  		    /* Put the text back from the save buffer.  First
  		     * delete any lines that readfile() added. */
! 		    while (!bufempty())
  			if (ml_delete(buf->b_ml.ml_line_count, FALSE) == FAIL)
  			    break;
  		    (void)move_lines(savebuf, buf);
--- 7161,7167 ----
  		{
  		    /* Put the text back from the save buffer.  First
  		     * delete any lines that readfile() added. */
! 		    while (!BUFEMPTY())
  			if (ml_delete(buf->b_ml.ml_line_count, FALSE) == FAIL)
  			    break;
  		    (void)move_lines(savebuf, buf);
*** ../vim-8.0.0447/src/fold.c	2017-03-04 18:42:35.715691765 +0100
--- src/fold.c	2017-03-12 18:00:58.355741445 +0100
***************
*** 1039,1045 ****
      if (!VIsual_active || !hasAnyFolding(curwin))
  	return;
  
!     if (ltoreq(VIsual, curwin->w_cursor))
      {
  	start = &VIsual;
  	end = &curwin->w_cursor;
--- 1040,1046 ----
      if (!VIsual_active || !hasAnyFolding(curwin))
  	return;
  
!     if (LTOREQ_POS(VIsual, curwin->w_cursor))
      {
  	start = &VIsual;
  	end = &curwin->w_cursor;
*** ../vim-8.0.0447/src/gui.c	2017-02-03 22:01:43.938349448 +0100
--- src/gui.c	2017-03-12 17:58:08.268987207 +0100
***************
*** 4476,4482 ****
  	pum_redraw();
  #endif
  
!     return (wp == curwin && !equalpos(curwin->w_cursor, old_cursor));
  }
  
  
--- 4476,4482 ----
  	pum_redraw();
  #endif
  
!     return (wp == curwin && !EQUAL_POS(curwin->w_cursor, old_cursor));
  }
  
  
***************
*** 5118,5124 ****
  		curwin->w_p_cole > 0
  # endif
  		)
! 		     && !equalpos(last_cursormoved, curwin->w_cursor))
      {
  # ifdef FEAT_AUTOCMD
  	if (has_cursormoved())
--- 5118,5124 ----
  		curwin->w_p_cole > 0
  # endif
  		)
! 		     && !EQUAL_POS(last_cursormoved, curwin->w_cursor))
      {
  # ifdef FEAT_AUTOCMD
  	if (has_cursormoved())
*** ../vim-8.0.0447/src/gui_beval.c	2016-11-17 19:11:51.713378271 +0100
--- src/gui_beval.c	2017-03-12 17:54:45.174475990 +0100
***************
*** 84,90 ****
  	    result = eval_to_string(bexpr, NULL, TRUE);
  
  	    /* Remove one trailing newline, it is added when the result was a
! 	     * list and it's hardly every useful.  If the user really wants a
  	     * trailing newline he can add two and one remains. */
  	    if (result != NULL)
  	    {
--- 84,90 ----
  	    result = eval_to_string(bexpr, NULL, TRUE);
  
  	    /* Remove one trailing newline, it is added when the result was a
! 	     * list and it's hardly ever useful.  If the user really wants a
  	     * trailing newline he can add two and one remains. */
  	    if (result != NULL)
  	    {
***************
*** 366,372 ****
  
  		    if (VIsual_active)
  		    {
! 			if (lt(VIsual, curwin->w_cursor))
  			{
  			    spos = &VIsual;
  			    epos = &curwin->w_cursor;
--- 366,372 ----
  
  		    if (VIsual_active)
  		    {
! 			if (LT_POS(VIsual, curwin->w_cursor))
  			{
  			    spos = &VIsual;
  			    epos = &curwin->w_cursor;
*** ../vim-8.0.0447/src/main.c	2017-03-05 17:43:10.620245573 +0100
--- src/main.c	2017-03-12 17:58:11.256965313 +0100
***************
*** 1144,1150 ****
  # endif
  			)
  # ifdef FEAT_AUTOCMD
! 		 && !equalpos(last_cursormoved, curwin->w_cursor)
  # endif
  		 )
  	    {
--- 1144,1150 ----
  # endif
  			)
  # ifdef FEAT_AUTOCMD
! 		 && !EQUAL_POS(last_cursormoved, curwin->w_cursor)
  # endif
  		 )
  	    {
***************
*** 3557,3564 ****
--- 3568,3578 ----
  			   && vim_FullName(argv0, buf, MAXPATHL, TRUE) != FAIL)
  	    val = buf;
      }
+ #  endif
  # endif
+ 
      set_vim_var_string(VV_PROGPATH, val, -1);
+ 
  # ifdef WIN32
      vim_free(path);
  # endif
*** ../vim-8.0.0447/src/mark.c	2017-01-28 18:23:49.725039260 +0100
--- src/mark.c	2017-03-12 17:58:35.896784789 +0100
***************
*** 206,212 ****
  checkpcmark(void)
  {
      if (curwin->w_prev_pcmark.lnum != 0
! 	    && (equalpos(curwin->w_pcmark, curwin->w_cursor)
  		|| curwin->w_pcmark.lnum == 0))
      {
  	curwin->w_pcmark = curwin->w_prev_pcmark;
--- 208,214 ----
  checkpcmark(void)
  {
      if (curwin->w_prev_pcmark.lnum != 0
! 	    && (EQUAL_POS(curwin->w_pcmark, curwin->w_cursor)
  		|| curwin->w_pcmark.lnum == 0))
      {
  	curwin->w_pcmark = curwin->w_prev_pcmark;
***************
*** 401,407 ****
      {
  	startp = &buf->b_visual.vi_start;
  	endp = &buf->b_visual.vi_end;
! 	if (((c == '<') == lt(*startp, *endp) || endp->lnum == 0)
  							  && startp->lnum != 0)
  	    posp = startp;
  	else
--- 403,409 ----
      {
  	startp = &buf->b_visual.vi_start;
  	endp = &buf->b_visual.vi_end;
! 	if (((c == '<') == LT_POS(*startp, *endp) || endp->lnum == 0)
  							  && startp->lnum != 0)
  	    posp = startp;
  	else
***************
*** 497,510 ****
  	{
  	    if (dir == FORWARD)
  	    {
! 		if ((result == NULL || lt(curbuf->b_namedm[i], *result))
! 			&& lt(pos, curbuf->b_namedm[i]))
  		    result = &curbuf->b_namedm[i];
  	    }
  	    else
  	    {
! 		if ((result == NULL || lt(*result, curbuf->b_namedm[i]))
! 			&& lt(curbuf->b_namedm[i], pos))
  		    result = &curbuf->b_namedm[i];
  	    }
  	}
--- 499,512 ----
  	{
  	    if (dir == FORWARD)
  	    {
! 		if ((result == NULL || LT_POS(curbuf->b_namedm[i], *result))
! 			&& LT_POS(pos, curbuf->b_namedm[i]))
  		    result = &curbuf->b_namedm[i];
  	    }
  	    else
  	    {
! 		if ((result == NULL || LT_POS(*result, curbuf->b_namedm[i]))
! 			&& LT_POS(curbuf->b_namedm[i], pos))
  		    result = &curbuf->b_namedm[i];
  	    }
  	}
***************
*** 1063,1069 ****
  	one_adjust(&(curbuf->b_last_change.lnum));
  
  	/* last cursor position, if it was set */
! 	if (!equalpos(curbuf->b_last_cursor, initpos))
  	    one_adjust(&(curbuf->b_last_cursor.lnum));
  
  
--- 1086,1092 ----
  	one_adjust(&(curbuf->b_last_change.lnum));
  
  	/* last cursor position, if it was set */
! 	if (!EQUAL_POS(curbuf->b_last_cursor, initpos))
  	    one_adjust(&(curbuf->b_last_cursor.lnum));
  
  
***************
*** 1838,1844 ****
      for (i = 0; i < buf->b_changelistlen; ++i)
      {
  	/* skip duplicates */
! 	if (i == 0 || !equalpos(buf->b_changelist[i - 1], buf->b_changelist[i]))
  	    write_one_mark(fp_out, '+', &buf->b_changelist[i]);
      }
  #endif
--- 1862,1869 ----
      for (i = 0; i < buf->b_changelistlen; ++i)
      {
  	/* skip duplicates */
! 	if (i == 0 || !EQUAL_POS(buf->b_changelist[i - 1],
! 							 buf->b_changelist[i]))
  	    write_one_mark(fp_out, '+', &buf->b_changelist[i]);
      }
  #endif
*** ../vim-8.0.0447/src/misc1.c	2017-03-08 22:19:21.717870787 +0100
--- src/misc1.c	2017-03-12 17:59:51.080234077 +0100
***************
*** 5272,5278 ****
  
      /* If comment_pos is before rs_pos the raw string is inside the comment.
       * If rs_pos is before comment_pos the comment is inside the raw string. */
!     if (comment_pos == NULL || (rs_pos != NULL && lt(*rs_pos, *comment_pos)))
  	return rs_pos;
      return comment_pos;
  }
--- 5272,5279 ----
  
      /* If comment_pos is before rs_pos the raw string is inside the comment.
       * If rs_pos is before comment_pos the comment is inside the raw string. */
!     if (comment_pos == NULL || (rs_pos != NULL
! 					     && LT_POS(*rs_pos, *comment_pos)))
  	return rs_pos;
      return comment_pos;
  }
***************
*** 7217,7223 ****
  	comment_pos = &tryposCopy;
      }
      trypos = find_start_rawstring(curbuf->b_ind_maxcomment);
!     if (trypos != NULL && (comment_pos == NULL || lt(*trypos, *comment_pos)))
      {
  	amount = -1;
  	goto laterend;
--- 7218,7225 ----
  	comment_pos = &tryposCopy;
      }
      trypos = find_start_rawstring(curbuf->b_ind_maxcomment);
!     if (trypos != NULL && (comment_pos == NULL
! 					     || LT_POS(*trypos, *comment_pos)))
      {
  	amount = -1;
  	goto laterend;
***************
*** 9352,9358 ****
      {
  	paren = *pos;
  	pos = findmatch(NULL, '[');
! 	if (pos == NULL || ltp(pos, &paren))
  	    pos = &paren;
      }
      if (pos != NULL)
--- 9354,9360 ----
      {
  	paren = *pos;
  	pos = findmatch(NULL, '[');
! 	if (pos == NULL || LT_POSP(pos, &paren))
  	    pos = &paren;
      }
      if (pos != NULL)
*** ../vim-8.0.0447/src/move.c	2017-01-15 20:51:33.900962677 +0100
--- src/move.c	2017-03-12 18:09:32.059989347 +0100
***************
*** 210,216 ****
      /*
       * If the buffer is empty, always set topline to 1.
       */
!     if (bufempty())		/* special case - file is empty */
      {
  	if (curwin->w_topline != 1)
  	    redraw_later(NOT_VALID);
--- 210,216 ----
      /*
       * If the buffer is empty, always set topline to 1.
       */
!     if (BUFEMPTY())		/* special case - file is empty */
      {
  	if (curwin->w_topline != 1)
  	    redraw_later(NOT_VALID);
*** ../vim-8.0.0447/src/normal.c	2017-02-26 19:09:01.398217128 +0100
--- src/normal.c	2017-03-12 18:13:15.254364513 +0100
***************
*** 1540,1546 ****
  	    if (VIsual_select && VIsual_mode == 'V'
  					    && cap->oap->op_type != OP_DELETE)
  	    {
! 		if (lt(VIsual, curwin->w_cursor))
  		{
  		    VIsual.col = 0;
  		    curwin->w_cursor.col =
--- 1540,1546 ----
  	    if (VIsual_select && VIsual_mode == 'V'
  					    && cap->oap->op_type != OP_DELETE)
  	    {
! 		if (LT_POS(VIsual, curwin->w_cursor))
  		{
  		    VIsual.col = 0;
  		    curwin->w_cursor.col =
***************
*** 1572,1578 ****
  	 * Set oap->start to the first position of the operated text, oap->end
  	 * to the end of the operated text.  w_cursor is equal to oap->start.
  	 */
! 	if (lt(oap->start, curwin->w_cursor))
  	{
  #ifdef FEAT_FOLDING
  	    /* Include folded lines completely. */
--- 1572,1578 ----
  	 * Set oap->start to the first position of the operated text, oap->end
  	 * to the end of the operated text.  w_cursor is equal to oap->start.
  	 */
! 	if (LT_POS(oap->start, curwin->w_cursor))
  	{
  #ifdef FEAT_FOLDING
  	    /* Include folded lines completely. */
***************
*** 1776,1782 ****
  		    && (!oap->inclusive
  			|| (oap->op_type == OP_YANK
  			    && gchar_pos(&oap->end) == NUL))
! 		    && equalpos(oap->start, oap->end)
  #ifdef FEAT_VIRTUALEDIT
  		    && !(virtual_op && oap->start.coladd != oap->end.coladd)
  #endif
--- 1776,1782 ----
  		    && (!oap->inclusive
  			|| (oap->op_type == OP_YANK
  			    && gchar_pos(&oap->end) == NUL))
! 		    && EQUAL_POS(oap->start, oap->end)
  #ifdef FEAT_VIRTUALEDIT
  		    && !(virtual_op && oap->start.coladd != oap->end.coladd)
  #endif
***************
*** 2683,2694 ****
  			    jump_flags = MOUSE_MAY_STOP_VIS;
  			else
  			{
! 			    if ((lt(curwin->w_cursor, VIsual)
! 					&& (lt(m_pos, curwin->w_cursor)
! 					    || lt(VIsual, m_pos)))
! 				    || (lt(VIsual, curwin->w_cursor)
! 					&& (lt(m_pos, VIsual)
! 					    || lt(curwin->w_cursor, m_pos))))
  			    {
  				jump_flags = MOUSE_MAY_STOP_VIS;
  			    }
--- 2683,2694 ----
  			    jump_flags = MOUSE_MAY_STOP_VIS;
  			else
  			{
! 			    if ((LT_POS(curwin->w_cursor, VIsual)
! 					&& (LT_POS(m_pos, curwin->w_cursor)
! 					    || LT_POS(VIsual, m_pos)))
! 				    || (LT_POS(VIsual, curwin->w_cursor)
! 					&& (LT_POS(m_pos, VIsual)
! 					  || LT_POS(curwin->w_cursor, m_pos))))
  			    {
  				jump_flags = MOUSE_MAY_STOP_VIS;
  			    }
***************
*** 2754,2760 ****
  		 * Remember the start and end of visual before moving the
  		 * cursor.
  		 */
! 		if (lt(curwin->w_cursor, VIsual))
  		{
  		    start_visual = curwin->w_cursor;
  		    end_visual = VIsual;
--- 2754,2760 ----
  		 * Remember the start and end of visual before moving the
  		 * cursor.
  		 */
! 		if (LT_POS(curwin->w_cursor, VIsual))
  		{
  		    start_visual = curwin->w_cursor;
  		    end_visual = VIsual;
***************
*** 2891,2899 ****
  	     * If the click is after the end of visual, change the end.  If
  	     * the click is inside the visual, change the closest side.
  	     */
! 	    if (lt(curwin->w_cursor, start_visual))
  		VIsual = end_visual;
! 	    else if (lt(end_visual, curwin->w_cursor))
  		VIsual = start_visual;
  	    else
  	    {
--- 2891,2899 ----
  	     * If the click is after the end of visual, change the end.  If
  	     * the click is inside the visual, change the closest side.
  	     */
! 	    if (LT_POS(curwin->w_cursor, start_visual))
  		VIsual = end_visual;
! 	    else if (LT_POS(end_visual, curwin->w_cursor))
  		VIsual = start_visual;
  	    else
  	    {
***************
*** 3097,3103 ****
  		if (oap != NULL
  			&& VIsual_mode == 'v'
  			&& !vim_iswordc(gchar_pos(&end_visual))
! 			&& equalpos(curwin->w_cursor, VIsual)
  			&& (pos = findmatch(oap, NUL)) != NULL)
  		{
  		    curwin->w_cursor = *pos;
--- 3097,3103 ----
  		if (oap != NULL
  			&& VIsual_mode == 'v'
  			&& !vim_iswordc(gchar_pos(&end_visual))
! 			&& EQUAL_POS(curwin->w_cursor, VIsual)
  			&& (pos = findmatch(oap, NUL)) != NULL)
  		{
  		    curwin->w_cursor = *pos;
***************
*** 3105,3111 ****
  			VIsual_mode = 'V';
  		    else if (*p_sel == 'e')
  		    {
! 			if (lt(curwin->w_cursor, VIsual))
  			    ++VIsual.col;
  			else
  			    ++curwin->w_cursor.col;
--- 3105,3111 ----
  			VIsual_mode = 'V';
  		    else if (*p_sel == 'e')
  		    {
! 			if (LT_POS(curwin->w_cursor, VIsual))
  			    ++VIsual.col;
  			else
  			    ++curwin->w_cursor.col;
***************
*** 3117,3123 ****
  	    {
  		/* When not found a match or when dragging: extend to include
  		 * a word. */
! 		if (lt(curwin->w_cursor, orig_cursor))
  		{
  		    find_start_of_word(&curwin->w_cursor);
  		    find_end_of_word(&VIsual);
--- 3117,3123 ----
  	    {
  		/* When not found a match or when dragging: extend to include
  		 * a word. */
! 		if (LT_POS(curwin->w_cursor, orig_cursor))
  		{
  		    find_start_of_word(&curwin->w_cursor);
  		    find_end_of_word(&VIsual);
***************
*** 3745,3751 ****
  
      if (VIsual_active && !char_avail())
      {
! 	int		cursor_bot = lt(VIsual, curwin->w_cursor);
  	long		lines;
  	colnr_T		leftcol, rightcol;
  	linenr_T	top, bot;
--- 3745,3751 ----
  
      if (VIsual_active && !char_avail())
      {
! 	int		cursor_bot = LT_POS(VIsual, curwin->w_cursor);
  	long		lines;
  	colnr_T		leftcol, rightcol;
  	linenr_T	top, bot;
***************
*** 4353,4359 ****
      curwin->w_cursor.col = 0;
  
      /* Search forward for the identifier, ignore comment lines. */
!     clearpos(&found_pos);
      for (;;)
      {
  	valid = FALSE;
--- 4353,4359 ----
      curwin->w_cursor.col = 0;
  
      /* Search forward for the identifier, ignore comment lines. */
!     CLEAR_POS(&found_pos);
      for (;;)
      {
  	valid = FALSE;
***************
*** 4419,4431 ****
  	 * declarations this skips the function header without types. */
  	if (!valid)
  	{
! 	    /* Braces needed due to macro expansion of clearpos. */
! 	    clearpos(&found_pos);
  	}
  	else
- 	{
  	    found_pos = curwin->w_cursor;
- 	}
  	/* Remove SEARCH_START from flags to avoid getting stuck at one
  	 * position. */
  	searchflags &= ~SEARCH_START;
--- 4419,4428 ----
  	 * declarations this skips the function header without types. */
  	if (!valid)
  	{
! 	    CLEAR_POS(&found_pos);
  	}
  	else
  	    found_pos = curwin->w_cursor;
  	/* Remove SEARCH_START from flags to avoid getting stuck at one
  	 * position. */
  	searchflags &= ~SEARCH_START;
***************
*** 5834,5840 ****
      }
      else
      {
! 	if (lt(curwin->w_cursor, VIsual))
  	{
  	    *pp = ml_get_pos(&curwin->w_cursor);
  	    *lenp = VIsual.col - curwin->w_cursor.col + 1;
--- 5831,5837 ----
      }
      else
      {
! 	if (LT_POS(curwin->w_cursor, VIsual))
  	{
  	    *pp = ml_get_pos(&curwin->w_cursor);
  	    *lenp = VIsual.col - curwin->w_cursor.col + 1;
***************
*** 6020,6026 ****
  		 * included, move to next line after that */
  		if (	   cap->oap->op_type != OP_NOP
  			&& !cap->oap->inclusive
! 			&& !lineempty(curwin->w_cursor.lnum))
  		    cap->oap->inclusive = TRUE;
  		else
  		{
--- 6017,6023 ----
  		 * included, move to next line after that */
  		if (	   cap->oap->op_type != OP_NOP
  			&& !cap->oap->inclusive
! 			&& !LINEEMPTY(curwin->w_cursor.lnum))
  		    cap->oap->inclusive = TRUE;
  		else
  		{
***************
*** 6042,6048 ****
  	    }
  	    else
  	    {
! 		if (!lineempty(curwin->w_cursor.lnum))
  		    cap->oap->inclusive = TRUE;
  	    }
  	    break;
--- 6039,6045 ----
  	    }
  	    else
  	    {
! 		if (!LINEEMPTY(curwin->w_cursor.lnum))
  		    cap->oap->inclusive = TRUE;
  	    }
  	    break;
***************
*** 6121,6127 ****
  		 * Don't adjust op_end now, otherwise it won't work. */
  		if (	   (cap->oap->op_type == OP_DELETE
  			    || cap->oap->op_type == OP_CHANGE)
! 			&& !lineempty(curwin->w_cursor.lnum))
  		{
  		    char_u *cp = ml_get_cursor();
  
--- 6118,6124 ----
  		 * Don't adjust op_end now, otherwise it won't work. */
  		if (	   (cap->oap->op_type == OP_DELETE
  			    || cap->oap->op_type == OP_CHANGE)
! 			&& !LINEEMPTY(curwin->w_cursor.lnum))
  		{
  		    char_u *cp = ml_get_cursor();
  
***************
*** 6333,6339 ****
      }
  
      (void)normal_search(cap, cap->cmdchar, cap->searchbuf,
! 			(cap->arg || !equalpos(save_cursor, curwin->w_cursor))
  							   ? 0 : SEARCH_MARK);
  }
  
--- 6330,6336 ----
      }
  
      (void)normal_search(cap, cap->cmdchar, cap->searchbuf,
! 			(cap->arg || !EQUAL_POS(save_cursor, curwin->w_cursor))
  							   ? 0 : SEARCH_MARK);
  }
  
***************
*** 6347,6353 ****
      pos_T old = curwin->w_cursor;
      int   i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg);
  
!     if (i == 1 && equalpos(old, curwin->w_cursor))
      {
  	/* Avoid getting stuck on the current cursor position, which can
  	 * happen when an offset is given and the cursor is on the last char
--- 6344,6350 ----
      pos_T old = curwin->w_cursor;
      int   i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg);
  
!     if (i == 1 && EQUAL_POS(old, curwin->w_cursor))
      {
  	/* Avoid getting stuck on the current cursor position, which can
  	 * happen when an offset is given and the cursor is on the last char
***************
*** 6689,6697 ****
  
  	    if (VIsual_active)
  	    {
! 		start = ltoreq(VIsual, curwin->w_cursor)
  						  ? VIsual : curwin->w_cursor;
! 		end =  equalpos(start,VIsual) ? curwin->w_cursor : VIsual;
  		curwin->w_cursor = (dir == BACKWARD ? start : end);
  	    }
  # ifdef FEAT_CLIPBOARD
--- 6686,6694 ----
  
  	    if (VIsual_active)
  	    {
! 		start = LTOREQ_POS(VIsual, curwin->w_cursor)
  						  ? VIsual : curwin->w_cursor;
! 		end =  EQUAL_POS(start,VIsual) ? curwin->w_cursor : VIsual;
  		curwin->w_cursor = (dir == BACKWARD ? start : end);
  	    }
  # ifdef FEAT_CLIPBOARD
***************
*** 7315,7321 ****
      if (checkclearopq(cap->oap))
  	return;
  
!     if (lineempty(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL)
      {
  	clearopbeep(cap->oap);
  	return;
--- 7312,7318 ----
      if (checkclearopq(cap->oap))
  	return;
  
!     if (LINEEMPTY(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL)
      {
  	clearopbeep(cap->oap);
  	return;
***************
*** 7559,7565 ****
  #ifdef FEAT_FOLDING
      if (cap->oap->op_type == OP_NOP
  	    && pos != NULL
! 	    && (pos == (pos_T *)-1 || !equalpos(old_cursor, *pos))
  	    && (fdo_flags & FDO_MARK)
  	    && old_KeyTyped)
  	foldOpenCursor();
--- 7556,7562 ----
  #ifdef FEAT_FOLDING
      if (cap->oap->op_type == OP_NOP
  	    && pos != NULL
! 	    && (pos == (pos_T *)-1 || !EQUAL_POS(old_cursor, *pos))
  	    && (fdo_flags & FDO_MARK)
  	    && old_KeyTyped)
  	foldOpenCursor();
***************
*** 8763,8769 ****
  
      /* Don't leave the cursor on the NUL past the end of line. Unless we
       * didn't move it forward. */
!     if (lt(startpos, curwin->w_cursor))
  	adjust_cursor(cap->oap);
  
      if (n == FAIL && cap->oap->op_type == OP_NOP)
--- 8760,8766 ----
  
      /* Don't leave the cursor on the NUL past the end of line. Unless we
       * didn't move it forward. */
!     if (LT_POS(startpos, curwin->w_cursor))
  	adjust_cursor(cap->oap);
  
      if (n == FAIL && cap->oap->op_type == OP_NOP)
***************
*** 8833,8839 ****
  adjust_for_sel(cmdarg_T *cap)
  {
      if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'
! 	    && gchar_cursor() != NUL && lt(VIsual, curwin->w_cursor))
      {
  #ifdef FEAT_MBYTE
  	if (has_mbyte)
--- 8830,8836 ----
  adjust_for_sel(cmdarg_T *cap)
  {
      if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'
! 	    && gchar_cursor() != NUL && LT_POS(VIsual, curwin->w_cursor))
      {
  #ifdef FEAT_MBYTE
  	if (has_mbyte)
***************
*** 8855,8863 ****
  {
      pos_T	*pp;
  
!     if (*p_sel == 'e' && !equalpos(VIsual, curwin->w_cursor))
      {
! 	if (lt(VIsual, curwin->w_cursor))
  	    pp = &curwin->w_cursor;
  	else
  	    pp = &VIsual;
--- 8852,8860 ----
  {
      pos_T	*pp;
  
!     if (*p_sel == 'e' && !EQUAL_POS(VIsual, curwin->w_cursor))
      {
! 	if (LT_POS(VIsual, curwin->w_cursor))
  	    pp = &curwin->w_cursor;
  	else
  	    pp = &VIsual;
***************
*** 9071,9078 ****
  
  	/* When the last char in the line was deleted then append. Detect this
  	 * by checking if the cursor moved to before the Visual area. */
! 	if (*ml_get_cursor() != NUL && lt(curwin->w_cursor, old_pos)
! 					   && lt(curwin->w_cursor, old_visual))
  	    inc_cursor();
  
  	/* Insert to replace the deleted text with the pasted text. */
--- 9068,9075 ----
  
  	/* When the last char in the line was deleted then append. Detect this
  	 * by checking if the cursor moved to before the Visual area. */
! 	if (*ml_get_cursor() != NUL && LT_POS(curwin->w_cursor, old_pos)
! 				       && LT_POS(curwin->w_cursor, old_visual))
  	    inc_cursor();
  
  	/* Insert to replace the deleted text with the pasted text. */
*** ../vim-8.0.0447/src/option.c	2017-03-09 18:59:05.660711160 +0100
--- src/option.c	2017-03-12 18:09:54.567825462 +0100
***************
*** 4170,4176 ****
      }
  #endif
  
!     if (bufempty())
      {
  	int idx_ffs = findoption((char_u *)"ffs");
  
--- 4170,4176 ----
      }
  #endif
  
!     if (BUFEMPTY())
      {
  	int idx_ffs = findoption((char_u *)"ffs");
  
*** ../vim-8.0.0447/src/popupmnu.c	2016-11-24 17:47:03.865021031 +0100
--- src/popupmnu.c	2017-03-12 18:09:58.211798929 +0100
***************
*** 590,596 ****
  			&& curbuf->b_p_bh[0] == 'w')
  		{
  		    /* Already a "wipeout" buffer, make it empty. */
! 		    while (!bufempty())
  			ml_delete((linenr_T)1, FALSE);
  		}
  		else
--- 590,596 ----
  			&& curbuf->b_p_bh[0] == 'w')
  		{
  		    /* Already a "wipeout" buffer, make it empty. */
! 		    while (!BUFEMPTY())
  			ml_delete((linenr_T)1, FALSE);
  		}
  		else
*** ../vim-8.0.0447/src/regexp.c	2016-11-10 20:01:41.197582893 +0100
--- src/regexp.c	2017-03-12 17:56:40.025633901 +0100
***************
*** 4150,4156 ****
  
      if (VIsual_active)
      {
! 	if (lt(VIsual, wp->w_cursor))
  	{
  	    top = VIsual;
  	    bot = wp->w_cursor;
--- 4150,4156 ----
  
      if (VIsual_active)
      {
! 	if (LT_POS(VIsual, wp->w_cursor))
  	{
  	    top = VIsual;
  	    bot = wp->w_cursor;
***************
*** 4164,4170 ****
      }
      else
      {
! 	if (lt(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))
  	{
  	    top = curbuf->b_visual.vi_start;
  	    bot = curbuf->b_visual.vi_end;
--- 4164,4170 ----
      }
      else
      {
! 	if (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))
  	{
  	    top = curbuf->b_visual.vi_start;
  	    bot = curbuf->b_visual.vi_end;
*** ../vim-8.0.0447/src/screen.c	2017-03-09 18:19:58.161107848 +0100
--- src/screen.c	2017-03-12 18:01:53.231339720 +0100
***************
*** 2714,2720 ****
       */
      if (VIsual_active && wp->w_buffer == curwin->w_buffer)
      {
! 	if (ltoreq(curwin->w_cursor, VIsual))
  	{
  	    /* Visual is after curwin->w_cursor */
  	    top = &curwin->w_cursor;
--- 2714,2720 ----
       */
      if (VIsual_active && wp->w_buffer == curwin->w_buffer)
      {
! 	if (LTOREQ_POS(curwin->w_cursor, VIsual))
  	{
  	    /* Visual is after curwin->w_cursor */
  	    top = &curwin->w_cursor;
***************
*** 3170,3176 ****
      if (VIsual_active && wp->w_buffer == curwin->w_buffer)
      {
  					/* Visual is after curwin->w_cursor */
! 	if (ltoreq(curwin->w_cursor, VIsual))
  	{
  	    top = &curwin->w_cursor;
  	    bot = &VIsual;
--- 3170,3176 ----
      if (VIsual_active && wp->w_buffer == curwin->w_buffer)
      {
  					/* Visual is after curwin->w_cursor */
! 	if (LTOREQ_POS(curwin->w_cursor, VIsual))
  	{
  	    top = &curwin->w_cursor;
  	    bot = &VIsual;
*** ../vim-8.0.0447/src/search.c	2017-03-12 16:32:27.490343281 +0100
--- src/search.c	2017-03-12 18:13:25.858287335 +0100
***************
*** 2100,2106 ****
  
      do_quotes = -1;
      start_in_quotes = MAYBE;
!     clearpos(&match_pos);
  
      /* backward search: Check if this line contains a single-line comment */
      if ((backwards && comment_dir)
--- 2100,2106 ----
  
      do_quotes = -1;
      start_in_quotes = MAYBE;
!     CLEAR_POS(&match_pos);
  
      /* backward search: Check if this line contains a single-line comment */
      if ((backwards && comment_dir)
***************
*** 2720,2726 ****
  	    if (decl(&pos) == -1)
  		break;
  	    /* when going forward: Stop in front of empty line */
! 	    if (lineempty(pos.lnum) && dir == FORWARD)
  	    {
  		incl(&pos);
  		goto found;
--- 2720,2726 ----
  	    if (decl(&pos) == -1)
  		break;
  	    /* when going forward: Stop in front of empty line */
! 	    if (LINEEMPTY(pos.lnum) && dir == FORWARD)
  	    {
  		incl(&pos);
  		goto found;
***************
*** 3082,3088 ****
  	    while (cls() == 0)
  	    {
  		if (curwin->w_cursor.col == 0
! 				      && lineempty(curwin->w_cursor.lnum))
  		    goto finished;
  		if (dec_cursor() == -1) /* hit start of file, stop here */
  		    return OK;
--- 3082,3088 ----
  	    while (cls() == 0)
  	    {
  		if (curwin->w_cursor.col == 0
! 				      && LINEEMPTY(curwin->w_cursor.lnum))
  		    goto finished;
  		if (dec_cursor() == -1) /* hit start of file, stop here */
  		    return OK;
***************
*** 3163,3169 ****
  	    while (cls() == 0)
  	    {
  		if (empty && curwin->w_cursor.col == 0
! 					  && lineempty(curwin->w_cursor.lnum))
  		    goto finished;
  		if (inc_cursor() == -1)	    /* hit end of file, stop here */
  		    return FAIL;
--- 3163,3169 ----
  	    while (cls() == 0)
  	    {
  		if (empty && curwin->w_cursor.col == 0
! 					  && LINEEMPTY(curwin->w_cursor.lnum))
  		    goto finished;
  		if (inc_cursor() == -1)	    /* hit end of file, stop here */
  		    return FAIL;
***************
*** 3223,3229 ****
  	 */
  	while (cls() == 0)
  	{
! 	    if (curwin->w_cursor.col == 0 && lineempty(curwin->w_cursor.lnum))
  		break;
  	    if ((i = dec_cursor()) == -1 || (eol && i == 1))
  		return OK;
--- 3223,3229 ----
  	 */
  	while (cls() == 0)
  	{
! 	    if (curwin->w_cursor.col == 0 && LINEEMPTY(curwin->w_cursor.lnum))
  		break;
  	    if ((i = dec_cursor()) == -1 || (eol && i == 1))
  		return OK;
***************
*** 3320,3336 ****
      int		include_white = FALSE;
  
      cls_bigword = bigword;
!     clearpos(&start_pos);
  
      /* Correct cursor when 'selection' is exclusive */
!     if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))
  	dec_cursor();
  
      /*
       * When Visual mode is not active, or when the VIsual area is only one
       * character, select the word and/or white space under the cursor.
       */
!     if (!VIsual_active || equalpos(curwin->w_cursor, VIsual))
      {
  	/*
  	 * Go to start of current word or white space.
--- 3320,3336 ----
      int		include_white = FALSE;
  
      cls_bigword = bigword;
!     CLEAR_POS(&start_pos);
  
      /* Correct cursor when 'selection' is exclusive */
!     if (VIsual_active && *p_sel == 'e' && LT_POS(VIsual, curwin->w_cursor))
  	dec_cursor();
  
      /*
       * When Visual mode is not active, or when the VIsual area is only one
       * character, select the word and/or white space under the cursor.
       */
!     if (!VIsual_active || EQUAL_POS(curwin->w_cursor, VIsual))
      {
  	/*
  	 * Go to start of current word or white space.
***************
*** 3387,3393 ****
      while (count > 0)
      {
  	inclusive = TRUE;
! 	if (VIsual_active && lt(curwin->w_cursor, VIsual))
  	{
  	    /*
  	     * In Visual mode, with cursor at start: move cursor back.
--- 3387,3393 ----
      while (count > 0)
      {
  	inclusive = TRUE;
! 	if (VIsual_active && LT_POS(curwin->w_cursor, VIsual))
  	{
  	    /*
  	     * In Visual mode, with cursor at start: move cursor back.
***************
*** 3463,3469 ****
  
      if (VIsual_active)
      {
! 	if (*p_sel == 'e' && inclusive && ltoreq(VIsual, curwin->w_cursor))
  	    inc_cursor();
  	if (VIsual_mode == 'V')
  	{
--- 3463,3469 ----
  
      if (VIsual_active)
      {
! 	if (*p_sel == 'e' && inclusive && LTOREQ_POS(VIsual, curwin->w_cursor))
  	    inc_cursor();
  	if (VIsual_mode == 'V')
  	{
***************
*** 3498,3507 ****
      /*
       * When the Visual area is bigger than one character: Extend it.
       */
!     if (VIsual_active && !equalpos(start_pos, VIsual))
      {
  extend:
! 	if (lt(start_pos, VIsual))
  	{
  	    /*
  	     * Cursor at start of Visual area.
--- 3498,3507 ----
      /*
       * When the Visual area is bigger than one character: Extend it.
       */
!     if (VIsual_active && !EQUAL_POS(start_pos, VIsual))
      {
  extend:
! 	if (LT_POS(start_pos, VIsual))
  	{
  	    /*
  	     * Cursor at start of Visual area.
***************
*** 3512,3518 ****
  	     */
  	    at_start_sent = TRUE;
  	    decl(&pos);
! 	    while (lt(pos, curwin->w_cursor))
  	    {
  		c = gchar_pos(&pos);
  		if (!vim_iswhite(c))
--- 3512,3518 ----
  	     */
  	    at_start_sent = TRUE;
  	    decl(&pos);
! 	    while (LT_POS(pos, curwin->w_cursor))
  	    {
  		c = gchar_pos(&pos);
  		if (!vim_iswhite(c))
***************
*** 3525,3531 ****
  	    if (!at_start_sent)
  	    {
  		findsent(BACKWARD, 1L);
! 		if (equalpos(curwin->w_cursor, start_pos))
  		    at_start_sent = TRUE;  /* exactly at start of sentence */
  		else
  		    /* inside a sentence, go to its end (start of next) */
--- 3525,3531 ----
  	    if (!at_start_sent)
  	    {
  		findsent(BACKWARD, 1L);
! 		if (EQUAL_POS(curwin->w_cursor, start_pos))
  		    at_start_sent = TRUE;  /* exactly at start of sentence */
  		else
  		    /* inside a sentence, go to its end (start of next) */
***************
*** 3554,3563 ****
  	     */
  	    incl(&pos);
  	    at_start_sent = TRUE;
! 	    if (!equalpos(pos, curwin->w_cursor)) /* not just before a sentence */
  	    {
  		at_start_sent = FALSE;
! 		while (lt(pos, curwin->w_cursor))
  		{
  		    c = gchar_pos(&pos);
  		    if (!vim_iswhite(c))
--- 3554,3564 ----
  	     */
  	    incl(&pos);
  	    at_start_sent = TRUE;
! 	    /* not just before a sentence */
! 	    if (!EQUAL_POS(pos, curwin->w_cursor))
  	    {
  		at_start_sent = FALSE;
! 		while (LT_POS(pos, curwin->w_cursor))
  		{
  		    c = gchar_pos(&pos);
  		    if (!vim_iswhite(c))
***************
*** 3588,3594 ****
       */
      while (c = gchar_pos(&pos), vim_iswhite(c))	/* vim_iswhite() is a macro */
  	incl(&pos);
!     if (equalpos(pos, curwin->w_cursor))
      {
  	start_blank = TRUE;
  	find_first_blank(&start_pos);	/* go back to first blank */
--- 3589,3595 ----
       */
      while (c = gchar_pos(&pos), vim_iswhite(c))	/* vim_iswhite() is a macro */
  	incl(&pos);
!     if (EQUAL_POS(pos, curwin->w_cursor))
      {
  	start_blank = TRUE;
  	find_first_blank(&start_pos);	/* go back to first blank */
***************
*** 3633,3639 ****
      if (VIsual_active)
      {
  	/* Avoid getting stuck with "is" on a single space before a sentence. */
! 	if (equalpos(start_pos, curwin->w_cursor))
  	    goto extend;
  	if (*p_sel == 'e')
  	    ++curwin->w_cursor.col;
--- 3634,3640 ----
      if (VIsual_active)
      {
  	/* Avoid getting stuck with "is" on a single space before a sentence. */
! 	if (EQUAL_POS(start_pos, curwin->w_cursor))
  	    goto extend;
  	if (*p_sel == 'e')
  	    ++curwin->w_cursor.col;
***************
*** 3682,3688 ****
      /*
       * If we start on '(', '{', ')', '}', etc., use the whole block inclusive.
       */
!     if (!VIsual_active || equalpos(VIsual, curwin->w_cursor))
      {
  	setpcmark();
  	if (what == '{')		/* ignore indent */
--- 3683,3689 ----
      /*
       * If we start on '(', '{', ')', '}', etc., use the whole block inclusive.
       */
!     if (!VIsual_active || EQUAL_POS(VIsual, curwin->w_cursor))
      {
  	setpcmark();
  	if (what == '{')		/* ignore indent */
***************
*** 3693,3699 ****
  	    /* cursor on '(' or '{', move cursor just after it */
  	    ++curwin->w_cursor.col;
      }
!     else if (lt(VIsual, curwin->w_cursor))
      {
  	old_start = VIsual;
  	curwin->w_cursor = VIsual;	    /* cursor at low end of Visual */
--- 3694,3700 ----
  	    /* cursor on '(' or '{', move cursor just after it */
  	    ++curwin->w_cursor.col;
      }
!     else if (LT_POS(VIsual, curwin->w_cursor))
      {
  	old_start = VIsual;
  	curwin->w_cursor = VIsual;	    /* cursor at low end of Visual */
***************
*** 3751,3757 ****
  	 * In Visual mode, when the resulting area is not bigger than what we
  	 * started with, extend it to the next block, and then exclude again.
  	 */
! 	if (!lt(start_pos, old_start) && !lt(old_end, curwin->w_cursor)
  		&& VIsual_active)
  	{
  	    curwin->w_cursor = old_start;
--- 3752,3758 ----
  	 * In Visual mode, when the resulting area is not bigger than what we
  	 * started with, extend it to the next block, and then exclude again.
  	 */
! 	if (!LT_POS(start_pos, old_start) && !LT_POS(old_end, curwin->w_cursor)
  		&& VIsual_active)
  	{
  	    curwin->w_cursor = old_start;
***************
*** 3792,3798 ****
  	oap->inclusive = FALSE;
  	if (sol)
  	    incl(&curwin->w_cursor);
! 	else if (ltoreq(start_pos, curwin->w_cursor))
  	    /* Include the character under the cursor. */
  	    oap->inclusive = TRUE;
  	else
--- 3793,3799 ----
  	oap->inclusive = FALSE;
  	if (sol)
  	    incl(&curwin->w_cursor);
! 	else if (LTOREQ_POS(start_pos, curwin->w_cursor))
  	    /* Include the character under the cursor. */
  	    oap->inclusive = TRUE;
  	else
***************
*** 3916,3922 ****
      /*
       * If we start on "<aaa>" select that block.
       */
!     if (!VIsual_active || equalpos(VIsual, curwin->w_cursor))
      {
  	setpcmark();
  
--- 3917,3923 ----
      /*
       * If we start on "<aaa>" select that block.
       */
!     if (!VIsual_active || EQUAL_POS(VIsual, curwin->w_cursor))
      {
  	setpcmark();
  
***************
*** 3942,3948 ****
  	    old_end = curwin->w_cursor;
  	}
      }
!     else if (lt(VIsual, curwin->w_cursor))
      {
  	old_start = VIsual;
  	curwin->w_cursor = VIsual;	    /* cursor at low end of Visual */
--- 3943,3949 ----
  	    old_end = curwin->w_cursor;
  	}
      }
!     else if (LT_POS(VIsual, curwin->w_cursor))
      {
  	old_start = VIsual;
  	curwin->w_cursor = VIsual;	    /* cursor at low end of Visual */
***************
*** 3999,4005 ****
      vim_free(spat);
      vim_free(epat);
  
!     if (r < 1 || lt(curwin->w_cursor, old_end))
      {
  	/* Can't find other end or it's before the previous end.  Could be a
  	 * HTML tag that doesn't have a matching end.  Search backwards for
--- 4000,4006 ----
      vim_free(spat);
      vim_free(epat);
  
!     if (r < 1 || LT_POS(curwin->w_cursor, old_end))
      {
  	/* Can't find other end or it's before the previous end.  Could be a
  	 * HTML tag that doesn't have a matching end.  Search backwards for
***************
*** 4046,4052 ****
  
  	/* If we now have the same text as before reset "do_include" and try
  	 * again. */
! 	if (equalpos(start_pos, old_start) && equalpos(end_pos, old_end))
  	{
  	    do_include = TRUE;
  	    curwin->w_cursor = old_start;
--- 4047,4053 ----
  
  	/* If we now have the same text as before reset "do_include" and try
  	 * again. */
! 	if (EQUAL_POS(start_pos, old_start) && EQUAL_POS(end_pos, old_end))
  	{
  	    do_include = TRUE;
  	    curwin->w_cursor = old_start;
***************
*** 4059,4065 ****
      {
  	/* If the end is before the start there is no text between tags, select
  	 * the char under the cursor. */
! 	if (lt(end_pos, start_pos))
  	    curwin->w_cursor = start_pos;
  	else if (*p_sel == 'e')
  	    inc_cursor();
--- 4060,4066 ----
      {
  	/* If the end is before the start there is no text between tags, select
  	 * the char under the cursor. */
! 	if (LT_POS(end_pos, start_pos))
  	    curwin->w_cursor = start_pos;
  	else if (*p_sel == 'e')
  	    inc_cursor();
***************
*** 4072,4078 ****
      {
  	oap->start = start_pos;
  	oap->motion_type = MCHAR;
! 	if (lt(end_pos, start_pos))
  	{
  	    /* End is before the start: there is no text between tags; operate
  	     * on an empty area. */
--- 4073,4079 ----
      {
  	oap->start = start_pos;
  	oap->motion_type = MCHAR;
! 	if (LT_POS(end_pos, start_pos))
  	{
  	    /* End is before the start: there is no text between tags; operate
  	     * on an empty area. */
***************
*** 4362,4371 ****
  	if (VIsual.lnum != curwin->w_cursor.lnum)
  	    return FALSE;
  
! 	vis_bef_curs = lt(VIsual, curwin->w_cursor);
  	if (*p_sel == 'e' && vis_bef_curs)
  	    dec_cursor();
! 	vis_empty = equalpos(VIsual, curwin->w_cursor);
      }
  
      if (!vis_empty)
--- 4363,4372 ----
  	if (VIsual.lnum != curwin->w_cursor.lnum)
  	    return FALSE;
  
! 	vis_bef_curs = LT_POS(VIsual, curwin->w_cursor);
  	if (*p_sel == 'e' && vis_bef_curs)
  	    dec_cursor();
! 	vis_empty = EQUAL_POS(VIsual, curwin->w_cursor);
      }
  
      if (!vis_empty)
***************
*** 4605,4611 ****
      p_ws = FALSE;
  
      /* Correct cursor when 'selection' is exclusive */
!     if (VIsual_active && *p_sel == 'e' && lt(VIsual, curwin->w_cursor))
  	dec_cursor();
  
      if (VIsual_active)
--- 4606,4612 ----
      p_ws = FALSE;
  
      /* Correct cursor when 'selection' is exclusive */
!     if (VIsual_active && *p_sel == 'e' && LT_POS(VIsual, curwin->w_cursor))
  	dec_cursor();
  
      if (VIsual_active)
***************
*** 4668,4679 ****
  	}
  	else if (!i && !result)
  	{
! 	    if (forward) /* try again from start of buffer */
  	    {
! 		clearpos(&pos);
  	    }
! 	    else /* try again from end of buffer */
  	    {
  		/* searching backwards, so set pos to last line and col */
  		pos.lnum = curwin->w_buffer->b_ml.ml_line_count;
  		pos.col  = (colnr_T)STRLEN(
--- 4669,4682 ----
  	}
  	else if (!i && !result)
  	{
! 	    if (forward)
  	    {
! 		/* try again from start of buffer */
! 		CLEAR_POS(&pos);
  	    }
! 	    else
  	    {
+ 		/* try again from end of buffer */
  		/* searching backwards, so set pos to last line and col */
  		pos.lnum = curwin->w_buffer->b_ml.ml_line_count;
  		pos.col  = (colnr_T)STRLEN(
***************
*** 4709,4717 ****
  	if (*p_sel == 'e')
  	{
  	    /* Correction for exclusive selection depends on the direction. */
! 	    if (forward && ltoreq(VIsual, curwin->w_cursor))
  		inc_cursor();
! 	    else if (!forward && ltoreq(curwin->w_cursor, VIsual))
  		inc(&VIsual);
  	}
  
--- 4712,4720 ----
  	if (*p_sel == 'e')
  	{
  	    /* Correction for exclusive selection depends on the direction. */
! 	    if (forward && LTOREQ_POS(VIsual, curwin->w_cursor))
  		inc_cursor();
! 	    else if (!forward && LTOREQ_POS(curwin->w_cursor, VIsual))
  		inc(&VIsual);
  	}
  
***************
*** 4764,4770 ****
      regmatch.startpos[0].col = -1;
      /* move to match */
      if (move)
! 	clearpos(&pos)
      else
      {
  	pos = curwin->w_cursor;
--- 4767,4775 ----
      regmatch.startpos[0].col = -1;
      /* move to match */
      if (move)
!     {
! 	CLEAR_POS(&pos);
!     }
      else
      {
  	pos = curwin->w_cursor;
*** ../vim-8.0.0447/src/spell.c	2017-02-25 14:20:56.780372194 +0100
--- src/spell.c	2017-03-12 18:10:15.023676521 +0100
***************
*** 1603,1609 ****
       * though...
       */
      lnum = wp->w_cursor.lnum;
!     clearpos(&found_pos);
  
      while (!got_int)
      {
--- 1603,1609 ----
       * though...
       */
      lnum = wp->w_cursor.lnum;
!     CLEAR_POS(&found_pos);
  
      while (!got_int)
      {
***************
*** 8545,8551 ****
      set_option_value((char_u*)"spl",  dummy, spl, OPT_LOCAL);
      vim_free(spl);
  
!     if (!bufempty())
  	return;
  
      spell_dump_compl(NULL, 0, NULL, eap->forceit ? DUMPFLAG_COUNT : 0);
--- 8545,8551 ----
      set_option_value((char_u*)"spl",  dummy, spl, OPT_LOCAL);
      vim_free(spl);
  
!     if (!BUFEMPTY())
  	return;
  
      spell_dump_compl(NULL, 0, NULL, eap->forceit ? DUMPFLAG_COUNT : 0);
*** ../vim-8.0.0447/src/tag.c	2017-03-01 15:45:01.410957865 +0100
--- src/tag.c	2017-03-12 18:05:14.813864808 +0100
***************
*** 178,184 ****
      free_string_option(nofile_fname);
      nofile_fname = NULL;
  
!     clearpos(&saved_fmark.mark);	/* shutup gcc 4.0 */
      saved_fmark.fnum = 0;
  
      /*
--- 178,184 ----
      free_string_option(nofile_fname);
      nofile_fname = NULL;
  
!     CLEAR_POS(&saved_fmark.mark);	/* shutup gcc 4.0 */
      saved_fmark.fnum = 0;
  
      /*
*** ../vim-8.0.0447/src/ui.c	2017-01-31 22:07:37.907625018 +0100
--- src/ui.c	2017-03-12 17:59:15.432495170 +0100
***************
*** 442,448 ****
      /* If visual mode is only due to a redo command ("."), then ignore it */
      if (!redo_VIsual_busy && VIsual_active && (State & NORMAL))
      {
! 	if (lt(VIsual, curwin->w_cursor))
  	{
  	    start = VIsual;
  	    end = curwin->w_cursor;
--- 442,448 ----
      /* If visual mode is only due to a redo command ("."), then ignore it */
      if (!redo_VIsual_busy && VIsual_active && (State & NORMAL))
      {
! 	if (LT_POS(VIsual, curwin->w_cursor))
  	{
  	    start = VIsual;
  	    end = curwin->w_cursor;
***************
*** 456,463 ****
  	    start = curwin->w_cursor;
  	    end = VIsual;
  	}
! 	if (!equalpos(clip->start, start)
! 		|| !equalpos(clip->end, end)
  		|| clip->vmode != VIsual_mode)
  	{
  	    clip_clear_selection(clip);
--- 456,463 ----
  	    start = curwin->w_cursor;
  	    end = VIsual;
  	}
! 	if (!EQUAL_POS(clip->start, start)
! 		|| !EQUAL_POS(clip->end, end)
  		|| clip->vmode != VIsual_mode)
  	{
  	    clip_clear_selection(clip);
*** ../vim-8.0.0447/src/undo.c	2017-02-26 18:17:05.855360711 +0100
--- src/undo.c	2017-03-12 18:10:20.043639973 +0100
***************
*** 2784,2790 ****
  
      curhead->uh_entry = newlist;
      curhead->uh_flags = new_flags;
!     if ((old_flags & UH_EMPTYBUF) && bufempty())
  	curbuf->b_ml.ml_flags |= ML_EMPTY;
      if (old_flags & UH_CHANGED)
  	changed();
--- 2784,2790 ----
  
      curhead->uh_entry = newlist;
      curhead->uh_flags = new_flags;
!     if ((old_flags & UH_EMPTYBUF) && BUFEMPTY())
  	curbuf->b_ml.ml_flags |= ML_EMPTY;
      if (old_flags & UH_CHANGED)
  	changed();
***************
*** 3175,3188 ****
  	if (STRCMP(ml_get_buf(curbuf, lnum, FALSE),
  						uep->ue_array[lnum - 1]) != 0)
  	{
! 	    clearpos(&(uhp->uh_cursor));
  	    uhp->uh_cursor.lnum = lnum;
  	    return;
  	}
      if (curbuf->b_ml.ml_line_count != uep->ue_size)
      {
  	/* lines added or deleted at the end, put the cursor there */
! 	clearpos(&(uhp->uh_cursor));
  	uhp->uh_cursor.lnum = lnum;
      }
  }
--- 3175,3188 ----
  	if (STRCMP(ml_get_buf(curbuf, lnum, FALSE),
  						uep->ue_array[lnum - 1]) != 0)
  	{
! 	    CLEAR_POS(&(uhp->uh_cursor));
  	    uhp->uh_cursor.lnum = lnum;
  	    return;
  	}
      if (curbuf->b_ml.ml_line_count != uep->ue_size)
      {
  	/* lines added or deleted at the end, put the cursor there */
! 	CLEAR_POS(&(uhp->uh_cursor));
  	uhp->uh_cursor.lnum = lnum;
      }
  }
*** ../vim-8.0.0447/src/version.c	2017-03-12 17:10:14.417925081 +0100
--- src/version.c	2017-03-12 18:14:04.110008941 +0100
***************
*** 2089,2095 ****
      void
  maybe_intro_message(void)
  {
!     if (bufempty()
  	    && curbuf->b_fname == NULL
  #ifdef FEAT_WINDOWS
  	    && firstwin->w_next == NULL
--- 2091,2097 ----
      void
  maybe_intro_message(void)
  {
!     if (BUFEMPTY()
  	    && curbuf->b_fname == NULL
  #ifdef FEAT_WINDOWS
  	    && firstwin->w_next == NULL
*** ../vim-8.0.0447/src/workshop.c	2016-09-25 21:44:59.445600117 +0200
--- src/workshop.c	2017-03-12 17:59:18.780470647 +0100
***************
*** 1087,1093 ****
      *curCol = curwin->w_cursor.col;
  
      if (curbuf->b_visual.vi_mode == 'v' &&
! 	    equalpos(curwin->w_cursor, curbuf->b_visual.vi_end))
      {
  	*selStartLine = curbuf->b_visual.vi_start.lnum;
  	*selStartCol = curbuf->b_visual.vi_start.col;
--- 1087,1093 ----
      *curCol = curwin->w_cursor.col;
  
      if (curbuf->b_visual.vi_mode == 'v' &&
! 	    EQUAL_POS(curwin->w_cursor, curbuf->b_visual.vi_end))
      {
  	*selStartLine = curbuf->b_visual.vi_start.lnum;
  	*selStartCol = curbuf->b_visual.vi_start.col;
*** ../vim-8.0.0447/src/if_perl.xs	2017-01-29 22:59:08.253373379 +0100
--- src/if_perl.xs	2017-03-12 18:10:38.615504757 +0100
***************
*** 1288,1294 ****
      linenr_T	i;
      buf_T	*was_curbuf = curbuf;
  
!     if (bufempty())
  	return;
  
      if (perl_interp == NULL)
--- 1288,1294 ----
      linenr_T	i;
      buf_T	*was_curbuf = curbuf;
  
!     if (BUFEMPTY())
  	return;
  
      if (perl_interp == NULL)
*** ../vim-8.0.0447/src/version.c	2017-03-12 17:10:14.417925081 +0100
--- src/version.c	2017-03-12 18:14:04.110008941 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     448,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
100. The most exciting sporting events you noticed during summer 1996
    was Netscape vs. Microsoft.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
