To: vim_dev@googlegroups.com
Subject: Patch 8.0.0607
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0607
Problem:    When creating a bufref, then using :bwipe and :new it might get
            the same memory and bufref_valid() returns true.
Solution:   Add br_fnum to check the buffer number didn't change.
Files:      src/structs.h, src/buffer.c, src/globals.h, src/if_py_both.h,
            src/quickfix.c


*** ../vim-8.0.0606/src/structs.h	2017-04-07 19:50:08.687049344 +0200
--- src/structs.h	2017-05-30 22:21:52.526534895 +0200
***************
*** 69,79 ****
  typedef int			scid_T;		/* script ID */
  typedef struct file_buffer	buf_T;  /* forward declaration */
  
! /* Reference to a buffer that stores the value of buf_free_count.
   * bufref_valid() only needs to check "buf" when the count differs.
   */
  typedef struct {
      buf_T   *br_buf;
      int	    br_buf_free_count;
  } bufref_T;
  
--- 69,81 ----
  typedef int			scid_T;		/* script ID */
  typedef struct file_buffer	buf_T;  /* forward declaration */
  
! /*
!  * Reference to a buffer that stores the value of buf_free_count.
   * bufref_valid() only needs to check "buf" when the count differs.
   */
  typedef struct {
      buf_T   *br_buf;
+     int	    br_fnum;
      int	    br_buf_free_count;
  } bufref_T;
  
*** ../vim-8.0.0606/src/buffer.c	2017-03-16 17:23:26.811815956 +0100
--- src/buffer.c	2017-05-30 22:41:24.667069705 +0200
***************
*** 372,389 ****
  set_bufref(bufref_T *bufref, buf_T *buf)
  {
      bufref->br_buf = buf;
      bufref->br_buf_free_count = buf_free_count;
  }
  
  /*
!  * Return TRUE if "bufref->br_buf" points to a valid buffer.
   * Only goes through the buffer list if buf_free_count changed.
   */
      int
  bufref_valid(bufref_T *bufref)
  {
      return bufref->br_buf_free_count == buf_free_count
! 					   ? TRUE : buf_valid(bufref->br_buf);
  }
  
  /*
--- 372,394 ----
  set_bufref(bufref_T *bufref, buf_T *buf)
  {
      bufref->br_buf = buf;
+     bufref->br_fnum = buf->b_fnum;
      bufref->br_buf_free_count = buf_free_count;
  }
  
  /*
!  * Return TRUE if "bufref->br_buf" points to the same buffer as when
!  * set_bufref() was called and it is a valid buffer.
   * Only goes through the buffer list if buf_free_count changed.
+  * Also checks if b_fnum is still the same, a :bwipe followed by :new might get
+  * the same allocated memory, but it's a different buffer.
   */
      int
  bufref_valid(bufref_T *bufref)
  {
      return bufref->br_buf_free_count == buf_free_count
! 	? TRUE : buf_valid(bufref->br_buf)
! 				  && bufref->br_fnum == bufref->br_buf->b_fnum;
  }
  
  /*
***************
*** 2261,2274 ****
  }
  
  /*
!  * get alternate file n
!  * set linenr to lnum or altfpos.lnum if lnum == 0
!  *	also set cursor column to altfpos.col if 'startofline' is not set.
   * if (options & GETF_SETMARK) call setpcmark()
   * if (options & GETF_ALT) we are jumping to an alternate file.
   * if (options & GETF_SWITCH) respect 'switchbuf' settings when jumping
   *
!  * return FAIL for failure, OK for success
   */
      int
  buflist_getfile(
--- 2266,2279 ----
  }
  
  /*
!  * Get alternate file "n".
!  * Set linenr to "lnum" or altfpos.lnum if "lnum" == 0.
!  *	Also set cursor column to altfpos.col if 'startofline' is not set.
   * if (options & GETF_SETMARK) call setpcmark()
   * if (options & GETF_ALT) we are jumping to an alternate file.
   * if (options & GETF_SWITCH) respect 'switchbuf' settings when jumping
   *
!  * Return FAIL for failure, OK for success.
   */
      int
  buflist_getfile(
***************
*** 2999,3005 ****
  
  #if defined(FEAT_LISTCMDS) || defined(PROTO)
  /*
!  * List all know file names (for :files and :buffers command).
   */
      void
  buflist_list(exarg_T *eap)
--- 3004,3010 ----
  
  #if defined(FEAT_LISTCMDS) || defined(PROTO)
  /*
!  * List all known file names (for :files and :buffers command).
   */
      void
  buflist_list(exarg_T *eap)
*** ../vim-8.0.0606/src/globals.h	2017-04-30 19:39:32.650857838 +0200
--- src/globals.h	2017-05-30 22:32:12.950575506 +0200
***************
*** 385,391 ****
  
  /* When deleting the current buffer, another one must be loaded.  If we know
   * which one is preferred, au_new_curbuf is set to it */
! EXTERN bufref_T	au_new_curbuf INIT(= {NULL COMMA 0});
  
  /* When deleting a buffer/window and autocmd_busy is TRUE, do not free the
   * buffer/window. but link it in the list starting with
--- 385,391 ----
  
  /* When deleting the current buffer, another one must be loaded.  If we know
   * which one is preferred, au_new_curbuf is set to it */
! EXTERN bufref_T	au_new_curbuf INIT(= {NULL COMMA 0 COMMA 0});
  
  /* When deleting a buffer/window and autocmd_busy is TRUE, do not free the
   * buffer/window. but link it in the list starting with
*** ../vim-8.0.0606/src/if_py_both.h	2017-02-23 19:00:28.512904202 +0100
--- src/if_py_both.h	2017-05-30 22:42:06.486804315 +0200
***************
*** 4311,4317 ****
      static int
  SetBufferLine(buf_T *buf, PyInt n, PyObject *line, PyInt *len_change)
  {
!     bufref_T	save_curbuf = {NULL, 0};
      win_T	*save_curwin = NULL;
      tabpage_T	*save_curtab = NULL;
  
--- 4311,4317 ----
      static int
  SetBufferLine(buf_T *buf, PyInt n, PyObject *line, PyInt *len_change)
  {
!     bufref_T	save_curbuf = {NULL, 0, 0};
      win_T	*save_curwin = NULL;
      tabpage_T	*save_curtab = NULL;
  
***************
*** 4415,4421 ****
  	PyObject *list,
  	PyInt *len_change)
  {
!     bufref_T	save_curbuf = {NULL, 0};
      win_T	*save_curwin = NULL;
      tabpage_T	*save_curtab = NULL;
  
--- 4415,4421 ----
  	PyObject *list,
  	PyInt *len_change)
  {
!     bufref_T	save_curbuf = {NULL, 0, 0};
      win_T	*save_curwin = NULL;
      tabpage_T	*save_curtab = NULL;
  
***************
*** 4616,4622 ****
      static int
  InsertBufferLines(buf_T *buf, PyInt n, PyObject *lines, PyInt *len_change)
  {
!     bufref_T	save_curbuf = {NULL, 0};
      win_T	*save_curwin = NULL;
      tabpage_T	*save_curtab = NULL;
  
--- 4616,4622 ----
      static int
  InsertBufferLines(buf_T *buf, PyInt n, PyObject *lines, PyInt *len_change)
  {
!     bufref_T	save_curbuf = {NULL, 0, 0};
      win_T	*save_curwin = NULL;
      tabpage_T	*save_curtab = NULL;
  
*** ../vim-8.0.0606/src/quickfix.c	2017-05-28 08:16:18.783611080 +0200
--- src/quickfix.c	2017-06-04 14:53:47.474177563 +0200
***************
*** 161,168 ****
   * Looking up a buffer can be slow if there are many.  Remember the last one
   * to make this a lot faster if there are multiple matches in the same file.
   */
! static char_u *qf_last_bufname = NULL;
! static bufref_T  qf_last_bufref = {NULL, 0};
  
  /*
   * Read the errorfile "efile" into memory, line by line, building the error
--- 161,168 ----
   * Looking up a buffer can be slow if there are many.  Remember the last one
   * to make this a lot faster if there are multiple matches in the same file.
   */
! static char_u   *qf_last_bufname = NULL;
! static bufref_T  qf_last_bufref = {NULL, 0, 0};
  
  /*
   * Read the errorfile "efile" into memory, line by line, building the error
***************
*** 2732,2738 ****
  }
  
  /*
!  * Free error list "idx".
   */
      static void
  qf_free(qf_info_T *qi, int idx)
--- 2732,2738 ----
  }
  
  /*
!  * Free all the entries in the error list "idx".
   */
      static void
  qf_free(qf_info_T *qi, int idx)
*** ../vim-8.0.0606/src/version.c	2017-05-28 08:16:18.783611080 +0200
--- src/version.c	2017-06-04 14:45:33.801558124 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     607,
  /**/

-- 
I think that you'll agree that engineers are very effective in their social
interactions.  It's the "normal" people who are nuts.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
