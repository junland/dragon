To: vim_dev@googlegroups.com
Subject: Patch 8.0.1112
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1112
Problem:    Can't get size or current index from quickfix list.
Solution:   Add "idx" and "size" options. (Yegappan Lakshmanan)
Files:      runtime/doc/eval.txt, src/quickfix.c,
            src/testdir/test_quickfix.vim


*** ../vim-8.0.1111/runtime/doc/eval.txt	2017-09-11 19:30:58.585288878 +0200
--- runtime/doc/eval.txt	2017-09-15 22:39:14.326660616 +0200
***************
*** 4642,4647 ****
--- 4642,4648 ----
  			id	get information for the quickfix list with
  				|quickfix-ID|; zero means the id for the
  				current list or the list specifed by "nr"
+ 			idx	index of the current entry in the list
  			items	quickfix list entries
  			lines	use 'errorformat' to extract items from a list
  				of lines and return the resulting entries.
***************
*** 4650,4655 ****
--- 4651,4657 ----
  			nr	get information for this quickfix list; zero
  				means the current quickfix list and "$" means
  				the last quickfix list
+ 			size	number of entries in the quickfix list
  			title	get the list title
  			winid	get the |window-ID| (if opened)
  			all	all of the above quickfix properties
***************
*** 4669,4676 ****
--- 4671,4680 ----
  		The returned dictionary contains the following entries:
  			context	context information stored with |setqflist()|
  			id	quickfix list ID |quickfix-ID|
+ 			idx	index of the current entry in the list
  			items	quickfix list entries
  			nr	quickfix list number
+ 			size	number of entries in the quickfix list
  			title	quickfix list title text
  			winid	quickfix |window-ID| (if opened)
  
*** ../vim-8.0.1111/src/quickfix.c	2017-09-14 13:57:33.280856020 +0200
--- src/quickfix.c	2017-09-15 22:39:14.326660616 +0200
***************
*** 2212,2219 ****
      old_qf_ptr = qf_ptr;
      qf_index = qi->qf_lists[qi->qf_curlist].qf_index;
      old_qf_index = qf_index;
!     if (dir == FORWARD || dir == FORWARD_FILE ||
! 	dir == BACKWARD || dir == BACKWARD_FILE)    /* next/prev valid entry */
      {
  	qf_ptr = get_nth_valid_entry(qi, errornr, qf_ptr, &qf_index, dir);
  	if (qf_ptr == NULL)
--- 2212,2218 ----
      old_qf_ptr = qf_ptr;
      qf_index = qi->qf_lists[qi->qf_curlist].qf_index;
      old_qf_index = qf_index;
!     if (dir != 0)    /* next/prev valid entry */
      {
  	qf_ptr = get_nth_valid_entry(qi, errornr, qf_ptr, &qf_index, dir);
  	if (qf_ptr == NULL)
***************
*** 4726,4731 ****
--- 4725,4732 ----
      QF_GETLIST_WINID	= 0x8,
      QF_GETLIST_CONTEXT	= 0x10,
      QF_GETLIST_ID	= 0x20,
+     QF_GETLIST_IDX	= 0x40,
+     QF_GETLIST_SIZE	= 0x80,
      QF_GETLIST_ALL	= 0xFF
  };
  
***************
*** 4882,4887 ****
--- 4883,4894 ----
      if (dict_find(what, (char_u *)"items", -1) != NULL)
  	flags |= QF_GETLIST_ITEMS;
  
+     if (dict_find(what, (char_u *)"idx", -1) != NULL)
+ 	flags |= QF_GETLIST_IDX;
+ 
+     if (dict_find(what, (char_u *)"size", -1) != NULL)
+ 	flags |= QF_GETLIST_SIZE;
+ 
      if (flags & QF_GETLIST_TITLE)
      {
  	char_u	*t;
***************
*** 4934,4939 ****
--- 4941,4959 ----
  	status = dict_add_nr_str(retdict, "id", qi->qf_lists[qf_idx].qf_id,
  									 NULL);
  
+     if ((status == OK) && (flags & QF_GETLIST_IDX))
+     {
+ 	int idx = qi->qf_lists[qf_idx].qf_index;
+ 	if (qi->qf_lists[qf_idx].qf_count == 0)
+ 	    /* For empty lists, qf_index is set to 1 */
+ 	    idx = 0;
+ 	status = dict_add_nr_str(retdict, "idx", idx, NULL);
+     }
+ 
+     if ((status == OK) && (flags & QF_GETLIST_SIZE))
+ 	status = dict_add_nr_str(retdict, "size",
+ 					qi->qf_lists[qf_idx].qf_count, NULL);
+ 
      return status;
  }
  
*** ../vim-8.0.1111/src/testdir/test_quickfix.vim	2017-09-11 19:30:58.589288855 +0200
--- src/testdir/test_quickfix.vim	2017-09-15 22:39:14.330660592 +0200
***************
*** 430,435 ****
--- 430,448 ----
  
    call delete('Xqftestfile1')
    call delete('Xqftestfile2')
+ 
+   " Should be able to use next/prev with invalid entries
+   Xexpr ""
+   call assert_equal(0, g:Xgetlist({'idx' : 0}).idx)
+   call assert_equal(0, g:Xgetlist({'size' : 0}).size)
+   Xaddexpr ['foo', 'bar', 'baz', 'quux', 'shmoo']
+   call assert_equal(5, g:Xgetlist({'size' : 0}).size)
+   Xlast
+   call assert_equal(5, g:Xgetlist({'idx' : 0}).idx)
+   Xfirst
+   call assert_equal(1, g:Xgetlist({'idx' : 0}).idx)
+   2Xnext
+   call assert_equal(3, g:Xgetlist({'idx' : 0}).idx)
  endfunc
  
  func Test_browse()
*** ../vim-8.0.1111/src/version.c	2017-09-15 12:40:49.001581807 +0200
--- src/version.c	2017-09-15 22:40:39.222161610 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     1112,
  /**/


-- 
hundred-and-one symptoms of being an internet addict:
127. You bring your laptop and cellular phone to church.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
