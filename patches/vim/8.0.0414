To: vim_dev@googlegroups.com
Subject: Patch 8.0.0414
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0414
Problem:    Balloon eval is not tested.
Solution:   Add a few balloon tests. (Kazunobu Kuriyama)
Files:      src/testdir/test_gui.vim


*** ../vim-8.0.0413/src/testdir/test_gui.vim	2017-03-04 13:32:06.967801328 +0100
--- src/testdir/test_gui.vim	2017-03-05 13:25:24.010083703 +0100
***************
*** 22,27 ****
--- 22,35 ----
    call assert_equal(1, has('gui_running'))
  endfunc
  
+ " As for non-GUI, a balloon_show() test was already added with patch 8.0.0401
+ func Test_balloon_show()
+   if has('balloon_eval')
+     " This won't do anything but must not crash either.
+     call balloon_show('hi!')
+   endif
+ endfunc
+ 
  func Test_getfontname_with_arg()
    let skipped = ''
  
***************
*** 117,122 ****
--- 125,253 ----
    endif
  endfunc
  
+ func Test_set_balloondelay()
+   if !exists('+balloondelay')
+     return
+   endif
+ 
+   let balloondelay_saved = &balloondelay
+ 
+   " Check if the default value is identical to that described in the manual.
+   set balloondelay&
+   call assert_equal(600, &balloondelay)
+ 
+   " Edge cases
+ 
+   " XXX This fact should be hidden so that people won't be tempted to write
+   " plugin/TimeMachine.vim.  TODO Add reasonable range checks to the source
+   " code.
+   set balloondelay=-1
+   call assert_equal(-1, &balloondelay)
+ 
+   " Though it's possible to interpret the zero delay to be 'as soon as
+   " possible' or even 'indefinite', its actual meaning depends on the GUI
+   " toolkit in use after all.
+   set balloondelay=0
+   call assert_equal(0, &balloondelay)
+ 
+   set balloondelay=1
+   call assert_equal(1, &balloondelay)
+ 
+   " Since p_bdelay is of type long currently, the upper bound can be
+   " impractically huge and machine-dependent.  Practically, it's sufficient
+   " to check if balloondelay works with 0xffffffff (32 bits) for now.
+   set balloondelay=4294967295
+   call assert_equal(4294967295, &balloondelay)
+ 
+   let &balloondelay = balloondelay_saved
+ endfunc
+ 
+ func Test_set_ballooneval()
+   if !exists('+ballooneval')
+     return
+   endif
+ 
+   let ballooneval_saved = &ballooneval
+ 
+   set ballooneval&
+   call assert_equal(0, &ballooneval)
+ 
+   set ballooneval
+   call assert_notequal(0, &ballooneval)
+ 
+   set noballooneval
+   call assert_equal(0, &ballooneval)
+ 
+   let &ballooneval = ballooneval_saved
+ endfunc
+ 
+ func Test_set_balloonexpr()
+   if !exists('+balloonexpr')
+     return
+   endif
+ 
+   let balloonexpr_saved = &balloonexpr
+ 
+   " Default value
+   set balloonexpr&
+   call assert_equal('', &balloonexpr)
+ 
+   " User-defined function
+   new
+   func MyBalloonExpr()
+       return 'Cursor is at line ' . v:beval_lnum .
+ 	      \', column ' . v:beval_col .
+ 	      \ ' of file ' .  bufname(v:beval_bufnr) .
+ 	      \ ' on word "' . v:beval_text . '"' .
+ 	      \ ' in window ' . v:beval_winid . ' (#' . v:beval_winnr . ')'
+   endfunc
+   setl balloonexpr=MyBalloonExpr()
+   setl ballooneval
+   call assert_equal('MyBalloonExpr()', &balloonexpr)
+   " TODO Read non-empty text, place the pointer at a character of a word,
+   " and check if the content of the balloon is the smae as what is expected.
+   " Also, check if textlock works as expected.
+   setl balloonexpr&
+   call assert_equal('', &balloonexpr)
+   delfunc MyBalloonExpr
+   bwipe!
+ 
+   " Multiline support
+   if has('balloon_multiline')
+     " Multiline balloon using NL
+     new
+     func MyBalloonFuncForMultilineUsingNL()
+       return "Multiline\nSuppported\nBalloon\nusing NL"
+     endfunc
+     setl balloonexpr=MyBalloonFuncForMultilineUsingNL()
+     setl ballooneval
+     call assert_equal('MyBalloonFuncForMultilineUsingNL()', &balloonexpr)
+     " TODO Read non-empty text, place the pointer at a character of a word,
+     " and check if the content of the balloon is the smae as what is
+     " expected.  Also, check if textlock works as expected.
+     setl balloonexpr&
+     delfunc MyBalloonFuncForMultilineUsingNL
+     bwipe!
+ 
+     " Multiline balloon using List
+     new
+     func MyBalloonFuncForMultilineUsingList()
+       return [ 'Multiline', 'Suppported', 'Balloon', 'using List' ]
+     endfunc
+     setl balloonexpr=MyBalloonFuncForMultilineUsingList()
+     setl ballooneval
+     call assert_equal('MyBalloonFuncForMultilineUsingList()', &balloonexpr)
+     " TODO Read non-empty text, place the pointer at a character of a word,
+     " and check if the content of the balloon is the smae as what is
+     " expected.  Also, check if textlock works as expected.
+     setl balloonexpr&
+     delfunc MyBalloonFuncForMultilineUsingList
+     bwipe!
+   endif
+ 
+   let &balloonexpr = balloonexpr_saved
+ endfunc
+ 
  func Test_set_guifont()
    let skipped = ''
  
*** ../vim-8.0.0413/src/version.c	2017-03-04 21:40:56.393176702 +0100
--- src/version.c	2017-03-05 13:26:31.101580474 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     414,
  /**/

-- 
Never go to the toilet in a paperless office.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
