To: vim_dev@googlegroups.com
Subject: Patch 8.0.0484
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0484
Problem:    Using :lhelpgrep with an argument that should fail does not
            produce an error if the previous :helpgrep worked.
Solution:   Use another way to detect that autocommands made the quickfix info
            invalid. (Yegappan Lakshmanan)
Files:      src/quickfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0483/src/quickfix.c	2017-03-16 17:23:26.831815811 +0100
--- src/quickfix.c	2017-03-19 14:16:01.003265351 +0100
***************
*** 5077,5082 ****
--- 5077,5083 ----
      char_u	*lang;
  #endif
      qf_info_T	*qi = &ql_info;
+     qf_info_T	*save_qi;
      int		new_qi = FALSE;
      win_T	*wp;
  #ifdef FEAT_AUTOCMD
***************
*** 5130,5135 ****
--- 5131,5139 ----
  	}
      }
  
+     /* Autocommands may change the list. Save it for later comparison */
+     save_qi = qi;
+ 
      regmatch.regprog = vim_regcomp(eap->arg, RE_MAGIC + RE_STRING);
      regmatch.rm_ic = FALSE;
      if (regmatch.regprog != NULL)
***************
*** 5262,5268 ****
      {
  	apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,
  					       curbuf->b_fname, TRUE, curbuf);
! 	if (!new_qi && qi != &ql_info && qf_find_buf(qi) == NULL)
  	    /* autocommands made "qi" invalid */
  	    return;
      }
--- 5266,5272 ----
      {
  	apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,
  					       curbuf->b_fname, TRUE, curbuf);
! 	if (!new_qi && qi != save_qi && qf_find_buf(qi) == NULL)
  	    /* autocommands made "qi" invalid */
  	    return;
      }
*** ../vim-8.0.0483/src/testdir/test_quickfix.vim	2017-03-04 13:47:08.244946882 +0100
--- src/testdir/test_quickfix.vim	2017-03-19 14:15:38.795424912 +0100
***************
*** 31,37 ****
      command! -nargs=* -bang Xnfile <mods>cnfile<bang> <args>
      command! -nargs=* -bang Xpfile <mods>cpfile<bang> <args>
      command! -nargs=* Xexpr <mods>cexpr <args>
!     command! -nargs=* Xvimgrep <mods>vimgrep <args>
      command! -nargs=* Xgrep <mods> grep <args>
      command! -nargs=* Xgrepadd <mods> grepadd <args>
      command! -nargs=* Xhelpgrep helpgrep <args>
--- 31,38 ----
      command! -nargs=* -bang Xnfile <mods>cnfile<bang> <args>
      command! -nargs=* -bang Xpfile <mods>cpfile<bang> <args>
      command! -nargs=* Xexpr <mods>cexpr <args>
!     command! -range -nargs=* Xvimgrep <mods><count>vimgrep <args>
!     command! -nargs=* Xvimgrepadd <mods>vimgrepadd <args>
      command! -nargs=* Xgrep <mods> grep <args>
      command! -nargs=* Xgrepadd <mods> grepadd <args>
      command! -nargs=* Xhelpgrep helpgrep <args>
***************
*** 61,67 ****
      command! -nargs=* -bang Xnfile <mods>lnfile<bang> <args>
      command! -nargs=* -bang Xpfile <mods>lpfile<bang> <args>
      command! -nargs=* Xexpr <mods>lexpr <args>
!     command! -nargs=* Xvimgrep <mods>lvimgrep <args>
      command! -nargs=* Xgrep <mods> lgrep <args>
      command! -nargs=* Xgrepadd <mods> lgrepadd <args>
      command! -nargs=* Xhelpgrep lhelpgrep <args>
--- 62,69 ----
      command! -nargs=* -bang Xnfile <mods>lnfile<bang> <args>
      command! -nargs=* -bang Xpfile <mods>lpfile<bang> <args>
      command! -nargs=* Xexpr <mods>lexpr <args>
!     command! -range -nargs=* Xvimgrep <mods><count>lvimgrep <args>
!     command! -nargs=* Xvimgrepadd <mods>lvimgrepadd <args>
      command! -nargs=* Xgrep <mods> lgrep <args>
      command! -nargs=* Xgrepadd <mods> lgrepadd <args>
      command! -nargs=* Xhelpgrep lhelpgrep <args>
***************
*** 85,141 ****
  		  \ 'non-error 3', 'Xtestfile3:3:1:Line3']
  
    " List only valid entries
!   redir => result
!   Xlist
!   redir END
!   let l = split(result, "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 4 Xtestfile2:2 col 2: Line2',
  		   \ ' 6 Xtestfile3:3 col 1: Line3'], l)
  
    " List all the entries
!   redir => result
!   Xlist!
!   redir END
!   let l = split(result, "\n")
    call assert_equal([' 1: non-error 1', ' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2',
  		   \ ' 5: non-error 3', ' 6 Xtestfile3:3 col 1: Line3'], l)
  
    " List a range of errors
!   redir => result
!   Xlist 3,6
!   redir END
!   let l = split(result, "\n")
    call assert_equal([' 4 Xtestfile2:2 col 2: Line2',
  		   \ ' 6 Xtestfile3:3 col 1: Line3'], l)
  
!   redir => result
!   Xlist! 3,4
!   redir END
!   let l = split(result, "\n")
    call assert_equal([' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
  
!   redir => result
!   Xlist -6,-4
!   redir END
!   let l = split(result, "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1'], l)
  
!   redir => result
!   Xlist! -5,-3
!   redir END
!   let l = split(result, "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
  
    " Test for '+'
!   redir => result
!   Xlist! +2
!   redir END
!   let l = split(result, "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
  endfunc
  
  func Test_clist()
--- 87,138 ----
  		  \ 'non-error 3', 'Xtestfile3:3:1:Line3']
  
    " List only valid entries
!   let l = split(execute('Xlist', ''), "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 4 Xtestfile2:2 col 2: Line2',
  		   \ ' 6 Xtestfile3:3 col 1: Line3'], l)
  
    " List all the entries
!   let l = split(execute('Xlist!', ''), "\n")
    call assert_equal([' 1: non-error 1', ' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2',
  		   \ ' 5: non-error 3', ' 6 Xtestfile3:3 col 1: Line3'], l)
  
    " List a range of errors
!   let l = split(execute('Xlist 3,6', ''), "\n")
    call assert_equal([' 4 Xtestfile2:2 col 2: Line2',
  		   \ ' 6 Xtestfile3:3 col 1: Line3'], l)
  
!   let l = split(execute('Xlist! 3,4', ''), "\n")
    call assert_equal([' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
  
!   let l = split(execute('Xlist -6,-4', ''), "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1'], l)
  
!   let l = split(execute('Xlist! -5,-3', ''), "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
  
    " Test for '+'
!   let l = split(execute('Xlist! +2', ''), "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
+ 
+   " Different types of errors
+   call g:Xsetlist([{'lnum':10,'col':5,'type':'W', 'text':'Warning','nr':11},
+ 	      \ {'lnum':20,'col':10,'type':'e','text':'Error','nr':22},
+ 	      \ {'lnum':30,'col':15,'type':'i','text':'Info','nr':33},
+ 	      \ {'lnum':40,'col':20,'type':'x', 'text':'Other','nr':44},
+ 	      \ {'lnum':50,'col':25,'type':"\<C-A>",'text':'one','nr':55}])
+   let l = split(execute('Xlist', ""), "\n")
+   call assert_equal([' 1:10 col 5 warning  11: Warning',
+ 	      \ ' 2:20 col 10 error  22: Error',
+ 	      \ ' 3:30 col 15 info  33: Info',
+ 	      \ ' 4:40 col 20 x  44: Other',
+ 	      \ ' 5:50 col 25  55: one'], l)
+ 
+   " Error cases
+   call assert_fails('Xlist abc', 'E488:')
  endfunc
  
  func Test_clist()
***************
*** 324,329 ****
--- 321,343 ----
  	\ l[3].lnum == 750 && l[3].col == 25 && l[3].text ==# 'Line 750')
    enew!
  
+   " Check for invalid buffer
+   call assert_fails('Xbuffer 199', 'E474:')
+ 
+   " Check for unloaded buffer
+   edit Xtestfile1
+   let bnr = bufnr('%')
+   enew!
+   call assert_fails('Xbuffer ' . bnr, 'E681:')
+ 
+   " Check for invalid range
+   " Using Xbuffer will not run the range check in the cbuffer/lbuffer
+   " commands. So directly call the commands.
+   if (a:cchar == 'c')
+       call assert_fails('900,999cbuffer', 'E16:')
+   else
+       call assert_fails('900,999lbuffer', 'E16:')
+   endif
  endfunc
  
  func Test_cbuffer()
***************
*** 372,377 ****
--- 386,394 ----
    call assert_equal('Xqftestfile1', bufname('%'))
    call assert_equal(5, line('.'))
  
+   Xexpr ""
+   call assert_fails('Xnext', 'E42:')
+ 
    call delete('Xqftestfile1')
    call delete('Xqftestfile2')
  endfunc
***************
*** 411,416 ****
--- 428,436 ----
    call assert_true(w:quickfix_title =~ title_text, w:quickfix_title)
    " This wipes out the buffer, make sure that doesn't cause trouble.
    Xclose
+ 
+   " Search for non existing help string
+   call assert_fails('Xhelpgrep a1b2c3', 'E480:')
  endfunc
  
  func Test_helpgrep()
***************
*** 604,610 ****
      wincmd n | only
  
      augroup! testgroup
!   endfunc
  
  func Test_locationlist_curwin_was_closed()
      augroup testgroup
--- 624,630 ----
      wincmd n | only
  
      augroup! testgroup
! endfunc
  
  func Test_locationlist_curwin_was_closed()
      augroup testgroup
***************
*** 623,629 ****
      call assert_fails('lrewind', 'E924:')
  
      augroup! testgroup
!   endfunc
  
  func Test_locationlist_cross_tab_jump()
    call writefile(['loclistfoo'], 'loclistfoo')
--- 643,649 ----
      call assert_fails('lrewind', 'E924:')
  
      augroup! testgroup
! endfunc
  
  func Test_locationlist_cross_tab_jump()
    call writefile(['loclistfoo'], 'loclistfoo')
***************
*** 760,766 ****
      call delete('Xerrorfile1')
      call delete('Xerrorfile2')
      call delete('Xtestfile')
!   endfunc
  
  " Test for quickfix directory stack support
  func s:dir_stack_tests(cchar)
--- 780,786 ----
      call delete('Xerrorfile1')
      call delete('Xerrorfile2')
      call delete('Xtestfile')
! endfunc
  
  " Test for quickfix directory stack support
  func s:dir_stack_tests(cchar)
***************
*** 919,938 ****
    call assert_equal(l[0].pattern, '^\VLine search text\$')
    call assert_equal(l[0].lnum, 0)
  
    " Test for %P, %Q and %t format specifiers
    let lines=["[Xtestfile1]",
  	      \ "(1,17)  error: ';' missing",
  	      \ "(21,2)  warning: variable 'z' not defined",
  	      \ "(67,3)  error: end of file found before string ended",
  	      \ "",
  	      \ "[Xtestfile2]",
  	      \ "",
  	      \ "[Xtestfile3]",
  	      \ "NEW compiler v1.1",
  	      \ "(2,2)   warning: variable 'x' not defined",
! 	      \ "(67,3)  warning: 's' already defined"
  	      \]
!   set efm=%+P[%f],(%l\\,%c)%*[\ ]%t%*[^:]:\ %m,%-Q
    " To exercise the push/pop file functionality in quickfix, the test files
    " need to be created.
    call writefile(['Line1'], 'Xtestfile1')
--- 939,964 ----
    call assert_equal(l[0].pattern, '^\VLine search text\$')
    call assert_equal(l[0].lnum, 0)
  
+   let l = split(execute('clist', ''), "\n")
+   call assert_equal([' 1 Xtestfile:^\VLine search text\$:  '], l)
+ 
    " Test for %P, %Q and %t format specifiers
    let lines=["[Xtestfile1]",
  	      \ "(1,17)  error: ';' missing",
  	      \ "(21,2)  warning: variable 'z' not defined",
  	      \ "(67,3)  error: end of file found before string ended",
+ 	      \ "--",
  	      \ "",
  	      \ "[Xtestfile2]",
+ 	      \ "--",
  	      \ "",
  	      \ "[Xtestfile3]",
  	      \ "NEW compiler v1.1",
  	      \ "(2,2)   warning: variable 'x' not defined",
! 	      \ "(67,3)  warning: 's' already defined",
! 	      \ "--"
  	      \]
!   set efm=%+P[%f]%r,(%l\\,%c)%*[\ ]%t%*[^:]:\ %m,%+Q--%r
    " To exercise the push/pop file functionality in quickfix, the test files
    " need to be created.
    call writefile(['Line1'], 'Xtestfile1')
***************
*** 943,949 ****
        caddexpr l
    endfor
    let l = getqflist()
!   call assert_equal(9, len(l))
    call assert_equal(21, l[2].lnum)
    call assert_equal(2, l[2].col)
    call assert_equal('w', l[2].type)
--- 969,975 ----
        caddexpr l
    endfor
    let l = getqflist()
!   call assert_equal(12, len(l))
    call assert_equal(21, l[2].lnum)
    call assert_equal(2, l[2].col)
    call assert_equal('w', l[2].type)
***************
*** 1098,1103 ****
--- 1124,1136 ----
    call g:Xsetlist([])
    let l = g:Xgetlist()
    call assert_equal(0, len(l))
+ 
+   " Error cases:
+   " Refer to a non-existing buffer and pass a non-dictionary type
+   call assert_fails("call g:Xsetlist([{'bufnr':998, 'lnum':4}," .
+ 	      \ " {'bufnr':999, 'lnum':5}])", 'E92:')
+   call g:Xsetlist([[1, 2,3]])
+   call assert_equal(0, len(g:Xgetlist()))
  endfunc
  
  func Test_setqflist()
***************
*** 1116,1122 ****
    call s:setup_commands(a:cchar)
  
    " create three quickfix lists
!   Xvimgrep Test_ test_quickfix.vim
    let testlen = len(g:Xgetlist())
    call assert_true(testlen > 0)
    Xvimgrep empty test_quickfix.vim
--- 1149,1156 ----
    call s:setup_commands(a:cchar)
  
    " create three quickfix lists
!   let @/ = 'Test_'
!   Xvimgrep // test_quickfix.vim
    let testlen = len(g:Xgetlist())
    call assert_true(testlen > 0)
    Xvimgrep empty test_quickfix.vim
***************
*** 1609,1614 ****
--- 1643,1664 ----
      call g:Xsetlist([], ' ', {'title' : 'N3'})
      call assert_equal('N2', g:Xgetlist({'nr':2, 'title':1}).title)
  
+     " Changing the title of an earlier quickfix list
+     call g:Xsetlist([], ' ', {'title' : 'NewTitle', 'nr' : 2})
+     call assert_equal('NewTitle', g:Xgetlist({'nr':2, 'title':1}).title)
+ 
+     " Changing the title of an invalid quickfix list
+     call assert_equal(-1, g:Xsetlist([], ' ',
+ 		\ {'title' : 'SomeTitle', 'nr' : 99}))
+     call assert_equal(-1, g:Xsetlist([], ' ',
+ 		\ {'title' : 'SomeTitle', 'nr' : 'abc'}))
+ 
+     if a:cchar == 'c'
+ 	copen
+ 	call assert_equal({'winid':win_getid()}, getqflist({'winid':1}))
+ 	cclose
+     endif
+ 
      " Invalid arguments
      call assert_fails('call g:Xgetlist([])', 'E715')
      call assert_fails('call g:Xsetlist([], "a", [])', 'E715')
***************
*** 1616,1631 ****
      call assert_equal(-1, s)
  
      call assert_equal({}, g:Xgetlist({'abc':1}))
  
      if a:cchar == 'l'
  	call assert_equal({}, getloclist(99, {'title': 1}))
      endif
!   endfunc
  
  func Test_qf_property()
      call Xproperty_tests('c')
      call Xproperty_tests('l')
!   endfunc
  
  " Tests for the QuickFixCmdPre/QuickFixCmdPost autocommands
  func QfAutoCmdHandler(loc, cmd)
--- 1666,1683 ----
      call assert_equal(-1, s)
  
      call assert_equal({}, g:Xgetlist({'abc':1}))
+     call assert_equal({}, g:Xgetlist({'nr':99, 'title':1}))
+     call assert_equal({}, g:Xgetlist({'nr':[], 'title':1}))
  
      if a:cchar == 'l'
  	call assert_equal({}, getloclist(99, {'title': 1}))
      endif
! endfunc
  
  func Test_qf_property()
      call Xproperty_tests('c')
      call Xproperty_tests('l')
! endfunc
  
  " Tests for the QuickFixCmdPre/QuickFixCmdPost autocommands
  func QfAutoCmdHandler(loc, cmd)
***************
*** 1774,1776 ****
--- 1826,1880 ----
    enew | only
    set efm&vim
  endfunc
+ 
+ func XvimgrepTests(cchar)
+   call s:setup_commands(a:cchar)
+ 
+   call writefile(['Editor:VIM vim',
+ 	      \ 'Editor:Emacs EmAcS',
+ 	      \ 'Editor:Notepad NOTEPAD'], 'Xtestfile1')
+   call writefile(['Linux', 'MacOS', 'MS-Windows'], 'Xtestfile2')
+ 
+   " Error cases
+   call assert_fails('Xvimgrep /abc *', 'E682:')
+ 
+   let @/=''
+   call assert_fails('Xvimgrep // *', 'E35:')
+ 
+   call assert_fails('Xvimgrep abc', 'E683:')
+   call assert_fails('Xvimgrep a1b2c3 Xtestfile1', 'E480:')
+   call assert_fails('Xvimgrep pat Xa1b2c3', 'E480:')
+ 
+   Xexpr ""
+   Xvimgrepadd Notepad Xtestfile1
+   Xvimgrepadd MacOS Xtestfile2
+   let l = g:Xgetlist()
+   call assert_equal(2, len(l))
+   call assert_equal('Editor:Notepad NOTEPAD', l[0].text)
+ 
+   Xvimgrep #\cvim#g Xtestfile?
+   let l = g:Xgetlist()
+   call assert_equal(2, len(l))
+   call assert_equal(8, l[0].col)
+   call assert_equal(12, l[1].col)
+ 
+   1Xvimgrep ?Editor? Xtestfile*
+   let l = g:Xgetlist()
+   call assert_equal(1, len(l))
+   call assert_equal('Editor:VIM vim', l[0].text)
+ 
+   edit +3 Xtestfile2
+   Xvimgrep +\cemacs+j Xtestfile1
+   let l = g:Xgetlist()
+   call assert_equal('Xtestfile2', bufname(''))
+   call assert_equal('Editor:Emacs EmAcS', l[0].text)
+ 
+   call delete('Xtestfile1')
+   call delete('Xtestfile2')
+ endfunc
+ 
+ " Tests for the :vimgrep command
+ func Test_vimgrep()
+   call XvimgrepTests('c')
+   call XvimgrepTests('l')
+ endfunc
*** ../vim-8.0.0483/src/version.c	2017-03-18 23:11:00.287000094 +0100
--- src/version.c	2017-03-19 14:18:27.450213230 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     484,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
162. You go outside and look for a brightness knob to turn down the sun.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
