To: vim_dev@googlegroups.com
Subject: Patch 8.0.1211
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1211
Problem:    Cannot reorder tab pages with drag & drop.
Solution:   Support drag & drop for GTK and MS-Windows. (Ken Takata, Masamichi
            Abe)
Files:      src/gui_gtk_x11.c, src/gui_w32.c


*** ../vim-8.0.1210/src/gui_gtk_x11.c	2017-09-09 23:00:49.381581228 +0200
--- src/gui_gtk_x11.c	2017-10-22 15:27:26.709921034 +0200
***************
*** 3567,3574 ****
  	gpointer	data UNUSED)
  {
      if (!ignore_tabline_evt)
-     {
  	send_tabline_event(idx + 1);
      }
  }
  
--- 3567,3595 ----
  	gpointer	data UNUSED)
  {
      if (!ignore_tabline_evt)
  	send_tabline_event(idx + 1);
+ }
+ 
+ /*
+  * Handle reordering the tabs (using D&D).
+  */
+     static void
+ on_tab_reordered(
+ 	GtkNotebook	*notebook UNUSED,
+ # if GTK_CHECK_VERSION(3,0,0)
+ 	gpointer	*page UNUSED,
+ # else
+ 	GtkNotebookPage *page UNUSED,
+ # endif
+ 	gint		idx,
+ 	gpointer	data UNUSED)
+ {
+     if (!ignore_tabline_evt)
+     {
+ 	if ((tabpage_index(curtab) - 1) < idx)
+ 	    tabpage_move(idx + 1);
+ 	else
+ 	    tabpage_move(idx);
      }
  }
  
***************
*** 3658,3663 ****
--- 3679,3687 ----
  		    page,
  		    event_box,
  		    nr++);
+ 	    gtk_notebook_set_tab_reorderable(GTK_NOTEBOOK(gui.tabline),
+ 		    page,
+ 		    TRUE);
  	}
  
  	event_box = gtk_notebook_get_tab_label(GTK_NOTEBOOK(gui.tabline), page);
***************
*** 4093,4106 ****
--- 4117,4135 ----
  # endif
  	gtk_container_add(GTK_CONTAINER(event_box), label);
  	gtk_notebook_set_tab_label(GTK_NOTEBOOK(gui.tabline), page, event_box);
+ 	gtk_notebook_set_tab_reorderable(GTK_NOTEBOOK(gui.tabline), page, TRUE);
      }
  
  # if GTK_CHECK_VERSION(3,0,0)
      g_signal_connect(G_OBJECT(gui.tabline), "switch-page",
  		     G_CALLBACK(on_select_tab), NULL);
+     g_signal_connect(G_OBJECT(gui.tabline), "page-reordered",
+ 		     G_CALLBACK(on_tab_reordered), NULL);
  # else
      gtk_signal_connect(GTK_OBJECT(gui.tabline), "switch_page",
  		       GTK_SIGNAL_FUNC(on_select_tab), NULL);
+     gtk_signal_connect(GTK_OBJECT(gui.tabline), "page-reordered",
+ 		       GTK_SIGNAL_FUNC(on_tab_reordered), NULL);
  # endif
  
      /* Create a popup menu for the tab line and connect it. */
*** ../vim-8.0.1210/src/gui_w32.c	2017-09-26 14:46:00.467725346 +0200
--- src/gui_w32.c	2017-10-22 15:22:23.148030111 +0200
***************
*** 8151,8156 ****
--- 8151,8184 ----
  # endif
  }
  
+ /*
+  * Get tabpage_T from POINT.
+  */
+     static tabpage_T *
+ GetTabFromPoint(
+     HWND    hWnd,
+     POINT   pt)
+ {
+     tabpage_T	*ptp = NULL;
+ 
+     if (gui_mch_showing_tabline())
+     {
+ 	TCHITTESTINFO htinfo;
+ 	htinfo.pt = pt;
+ 	/* ignore if a window under cusor is not tabcontrol. */
+ 	if (s_tabhwnd == hWnd)
+ 	{
+ 	    int idx = TabCtrl_HitTest(s_tabhwnd, &htinfo);
+ 	    if (idx != -1)
+ 		ptp = find_tabpage(idx + 1);
+ 	}
+     }
+     return ptp;
+ }
+ 
+ static POINT	    s_pt = {0, 0};
+ static HCURSOR      s_hCursor = NULL;
+ 
      static LRESULT CALLBACK
  tabline_wndproc(
      HWND hwnd,
***************
*** 8158,8164 ****
--- 8186,8258 ----
      WPARAM wParam,
      LPARAM lParam)
  {
+     POINT	pt;
+     tabpage_T	*tp;
+     RECT	rect;
+     int		nCenter;
+     int		idx0;
+     int		idx1;
+ 
      HandleMouseHide(uMsg, lParam);
+ 
+     switch (uMsg)
+     {
+ 	case WM_LBUTTONDOWN:
+ 	    {
+ 		s_pt.x = GET_X_LPARAM(lParam);
+ 		s_pt.y = GET_Y_LPARAM(lParam);
+ 		SetCapture(hwnd);
+ 		s_hCursor = GetCursor(); /* backup default cursor */
+ 		break;
+ 	    }
+ 	case WM_MOUSEMOVE:
+ 	    if (GetCapture() == hwnd
+ 		    && ((wParam & MK_LBUTTON)) != 0)
+ 	    {
+ 		pt.x = GET_X_LPARAM(lParam);
+ 		pt.y = s_pt.y;
+ 		if (abs(pt.x - s_pt.x) > GetSystemMetrics(SM_CXDRAG))
+ 		{
+ 		    SetCursor(LoadCursor(NULL, IDC_SIZEWE));
+ 
+ 		    tp = GetTabFromPoint(hwnd, pt);
+ 		    if (tp != NULL)
+ 		    {
+ 			idx0 = tabpage_index(curtab) - 1;
+ 			idx1 = tabpage_index(tp) - 1;
+ 
+ 			TabCtrl_GetItemRect(hwnd, idx1, &rect);
+ 			nCenter = rect.left + (rect.right - rect.left) / 2;
+ 
+ 			/* Check if the mouse cursor goes over the center of
+ 			 * the next tab to prevent "flickering". */
+ 			if ((idx0 < idx1) && (nCenter < pt.x))
+ 			{
+ 			    tabpage_move(idx1 + 1);
+ 			    update_screen(0);
+ 			}
+ 			else if ((idx1 < idx0) && (pt.x < nCenter))
+ 			{
+ 			    tabpage_move(idx1);
+ 			    update_screen(0);
+ 			}
+ 		    }
+ 		}
+ 	    }
+ 	    break;
+ 	case WM_LBUTTONUP:
+ 	    {
+ 		if (GetCapture() == hwnd)
+ 		{
+ 		    SetCursor(s_hCursor);
+ 		    ReleaseCapture();
+ 		}
+ 		break;
+ 	    }
+ 	default:
+ 	    break;
+     }
+ 
      return CallWindowProc(s_tabline_wndproc, hwnd, uMsg, wParam, lParam);
  }
  #endif
*** ../vim-8.0.1210/src/version.c	2017-10-22 14:44:13.931751620 +0200
--- src/version.c	2017-10-22 15:35:45.494485408 +0200
***************
*** 763,764 ****
--- 763,766 ----
  {   /* Add new patch number below this line */
+ /**/
+     1211,
  /**/

-- 
Windows
M!uqoms

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
