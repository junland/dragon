To: vim_dev@googlegroups.com
Subject: Patch 8.0.1302
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1302
Problem:    Still too many old style tests.
Solution:   Convert a few more tests to new style. (Yegappan Lakshmanan,
            closes #2326)
Files:      src/Makefile, src/testdir/Make_all.mak, src/testdir/Make_ming.mak,
            src/testdir/Make_vms.mms, src/testdir/runtest.vim,
            src/testdir/test68.in, src/testdir/test68.ok,
            src/testdir/test73.in, src/testdir/test73.ok,
            src/testdir/test_close_count.in, src/testdir/test_close_count.ok,
            src/testdir/test_close_count.vim,
            src/testdir/test_erasebackword.in,
            src/testdir/test_erasebackword.ok,
            src/testdir/test_erasebackword.vim,
            src/testdir/test_find_complete.vim, src/testdir/test_fixeol.in,
            src/testdir/test_fixeol.ok, src/testdir/test_fixeol.vim,
            src/testdir/test_listchars.in, src/testdir/test_listchars.ok,
            src/testdir/test_listchars.vim, src/testdir/test_textformat.vim


*** ../vim-8.0.1301/src/Makefile	2017-11-12 19:21:06.565379605 +0100
--- src/Makefile	2017-11-16 21:46:55.063877420 +0100
***************
*** 2097,2114 ****
  # Run individual OLD style test.
  # These do not depend on the executable, compile it when needed.
  test1 \
- 	test_close_count \
- 	test_erasebackword \
  	test_eval \
- 	test_fixeol \
- 	test_listchars \
  	test_wordcount \
  	test3 test11 test14 test15 test17 \
  	test29 test30 test36 test37 test39 \
  	test42 test44 test48 test49 \
  	test50 test52 test59 \
! 	test64 test68 test69 \
! 	test70 test72 test73 \
  	test85 test86 test87 test88 \
  	test94 test95 test99 test108:
  	cd testdir; rm -f $@.out; $(MAKE) -f Makefile $@.out VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
--- 2101,2114 ----
  # Run individual OLD style test.
  # These do not depend on the executable, compile it when needed.
  test1 \
  	test_eval \
  	test_wordcount \
  	test3 test11 test14 test15 test17 \
  	test29 test30 test36 test37 test39 \
  	test42 test44 test48 test49 \
  	test50 test52 test59 \
! 	test64 test69 \
! 	test70 test72 \
  	test85 test86 test87 test88 \
  	test94 test95 test99 test108:
  	cd testdir; rm -f $@.out; $(MAKE) -f Makefile $@.out VIMPROG=../$(VIMTARGET) $(GUI_TESTARG) SCRIPTSOURCE=../$(SCRIPTSOURCE)
***************
*** 2133,2138 ****
--- 2133,2139 ----
  	test_charsearch_utf8 \
  	test_cindent \
  	test_clientserver \
+ 	test_close_count \
  	test_cmdline \
  	test_command_count \
  	test_comparators \
***************
*** 2145,2150 ****
--- 2146,2152 ----
  	test_digraph \
  	test_display \
  	test_edit \
+ 	test_erasebackword \
  	test_escaped_glob \
  	test_ex_undo \
  	test_ex_z \
***************
*** 2164,2170 ****
--- 2166,2174 ----
  	test_filetype \
  	test_filter_cmd \
  	test_filter_map \
+ 	test_find_complete \
  	test_findfile \
+ 	test_fixeol \
  	test_float_func \
  	test_fnameescape \
  	test_fnamemodify \
***************
*** 2200,2205 ****
--- 2204,2210 ----
  	test_let \
  	test_lineending \
  	test_lispwords \
+ 	test_listchars \
  	test_listdict \
  	test_listlbr \
  	test_listlbr_utf8 \
***************
*** 2272,2277 ****
--- 2277,2283 ----
  	test_tcl \
  	test_terminal \
  	test_terminal_fail \
+ 	test_textformat \
  	test_textobjects \
  	test_timers \
  	test_true_false \
*** ../vim-8.0.1301/src/testdir/Make_all.mak	2017-11-05 20:59:12.524905157 +0100
--- src/testdir/Make_all.mak	2017-11-16 21:41:26.513027924 +0100
***************
*** 24,43 ****
  	test44.out \
  	test48.out \
  	test64.out \
- 	test68.out \
  	test69.out \
  	test70.out \
- 	test73.out \
  	test88.out \
  	test94.out \
  	test95.out \
  	test99.out \
  	test108.out \
- 	test_close_count.out \
- 	test_erasebackword.out \
  	test_eval.out \
- 	test_fixeol.out \
- 	test_listchars.out \
  	test_wordcount.out
  
  
--- 24,37 ----
***************
*** 86,91 ****
--- 80,86 ----
  	    test_charsearch.res \
  	    test_cindent.res \
  	    test_clientserver.res \
+ 	    test_close_count.res \
  	    test_cmdline.res \
  	    test_command_count.res \
  	    test_crypt.res \
***************
*** 95,103 ****
--- 90,101 ----
  	    test_digraph.res \
  	    test_display.res \
  	    test_edit.res \
+ 	    test_erasebackword.res \
  	    test_exists.res \
  	    test_farsi.res \
  	    test_file_size.res \
+ 	    test_find_complete.res \
+ 	    test_fixeol.res \
  	    test_fnameescape.res \
  	    test_fold.res \
  	    test_getvar.res \
***************
*** 119,124 ****
--- 117,123 ----
  	    test_langmap.res \
  	    test_let.res \
  	    test_lineending.res \
+ 	    test_listchars.res \
  	    test_listdict.res \
  	    test_listlbr.res \
  	    test_listlbr_utf8.res \
*** ../vim-8.0.1301/src/testdir/Make_ming.mak	2017-11-02 21:04:17.987345075 +0100
--- src/testdir/Make_ming.mak	2017-11-16 21:41:26.513027924 +0100
***************
*** 63,70 ****
  fixff:
  	-$(VIMPROG) -u dos.vim $(NO_INITS) "+argdo set ff=dos|upd" +q *.in *.ok
  	-$(VIMPROG) -u dos.vim $(NO_INITS) "+argdo set ff=unix|upd" +q \
! 		dotest.in test_listchars.ok \
! 		test_wordcount.ok
  
  clean:
  	-@if exist *.out $(DEL) *.out
--- 63,69 ----
  fixff:
  	-$(VIMPROG) -u dos.vim $(NO_INITS) "+argdo set ff=dos|upd" +q *.in *.ok
  	-$(VIMPROG) -u dos.vim $(NO_INITS) "+argdo set ff=unix|upd" +q \
! 		dotest.in test_wordcount.ok
  
  clean:
  	-@if exist *.out $(DEL) *.out
*** ../vim-8.0.1301/src/testdir/Make_vms.mms	2017-11-05 20:59:12.524905157 +0100
--- src/testdir/Make_vms.mms	2017-11-16 21:41:26.513027924 +0100
***************
*** 78,93 ****
         test29.out \
         test30.out test36.out test37.out test39.out \
         test42.out test44.out test48.out test49.out \
!        test64.out test68.out test69.out \
         test72.out test77a.out test88.out \
         test94.out test95.out test99.out test108.out \
         test_autocmd_option.out \
         test_breakindent.out \
-        test_close_count.out \
-        test_erasebackword.out \
         test_eval.out \
-        test_fixeol.out \
-        test_listchars.out \
         test_listlbr.out \
         test_listlbr_utf8.out \
         test_utf8.out \
--- 78,89 ----
         test29.out \
         test30.out test36.out test37.out test39.out \
         test42.out test44.out test48.out test49.out \
!        test64.out test69.out \
         test72.out test77a.out test88.out \
         test94.out test95.out test99.out test108.out \
         test_autocmd_option.out \
         test_breakindent.out \
         test_eval.out \
         test_listlbr.out \
         test_listlbr_utf8.out \
         test_utf8.out \
***************
*** 114,120 ****
  .ENDIF
  
  .IFDEF WANT_UNIX
! SCRIPT_UNIX = test10.out test17.out test27.out test49.out test73.out
  .ENDIF
  
  .IFDEF WANT_WIN
--- 110,116 ----
  .ENDIF
  
  .IFDEF WANT_UNIX
! SCRIPT_UNIX = test10.out test17.out test27.out test49.out
  .ENDIF
  
  .IFDEF WANT_WIN
*** ../vim-8.0.1301/src/testdir/runtest.vim	2017-11-04 20:46:35.106721408 +0100
--- src/testdir/runtest.vim	2017-11-16 21:41:26.513027924 +0100
***************
*** 103,108 ****
--- 103,112 ----
    " buffers.
    %bwipe!
  
+   " The test may change the current directory. Save and restore the
+   " directory after executing the test.
+   let save_cwd = getcwd()
+ 
    if exists("*SetUp")
      try
        call SetUp()
***************
*** 157,162 ****
--- 161,168 ----
        break
      endif
    endwhile
+ 
+   exe 'cd ' . save_cwd
  endfunc
  
  func AfterTheTest()
*** ../vim-8.0.1301/src/testdir/test68.in	2013-10-06 16:20:33.000000000 +0200
--- src/testdir/test68.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,131 ****
- Test for text formatting.
- 
- Results of test68:
- 
- STARTTEST
- :so small.vim
- /^{/+1
- :set noai tw=2 fo=t
- gRa b
- ENDTEST
- 
- {
-     
- 
- }
- 
- STARTTEST
- /^{/+1
- :set ai tw=2 fo=tw
- gqgqjjllab
- ENDTEST
- 
- {
- a  b  
- 
- a    
- }
- 
- STARTTEST
- /^{/+1
- :set tw=3 fo=t
- gqgqo
- a 
- ENDTEST
- 
- {
- a 
- }
- 
- STARTTEST
- /^{/+1
- :set tw=2 fo=tcq1 comments=:#
- gqgqjgqgqo
- a b
- #a b
- ENDTEST
- 
- {
- a b
- #a b
- }
- 
- STARTTEST
- /^{/+1
- :set tw=5 fo=tcn comments=:#
- A bjA b
- ENDTEST
- 
- {
-   1 a
- # 1 a
- }
- 
- STARTTEST
- /^{/+3
- :set tw=5 fo=t2a si
- i  A_
- ENDTEST
- 
- {
- 
-   x a
-   b
-  c
- 
- }
- 
- STARTTEST
- /^{/+1
- :set tw=5 fo=qn comments=:#
- gwap
- ENDTEST
- 
- {
- # 1 a b
- }
- 
- STARTTEST
- /^{/+1
- :set tw=5 fo=q2 comments=:#
- gwap
- ENDTEST
- 
- {
- # x
- #   a b
- }
- 
- STARTTEST
- /^{/+2
- :set tw& fo=a
- I^^
- ENDTEST
- 
- {
-    1aa
-    2bb
- }
- 
- STARTTEST
- /mno pqr/
- :setl tw=20 fo=an12wcq comments=s1:/*,mb:*,ex:*/
- A vwx yz
- ENDTEST
- 
- /* abc def ghi jkl 
-  *    mno pqr stu
-  */
- 
- STARTTEST
- /^#/
- :setl tw=12 fo=tqnc comments=:#
- A foobar
- ENDTEST
- 
- # 1 xxxxx
- 
- STARTTEST
- :g/^STARTTEST/.,/^ENDTEST/d
- :1;/^Results/,$wq! test.out
- ENDTEST
--- 0 ----
*** ../vim-8.0.1301/src/testdir/test68.ok	2013-10-06 16:20:33.000000000 +0200
--- src/testdir/test68.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,77 ****
- Results of test68:
- 
- 
- {
- a
- b
- }
- 
- 
- {
- a  
- b  
- 
- a  
- b
- }
- 
- 
- {
- a
- 
- 
- a
- 
- }
- 
- 
- {
- a b
- #a b
- 
- a b
- #a b
- }
- 
- 
- {
-   1 a
-     b
- # 1 a
- #   b
- }
- 
- 
- {
- 
-   x a
-     b_
-     c
- 
- }
- 
- 
- {
- # 1 a
- #   b
- }
- 
- 
- {
- # x a
- #   b
- }
- 
- 
- { 1aa ^^2bb }
- 
- 
- /* abc def ghi jkl 
-  *    mno pqr stu 
-  *    vwx yz
-  */
- 
- 
- # 1 xxxxx
- #   foobar
- 
--- 0 ----
*** ../vim-8.0.1301/src/testdir/test73.in	2017-03-08 22:55:14.914181221 +0100
--- src/testdir/test73.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,170 ****
- Tests for find completion.
- 
- STARTTEST
- :so small.vim
- :set belloff=all
- :" Do all test in a separate window to avoid E211 when we recursively
- :" delete the Xfind directory during cleanup
- :"
- :" This will cause a few errors, do it silently.
- :set visualbell
- :set nocp viminfo+=nviminfo
- :"
- :" On windows a stale "Xfind" directory may exist, remove it so that
- :" we start from a clean state.
- :call delete("Xfind", "rf")
- :new
- :let cwd=getcwd()
- :let test_out = cwd . '/test.out'
- :call mkdir('Xfind')
- :cd Xfind
- :set path=
- :find 	
- :exec "w! " . test_out
- :close
- :new
- :set path=.
- :find 	
- :exec "w >>" . test_out
- :close
- :new
- :set path=.,,
- :find 	
- :exec "w >>" . test_out
- :close
- :new
- :set path=./**
- :find 	
- :exec "w >>" . test_out
- :close
- :new
- :" We shouldn't find any file at this point, test.out must be empty.
- :call mkdir('in')
- :cd in
- :call mkdir('path')
- :exec "cd " . cwd
- :e Xfind/file.txt
- SHoly Grail:w
- :e Xfind/in/file.txt
- SJimmy Hoffa:w
- :e Xfind/in/stuff.txt
- SAnother Holy Grail:w
- :e Xfind/in/path/file.txt
- SE.T.:w
- :set path=Xfind/**
- :find file	
- :exec "w >>" . test_out
- :find file		
- :exec "w >>" . test_out
- :find file			
- :exec "w >>" . test_out
- :" Rerun the previous three find completions, using fullpath in 'path'
- :exec "set path=" . cwd . "/Xfind/**"
- :find file	
- :exec "w >>" .  test_out
- :find file		
- :exec "w >>" . test_out
- :find file			
- :exec "w >>" . test_out
- :" Same steps again, using relative and fullpath items that point to the same
- :" recursive location.
- :" This is to test that there are no duplicates in the completion list.
- :exec "set path+=Xfind/**"
- :find file	
- :exec "w >>" .  test_out
- :find file		
- :exec "w >>" . test_out
- :find file			
- :exec "w >>" . test_out
- :find file		
- :" Test find completion for directory of current buffer, which at this point
- :" is Xfind/in/file.txt.
- :set path=.
- :find st	
- :exec "w >>" .  test_out
- :" Test find completion for empty path item ",," which is the current directory
- :cd Xfind
- :set path=,,
- :find f		
- :exec "w >>" . test_out
- :" Test shortening of
- :"
- :"    foo/x/bar/voyager.txt
- :"    foo/y/bar/voyager.txt
- :"
- :" When current directory is above foo/ they should be shortened to (in order
- :" of appearance):
- :"
- :"    x/bar/voyager.txt
- :"    y/bar/voyager.txt
- :call mkdir('foo')
- :cd foo
- :call mkdir('x')
- :call mkdir('y')
- :cd x
- :call mkdir('bar')
- :cd ..
- :cd y
- :call mkdir('bar')
- :cd ..
- :cd ..
- :" We should now be in the Xfind directory
- :e foo/x/bar/voyager.txt
- SVoyager 1:w
- :e foo/y/bar/voyager.txt
- SVoyager 2:w
- :exec "set path=" . cwd . "/Xfind/**"
- :find voyager	
- :exec "w >>" . test_out
- :find voyager		
- :exec "w >>" . test_out
- :"
- :" When current directory is .../foo/y/bar they should be shortened to (in
- :" order of appearance):
- :"
- :"    ./voyager.txt
- :"    x/bar/voyager.txt
- :cd foo
- :cd y
- :cd bar
- :find voyager	
- :exec "w >> " . test_out
- :find voyager		
- :exec "w >> " . test_out
- :" Check the opposite too:
- :cd ..
- :cd ..
- :cd x
- :cd bar
- :find voyager	
- :exec "w >> " . test_out
- :find voyager		
- :exec "w >> " . test_out
- :" Check for correct handling of shorten_fname()'s behavior on windows
- :exec "cd " . cwd . "/Xfind/in"
- :find file	
- :exec "w >>" . test_out
- :" Test for relative to current buffer 'path' item
- :exec "cd " . cwd . "/Xfind/"
- :set path=./path
- :" Open the file where Jimmy Hoffa is found
- :e in/file.txt
- :" Find the file containing 'E.T.' in the Xfind/in/path directory
- :find file	
- :exec "w >>" . test_out
- :"
- :" Test that completion works when path=.,,
- :"
- :set path=.,,
- :" Open Jimmy Hoffa file
- :e in/file.txt
- :exec "w >>" . test_out
- :" Search for the file containing Holy Grail in same directory as in/path.txt
- :find stu	
- :exec "w >>" . test_out
- :q
- :exec "cd " . cwd
- :call delete("Xfind", "rf")
- :qa!
- ENDTEST
- 
--- 0 ----
*** ../vim-8.0.1301/src/testdir/test73.ok	2013-04-24 17:22:28.000000000 +0200
--- src/testdir/test73.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,21 ****
- Holy Grail
- Jimmy Hoffa
- E.T.
- Holy Grail
- Jimmy Hoffa
- E.T.
- Holy Grail
- Jimmy Hoffa
- E.T.
- Another Holy Grail
- Holy Grail
- Voyager 1
- Voyager 2
- Voyager 2
- Voyager 1
- Voyager 1
- Voyager 2
- Jimmy Hoffa
- E.T.
- Jimmy Hoffa
- Another Holy Grail
--- 0 ----
*** ../vim-8.0.1301/src/testdir/test_close_count.in	2017-03-08 22:55:14.914181221 +0100
--- src/testdir/test_close_count.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,154 ****
- Tests for :[count]close! and :[count]hide     vim: set ft=vim :
- 
- STARTTEST
- :so small.vim
- :set belloff=all
- :let tests = []
- :for i in range(5)
- :new
- :endfor
- :4wincmd w
- :close!
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :1close!
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :$close!
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :1wincmd w
- :2close!
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :1wincmd w
- :new
- :new
- :2wincmd w
- :-1close!
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :2wincmd w
- :+1close!
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :e! test.out
- :call append(0, map(copy(tests), 'join(v:val, " ")'))
- :w
- :only!
- :b1
- ENDTEST
- 
- STARTTEST
- :let tests = []
- :for i in range(5)
- :new
- :endfor
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :4wincmd w
- :.hide
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :1hide
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :$hide
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :1wincmd w
- :2hide
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :1wincmd w
- :new
- :new
- :3wincmd w
- :-hide
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :2wincmd w
- :+hide
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :e! test.out
- :call append(line('$'), map(copy(tests), 'join(v:val, " ")'))
- Go
- :w
- :only!
- :b1
- ENDTEST
- 
- STARTTEST
- :let tests = []
- :set hidden
- :for i in range(5)
- :new
- :endfor
- :1wincmd w
- :$ hide
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :$-1 close!
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :1wincmd w
- :.+close!
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :e! test.out
- :call append(line('$'), map(copy(tests), 'join(v:val, " ")'))
- Go
- :w
- :only!
- :b1
- ENDTEST
- 
- STARTTEST
- :let tests = []
- :set hidden
- :for i in range(5)
- :new
- :endfor
- :4wincmd w
- c
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- 1c
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- 9c
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :1wincmd w
- 2c
- :let buffers = []
- :windo call add(buffers, bufnr('%'))
- :call add(tests, buffers)
- :only!
- :e! test.out
- :call append(line('$'), map(copy(tests), 'join(v:val, " ")'))
- :w
- :qa!
- ENDTEST
- 
- 
--- 0 ----
*** ../vim-8.0.1301/src/testdir/test_close_count.ok	2014-11-27 14:21:34.000000000 +0100
--- src/testdir/test_close_count.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,23 ****
- 6 5 4 2 1
- 5 4 2 1
- 5 4 2
- 5 2
- 7 5 2
- 7 5
- 
- 13 12 11 10 9 1
- 13 12 11 9 1
- 12 11 9 1
- 12 11 9
- 12 9
- 15 12 9
- 15 12
- 
- 20 19 18 17 16
- 20 19 18 16
- 20 18 16
- 
- 25 24 23 21 1
- 24 23 21 1
- 24 23 21
- 24 21
--- 0 ----
*** ../vim-8.0.1301/src/testdir/test_close_count.vim	2017-11-16 21:51:29.091619215 +0100
--- src/testdir/test_close_count.vim	2017-11-16 21:41:26.513027924 +0100
***************
*** 0 ****
--- 1,174 ----
+ 
+ " Tests for :[count]close! command
+ func Test_close_count()
+   enew! | only
+ 
+   let wids = [win_getid()]
+   for i in range(5)
+     new
+     call add(wids, win_getid())
+   endfor
+ 
+   4wincmd w
+   close!
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[5], wids[4], wids[3], wids[1], wids[0]], ids)
+ 
+   1close!
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[4], wids[3], wids[1], wids[0]], ids)
+ 
+   $close!
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[4], wids[3], wids[1]], ids)
+ 
+   1wincmd w
+   2close!
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[4], wids[1]], ids)
+ 
+   1wincmd w
+   new
+   call add(wids, win_getid())
+   new
+   call add(wids, win_getid())
+   2wincmd w
+   -1close!
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[6], wids[4], wids[1]], ids)
+ 
+   2wincmd w
+   +1close!
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[6], wids[4]], ids)
+ 
+   only!
+ endfunc
+ 
+ " Tests for :[count]hide command
+ func Test_hide_count()
+   enew! | only
+ 
+   let wids = [win_getid()]
+   for i in range(5)
+     new
+     call add(wids, win_getid())
+   endfor
+ 
+   4wincmd w
+   .hide
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[5], wids[4], wids[3], wids[1], wids[0]], ids)
+ 
+   1hide
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[4], wids[3], wids[1], wids[0]], ids)
+ 
+   $hide
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[4], wids[3], wids[1]], ids)
+ 
+   1wincmd w
+   2hide
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[4], wids[1]], ids)
+ 
+   1wincmd w
+   new
+   call add(wids, win_getid())
+   new
+   call add(wids, win_getid())
+   3wincmd w
+   -hide
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[7], wids[4], wids[1]], ids)
+ 
+   2wincmd w
+   +hide
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[7], wids[4]], ids)
+ 
+   only!
+ endfunc
+ 
+ " Tests for :[count]close! command with 'hidden'
+ func Test_hidden_close_count()
+   enew! | only
+ 
+   let wids = [win_getid()]
+   for i in range(5)
+     new
+     call add(wids, win_getid())
+   endfor
+ 
+   set hidden
+ 
+   $ hide
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[5], wids[4], wids[3], wids[2], wids[1]], ids)
+ 
+   $-1 close!
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[5], wids[4], wids[3], wids[1]], ids)
+ 
+   1wincmd w
+   .+close!
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[5], wids[3], wids[1]], ids)
+ 
+   set nohidden
+   only!
+ endfunc
+ 
+ " Tests for 'CTRL-W c' command to close windows.
+ func Test_winclose_command()
+   enew! | only
+ 
+   let wids = [win_getid()]
+   for i in range(5)
+     new
+     call add(wids, win_getid())
+   endfor
+ 
+   set hidden
+ 
+   4wincmd w
+   exe "normal \<C-W>c"
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[5], wids[4], wids[3], wids[1], wids[0]], ids)
+ 
+   exe "normal 1\<C-W>c"
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[4], wids[3], wids[1], wids[0]], ids)
+ 
+   exe "normal 9\<C-W>c"
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[4], wids[3], wids[1]], ids)
+ 
+   1wincmd w
+   exe "normal 2\<C-W>c"
+   let ids = []
+   windo call add(ids, win_getid())
+   call assert_equal([wids[4], wids[1]], ids)
+ 
+   set nohidden
+   only!
+ endfunc
*** ../vim-8.0.1301/src/testdir/test_erasebackword.in	2017-03-08 22:55:14.914181221 +0100
--- src/testdir/test_erasebackword.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,20 ****
- Test for erasing backword
- 
- STARTTEST
- :so small.vim
- :set belloff=all
- :so mbyte.vim
- :set encoding=utf-8
- G
- o www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå„ÉØ„Éº„É´„Éâvim 
- o www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå„ÉØ„Éº„É´„Éâvim 
- o www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå„ÉØ„Éº„É´„Éâvim 
- o www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå„ÉØ„Éº„É´„Éâvim 
- o www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå„ÉØ„Éº„É´„Éâvim 
- o www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå„ÉØ„Éº„É´„Éâvim 
- :/^test/,$w! test.out
- :qa!
- ENDTEST
- 
- test starts here:
- 
--- 0 ----
*** ../vim-8.0.1301/src/testdir/test_erasebackword.ok	2015-01-30 03:19:33.000000000 +0100
--- src/testdir/test_erasebackword.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,8 ****
- test starts here:
- 
-  www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå„ÉØ„Éº„É´„Éâ
-  www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå
-  www„Åì„Çì„Å´„Å°„Çè
-  www
-  
- 
--- 0 ----
*** ../vim-8.0.1301/src/testdir/test_erasebackword.vim	2017-11-16 21:51:29.103619029 +0100
--- src/testdir/test_erasebackword.vim	2017-11-16 21:41:26.513027924 +0100
***************
*** 0 ****
--- 1,25 ----
+ 
+ func Test_erasebackword()
+   if !has('multi_byte')
+     return
+   endif
+ 
+   set encoding=utf-8
+   enew
+ 
+   exe "normal o www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå„ÉØ„Éº„É´„Éâvim \<C-W>"
+   call assert_equal(' www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå„ÉØ„Éº„É´„Éâ', getline('.'))
+   exe "normal o www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå„ÉØ„Éº„É´„Éâvim \<C-W>\<C-W>"
+   call assert_equal(' www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå', getline('.'))
+   exe "normal o www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå„ÉØ„Éº„É´„Éâvim \<C-W>\<C-W>\<C-W>"
+   call assert_equal(' www„Åì„Çì„Å´„Å°„Çè', getline('.'))
+   exe "normal o www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå„ÉØ„Éº„É´„Éâvim \<C-W>\<C-W>\<C-W>\<C-W>"
+   call assert_equal(' www', getline('.'))
+   exe "normal o www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå„ÉØ„Éº„É´„Éâvim \<C-W>\<C-W>\<C-W>\<C-W>\<C-W>"
+   call assert_equal(' ', getline('.'))
+   exe "normal o www„Åì„Çì„Å´„Å°„Çè‰∏ñÁïå„ÉØ„Éº„É´„Éâvim \<C-W>\<C-W>\<C-W>\<C-W>\<C-W>\<C-W>"
+   call assert_equal('', getline('.'))
+ 
+   enew!
+   set encoding&
+ endfunc
*** ../vim-8.0.1301/src/testdir/test_find_complete.vim	2017-11-16 21:51:29.107618967 +0100
--- src/testdir/test_find_complete.vim	2017-11-16 21:41:26.513027924 +0100
***************
*** 0 ****
--- 1,157 ----
+ " Tests for the 'find' command completion.
+ 
+ " Do all the tests in a separate window to avoid E211 when we recursively
+ " delete the Xfind directory during cleanup
+ func Test_find_complete()
+   set belloff=all
+ 
+   " On windows a stale "Xfind" directory may exist, remove it so that
+   " we start from a clean state.
+   call delete("Xfind", "rf")
+   let cwd = getcwd()
+   let test_out = cwd . '/test.out'
+   call mkdir('Xfind')
+   cd Xfind
+ 
+   new
+   set path=
+   call assert_fails('call feedkeys(":find\t\n", "xt")', 'E345:')
+   close
+ 
+   new
+   set path=.
+   call assert_fails('call feedkeys(":find\t\n", "xt")', 'E32:')
+   close
+ 
+   new
+   set path=.,,
+   call assert_fails('call feedkeys(":find\t\n", "xt")', 'E32:')
+   close
+ 
+   new
+   set path=./**
+   call assert_fails('call feedkeys(":find\t\n", "xt")', 'E32:')
+   close
+ 
+   " We shouldn't find any file till this point
+ 
+   call mkdir('in/path', 'p')
+   exe 'cd ' . cwd
+   call writefile(['Holy Grail'], 'Xfind/file.txt')
+   call writefile(['Jimmy Hoffa'], 'Xfind/in/file.txt')
+   call writefile(['Another Holy Grail'], 'Xfind/in/stuff.txt')
+   call writefile(['E.T.'], 'Xfind/in/path/file.txt')
+ 
+   new
+   set path=Xfind/**
+   call feedkeys(":find file\t\n", "xt")
+   call assert_equal('Holy Grail', getline(1))
+   call feedkeys(":find file\t\t\n", "xt")
+   call assert_equal('Jimmy Hoffa', getline(1))
+   call feedkeys(":find file\t\t\t\n", "xt")
+   call assert_equal('E.T.', getline(1))
+ 
+   " Rerun the previous three find completions, using fullpath in 'path'
+   exec "set path=" . cwd . "/Xfind/**"
+ 
+   call feedkeys(":find file\t\n", "xt")
+   call assert_equal('Holy Grail', getline(1))
+   call feedkeys(":find file\t\t\n", "xt")
+   call assert_equal('Jimmy Hoffa', getline(1))
+   call feedkeys(":find file\t\t\t\n", "xt")
+   call assert_equal('E.T.', getline(1))
+ 
+   " Same steps again, using relative and fullpath items that point to the same
+   " recursive location.
+   " This is to test that there are no duplicates in the completion list.
+   set path+=Xfind/**
+   call feedkeys(":find file\t\n", "xt")
+   call assert_equal('Holy Grail', getline(1))
+   call feedkeys(":find file\t\t\n", "xt")
+   call assert_equal('Jimmy Hoffa', getline(1))
+   call feedkeys(":find file\t\t\t\n", "xt")
+   call assert_equal('E.T.', getline(1))
+   call feedkeys(":find file\t\t\n", "xt")
+ 
+   " Test find completion for directory of current buffer, which at this point
+   " is Xfind/in/file.txt.
+   set path=.
+   call feedkeys(":find st\t\n", "xt")
+   call assert_equal('Another Holy Grail', getline(1))
+ 
+   " Test find completion for empty path item ",," which is the current
+   " directory
+   cd Xfind
+   set path=,,
+   call feedkeys(":find f\t\n", "xt")
+   call assert_equal('Holy Grail', getline(1))
+ 
+   " Test shortening of
+   "
+   "    foo/x/bar/voyager.txt
+   "    foo/y/bar/voyager.txt
+   "
+   " When current directory is above foo/ they should be shortened to (in order
+   " of appearance):
+   "
+   "    x/bar/voyager.txt
+   "    y/bar/voyager.txt
+   call mkdir('foo/x/bar', 'p')
+   call mkdir('foo/y/bar', 'p')
+   call writefile(['Voyager 1'], 'foo/x/bar/voyager.txt')
+   call writefile(['Voyager 2'], 'foo/y/bar/voyager.txt')
+ 
+   exec "set path=" . cwd . "/Xfind/**"
+   call feedkeys(":find voyager\t\n", "xt")
+   call assert_equal('Voyager 1', getline(1))
+   call feedkeys(":find voyager\t\t\n", "xt")
+   call assert_equal('Voyager 2', getline(1))
+ 
+   "
+   " When current directory is .../foo/y/bar they should be shortened to (in
+   " order of appearance):
+   "
+   "    ./voyager.txt
+   "    x/bar/voyager.txt
+   cd foo/y/bar
+   call feedkeys(":find voyager\t\n", "xt")
+   call assert_equal('Voyager 2', getline(1))
+   call feedkeys(":find voyager\t\t\n", "xt")
+   call assert_equal('Voyager 1', getline(1))
+ 
+   " Check the opposite too:
+   cd ../../x/bar
+   call feedkeys(":find voyager\t\n", "xt")
+   call assert_equal('Voyager 1', getline(1))
+   call feedkeys(":find voyager\t\t\n", "xt")
+   call assert_equal('Voyager 2', getline(1))
+ 
+   " Check for correct handling of shorten_fname()'s behavior on windows
+   exec "cd " . cwd . "/Xfind/in"
+   call feedkeys(":find file\t\n", "xt")
+   call assert_equal('Jimmy Hoffa', getline(1))
+ 
+   " Test for relative to current buffer 'path' item
+   exec "cd " . cwd . "/Xfind/"
+   set path=./path
+   " Open the file where Jimmy Hoffa is found
+   e in/file.txt
+   " Find the file containing 'E.T.' in the Xfind/in/path directory
+   call feedkeys(":find file\t\n", "xt")
+   call assert_equal('E.T.', getline(1))
+ 
+   " Test that completion works when path=.,,
+   set path=.,,
+   " Open Jimmy Hoffa file
+   e in/file.txt
+   call assert_equal('Jimmy Hoffa', getline(1))
+ 
+   " Search for the file containing Holy Grail in same directory as in/path.txt
+   call feedkeys(":find stu\t\n", "xt")
+   call assert_equal('Another Holy Grail', getline(1))
+ 
+   enew | only
+   exe 'cd ' . cwd
+   call delete('Xfind', 'rf')
+   set path&
+ endfunc
*** ../vim-8.0.1301/src/testdir/test_fixeol.in	2015-07-17 13:55:33.000000000 +0200
--- src/testdir/test_fixeol.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,40 ****
- Tests for 'fixeol'                         vim: set ft=vim :
-  
- STARTTEST
- :" first write two test files ‚Äì with and without trailing EOL
- :" use Unix fileformat for consistency
- :set ff=unix
- :enew!
- awith eol:w! XXEol
- :enew!
- :set noeol nofixeol
- awithout eol:w! XXNoEol
- :set eol fixeol
- :bwipe XXEol XXNoEol
- :"
- :" try editing files with 'fixeol' disabled
- :e! XXEol
- ostays eol:set nofixeol
- :w! XXTestEol
- :e! XXNoEol
- ostays without:set nofixeol
- :w! XXTestNoEol
- :bwipe XXEol XXNoEol XXTestEol XXTestNoEol
- :set fixeol
- :"
- :" Append "END" to each file so that we can see what the last written char was.
- ggdGaEND:w >>XXEol
- :w >>XXNoEol
- :w >>XXTestEol
- :w >>XXTestNoEol
- :"
- :" Concatenate the results
- :e! test.out
- a0:$r XXEol
- :$r XXNoEol
- Go1:$r XXTestEol
- :$r XXTestNoEol
- :w
- :qa!
- ENDTEST
- 
--- 0 ----
*** ../vim-8.0.1301/src/testdir/test_fixeol.ok	2015-07-17 13:55:33.000000000 +0200
--- src/testdir/test_fixeol.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,10 ****
- 0
- with eol
- END
- without eolEND
- 1
- with eol
- stays eol
- END
- without eol
- stays withoutEND
--- 0 ----
*** ../vim-8.0.1301/src/testdir/test_fixeol.vim	2017-11-16 21:51:29.119618781 +0100
--- src/testdir/test_fixeol.vim	2017-11-16 21:41:26.513027924 +0100
***************
*** 0 ****
--- 1,48 ----
+ " Tests for 'fixeol' and 'eol'
+ func Test_fixeol()
+   " first write two test files ‚Äì with and without trailing EOL
+   " use Unix fileformat for consistency
+   set ff=unix
+   enew!
+   call setline('.', 'with eol')
+   w! XXEol
+   enew!
+   set noeol nofixeol
+   call setline('.', 'without eol')
+   w! XXNoEol
+   set eol fixeol
+   bwipe XXEol XXNoEol
+ 
+   " try editing files with 'fixeol' disabled
+   e! XXEol
+   normal ostays eol
+   set nofixeol
+   w! XXTestEol
+   e! XXNoEol
+   normal ostays without
+   set nofixeol
+   w! XXTestNoEol
+   bwipe! XXEol XXNoEol XXTestEol XXTestNoEol
+   set fixeol
+ 
+   " Append "END" to each file so that we can see what the last written char
+   " was.
+   normal ggdGaEND
+   w >>XXEol
+   w >>XXNoEol
+   w >>XXTestEol
+   w >>XXTestNoEol
+ 
+   call assert_equal(['with eol', 'END'], readfile('XXEol'))
+   call assert_equal(['without eolEND'], readfile('XXNoEol'))
+   call assert_equal(['with eol', 'stays eol', 'END'], readfile('XXTestEol'))
+   call assert_equal(['without eol', 'stays withoutEND'],
+ 	      \ readfile('XXTestNoEol'))
+ 
+   call delete('XXEol')
+   call delete('XXNoEol')
+   call delete('XXTestEol')
+   call delete('XXTestNoEol')
+   set ff& fixeol& eol&
+   enew!
+ endfunc
*** ../vim-8.0.1301/src/testdir/test_listchars.in	2015-06-09 19:49:07.000000000 +0200
--- src/testdir/test_listchars.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,54 ****
- Tests for 'listchars' display with 'list' and :list
- 
- STARTTEST
- :so small.vim
- :set ff=unix
- :let g:lines = []
- :function GetScreenCharsForLine(lnum)
- :  return join(map(range(1, virtcol('$')), 'nr2char(screenchar(a:lnum, v:val))'), '')
- :endfunction
- :nnoremap <expr> GG ":call add(g:lines, GetScreenCharsForLine(".screenrow()."))\<CR>"
- :set listchars+=tab:>-,space:.,trail:<
- :set list
- :
- /^start:/
- :normal! jzt
- GG
- GG
- GG
- GG
- GGH:
- :set listchars-=trail:<
- GG
- GG
- GG
- GG
- GG:
- :put =g:lines
- :'[,']w! test.out
- ENDTEST
- 
- start:
- 	aa	
-   bb	  
-    cccc	 
- dd        ee  	
-  
- 
- 
- STARTTEST
- :set listchars+=trail:<
- :set nolist
- :
- /^start:/
- :redir! >> test.out
- :+1,$list
- :redir END
- :q!
- ENDTEST
- 
- start:
-   fff	  
- 	gg	
-      h	
- iii    	  
--- 0 ----
*** ../vim-8.0.1301/src/testdir/test_listchars.ok	2015-04-21 18:21:13.000000000 +0200
--- src/testdir/test_listchars.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,16 ****
- >-------aa>-----$
- ..bb>---<<$
- ...cccc><$
- dd........ee<<>-$
- <$
- >-------aa>-----$
- ..bb>---..$
- ...cccc>.$
- dd........ee..>-$
- .$
- 
- 
- ..fff>--<<$
- >-------gg>-----$
- .....h>-$
- iii<<<<><<$
--- 0 ----
*** ../vim-8.0.1301/src/testdir/test_listchars.vim	2017-11-16 21:51:29.131618595 +0100
--- src/testdir/test_listchars.vim	2017-11-16 21:41:26.513027924 +0100
***************
*** 0 ****
--- 1,63 ----
+ " Tests for 'listchars' display with 'list' and :list
+ 
+ source view_util.vim
+ 
+ func Test_listchars()
+   enew!
+   set ff=unix
+   set list
+ 
+   set listchars+=tab:>-,space:.,trail:<
+   call append(0, [
+ 	      \ '	aa	',
+ 	      \ '  bb	  ',
+ 	      \ '   cccc	 ',
+ 	      \ 'dd        ee  	',
+ 	      \ ' '
+ 	      \ ])
+   let expected = [
+ 	      \ '>-------aa>-----$',
+ 	      \ '..bb>---<<$',
+ 	      \ '...cccc><$',
+ 	      \ 'dd........ee<<>-$',
+ 	      \ '<$'
+ 	      \ ]
+   redraw!
+   for i in range(1, 5)
+     call cursor(i, 1)
+     call assert_equal([expected[i - 1]], ScreenLines(i, virtcol('$')))
+   endfor
+ 
+   set listchars-=trail:<
+   let expected = [
+ 	      \ '>-------aa>-----$',
+ 	      \ '..bb>---..$',
+ 	      \ '...cccc>.$',
+ 	      \ 'dd........ee..>-$',
+ 	      \ '.$'
+ 	      \ ]
+   redraw!
+   for i in range(1, 5)
+     call cursor(i, 1)
+     call assert_equal([expected[i - 1]], ScreenLines(i, virtcol('$')))
+   endfor
+ 
+   set listchars+=trail:<
+   set nolist
+   normal ggdG
+   call append(0, [
+ 	      \ '  fff	  ',
+ 	      \ '	gg	',
+ 	      \ '     h	',
+ 	      \ 'iii    	  ',
+ 	      \ ])
+   let l = split(execute("%list"), "\n")
+   call assert_equal([
+ 	      \ '..fff>--<<$',
+ 	      \ '>-------gg>-----$',
+ 	      \ '.....h>-$',
+ 	      \ 'iii<<<<><<$', '$'], l)
+ 
+   enew!
+   set listchars& ff&
+ endfunc
*** ../vim-8.0.1301/src/testdir/test_textformat.vim	2017-11-16 21:51:29.135618533 +0100
--- src/testdir/test_textformat.vim	2017-11-16 21:41:26.513027924 +0100
***************
*** 0 ****
--- 1,168 ----
+ " Tests for the various 'formatoptions' settings
+ func Test_text_format()
+   enew!
+ 
+   setl noai tw=2 fo=t
+   call append('$', [
+ 	      \ '{',
+ 	      \ '    ',
+ 	      \ '',
+ 	      \ '}'])
+   exe "normal /^{/+1\n0"
+   normal gRa b
+   let lnum = line('.')
+   call assert_equal([
+ 	      \ 'a',
+ 	      \ 'b'], getline(lnum - 1, lnum))
+ 
+   normal ggdG
+   setl ai tw=2 fo=tw
+   call append('$', [
+ 	      \ '{',
+ 	      \ 'a  b  ',
+ 	      \ '',
+ 	      \ 'a    ',
+ 	      \ '}'])
+   exe "normal /^{/+1\n0"
+   normal gqgqjjllab
+   let lnum = line('.')
+   call assert_equal([
+ 	      \ 'a  ',
+ 	      \ 'b  ',
+ 	      \ '',
+ 	      \ 'a  ',
+ 	      \ 'b'], getline(lnum - 4, lnum))
+ 
+   normal ggdG
+   setl tw=3 fo=t
+   call append('$', [
+ 	      \ '{',
+ 	      \ "a \<C-A>",
+ 	      \ '}'])
+   exe "normal /^{/+1\n0"
+   exe "normal gqgqo\na \<C-V>\<C-A>"
+   let lnum = line('.')
+   call assert_equal([
+ 	      \ 'a',
+ 	      \ "\<C-A>",
+ 	      \ '',
+ 	      \ 'a',
+ 	      \ "\<C-A>"], getline(lnum - 4, lnum))
+ 
+   normal ggdG
+   setl tw=2 fo=tcq1 comments=:#
+   call append('$', [
+ 	      \ '{',
+ 	      \ 'a b',
+ 	      \ '#a b',
+ 	      \ '}'])
+   exe "normal /^{/+1\n0"
+   exe "normal gqgqjgqgqo\na b\n#a b"
+   let lnum = line('.')
+   call assert_equal([
+ 	      \ 'a b',
+ 	      \ '#a b',
+ 	      \ '',
+ 	      \ 'a b',
+ 	      \ '#a b'], getline(lnum - 4, lnum))
+ 
+   normal ggdG
+   setl tw=5 fo=tcn comments=:#
+   call append('$', [
+ 	      \ '{',
+ 	      \ '  1 a',
+ 	      \ '# 1 a',
+ 	      \ '}'])
+   exe "normal /^{/+1\n0"
+   exe "normal A b\<Esc>jA b"
+   let lnum = line('.')
+   call assert_equal([
+ 	      \ '  1 a',
+ 	      \ '    b',
+ 	      \ '# 1 a',
+ 	      \ '#   b'], getline(lnum - 3, lnum))
+ 
+   normal ggdG
+   setl tw=5 fo=t2a si
+   call append('$', [
+ 	      \ '{',
+ 	      \ '',
+ 	      \ '  x a',
+ 	      \ '  b',
+ 	      \ ' c',
+ 	      \ '',
+ 	      \ '}'])
+   exe "normal /^{/+3\n0"
+   exe "normal i  \<Esc>A_"
+   let lnum = line('.')
+   call assert_equal([
+ 	      \ '',
+ 	      \ '  x a',
+ 	      \ '    b_',
+ 	      \ '    c',
+ 	      \ ''], getline(lnum - 2, lnum + 2))
+ 
+   normal ggdG
+   setl tw=5 fo=qn comments=:#
+   call append('$', [
+ 	      \ '{',
+ 	      \ '# 1 a b',
+ 	      \ '}'])
+   exe "normal /^{/+1\n5|"
+   normal gwap
+   call assert_equal(5, col('.'))
+   let lnum = line('.')
+   call assert_equal([
+ 	      \ '# 1 a',
+ 	      \ '#   b'], getline(lnum, lnum + 1))
+ 
+   normal ggdG
+   setl tw=5 fo=q2 comments=:#
+   call append('$', [
+ 	      \ '{',
+ 	      \ '# x',
+ 	      \ '#   a b',
+ 	      \ '}'])
+   exe "normal /^{/+1\n0"
+   normal gwap
+   let lnum = line('.')
+   call assert_equal([
+ 	      \ '# x a',
+ 	      \ '#   b'], getline(lnum, lnum + 1))
+ 
+   normal ggdG
+   setl tw& fo=a
+   call append('$', [
+ 	      \ '{',
+ 	      \ '   1aa',
+ 	      \ '   2bb',
+ 	      \ '}'])
+   exe "normal /^{/+2\n0"
+   normal I^^
+   call assert_equal('{ 1aa ^^2bb }', getline('.'))
+ 
+   normal ggdG
+   setl tw=20 fo=an12wcq comments=s1:/*,mb:*,ex:*/
+   call append('$', [
+ 	      \ '/* abc def ghi jkl ',
+ 	      \ ' *    mno pqr stu',
+ 	      \ ' */'])
+   exe "normal /mno pqr/\n"
+   normal A vwx yz
+   let lnum = line('.')
+   call assert_equal([
+ 	      \ ' *    mno pqr stu ',
+ 	      \ ' *    vwx yz',
+ 	      \ ' */'], getline(lnum - 1, lnum + 1))
+ 
+   normal ggdG
+   setl tw=12 fo=tqnc comments=:#
+   call setline('.', '# 1 xxxxx')
+   normal A foobar
+   call assert_equal([
+ 	      \ '# 1 xxxxx',
+ 	      \ '#   foobar'], getline(1, 2))
+ 
+   setl ai& tw& fo& si& comments&
+   enew!
+ endfunc
*** ../vim-8.0.1301/src/version.c	2017-11-16 17:35:57.076876528 +0100
--- src/version.c	2017-11-16 21:42:14.620269454 +0100
***************
*** 768,769 ****
--- 768,771 ----
  {   /* Add new patch number below this line */
+ /**/
+     1302,
  /**/

-- 
No engineer can take a shower without wondering if some sort of Teflon coating
would make showering unnecessary.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
