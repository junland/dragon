To: vim_dev@googlegroups.com
Subject: Patch 8.0.0477
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0477
Problem:    The client-server test may hang when failing.
Solution:   Set a timer.  Add assert_report()
Files:      src/testdir/test_clientserver.vim, src/testdir/runtest.vim,
            src/eval.c, src/evalfunc.c, src/proto/eval.pro, src/if_xcmdsrv.c,
            src/os_mswin.c, runtime/doc/eval.txt


*** ../vim-8.0.0476/src/testdir/test_clientserver.vim	2017-03-18 18:10:08.771696859 +0100
--- src/testdir/test_clientserver.vim	2017-03-18 19:31:27.544556146 +0100
***************
*** 6,34 ****
  
  source shared.vim
  
  func Test_client_server()
    let cmd = GetVimCommand()
    if cmd == ''
      return
    endif
!   let name = 'XVIMTEXT'
    let cmd .= ' --servername ' . name
    let g:job = job_start(cmd, {'stoponexit': 'kill', 'out_io': 'null'})
    call WaitFor('job_status(g:job) == "run"')
    if job_status(g:job) != 'run'
!     call assert_true(0, 'Cannot run the Vim server')
      return
    endif
  
    " Takes a short while for the server to be active.
    call WaitFor('serverlist() =~ "' . name . '"')
    call assert_match(name, serverlist())
  
    call remote_foreground(name)
  
    call remote_send(name, ":let testvar = 'yes'\<CR>")
    call WaitFor('remote_expr("' . name . '", "testvar") == "yes"')
    call assert_equal('yes', remote_expr(name, "testvar"))
  
    if has('unix') && has('gui') && !has('gui_running')
      " Running in a terminal and the GUI is avaiable: Tell the server to open
--- 6,51 ----
  
  source shared.vim
  
+ let s:where = 0
+ func Abort(id)
+   call assert_report('Test timed out at ' . s:where)
+   call FinishTesting()
+ endfunc
+ 
  func Test_client_server()
    let cmd = GetVimCommand()
    if cmd == ''
      return
    endif
! 
!   " Some of these commands may hang when failing.
!   call timer_start(10000, 'Abort')
! 
!   let s:where = 1
!   let name = 'XVIMTEST'
    let cmd .= ' --servername ' . name
    let g:job = job_start(cmd, {'stoponexit': 'kill', 'out_io': 'null'})
    call WaitFor('job_status(g:job) == "run"')
    if job_status(g:job) != 'run'
!     call assert_report('Cannot run the Vim server')
      return
    endif
+   let s:where = 2
  
    " Takes a short while for the server to be active.
    call WaitFor('serverlist() =~ "' . name . '"')
    call assert_match(name, serverlist())
+   let s:where = 3
  
    call remote_foreground(name)
+   let s:where = 4
  
    call remote_send(name, ":let testvar = 'yes'\<CR>")
+   let s:where = 5
    call WaitFor('remote_expr("' . name . '", "testvar") == "yes"')
+   let s:where = 6
    call assert_equal('yes', remote_expr(name, "testvar"))
+   let s:where = 7
  
    if has('unix') && has('gui') && !has('gui_running')
      " Running in a terminal and the GUI is avaiable: Tell the server to open
***************
*** 36,64 ****
      " Need to wait for the GUI to start up, otherwise the send hangs in trying
      " to send to the terminal window.
      call remote_send(name, ":gui -f\<CR>")
      sleep 500m
      call remote_send(name, ":let testvar = 'maybe'\<CR>")
      call WaitFor('remote_expr("' . name . '", "testvar") == "maybe"')
      call assert_equal('maybe', remote_expr(name, "testvar"))
    endif
  
    call assert_fails('call remote_send("XXX", ":let testvar = ''yes''\<CR>")', 'E241')
  
    " Expression evaluated locally.
    if v:servername == ''
      call remote_startserver('MYSELF')
      call assert_equal('MYSELF', v:servername)
    endif
    let g:testvar = 'myself'
    call assert_equal('myself', remote_expr(v:servername, 'testvar'))
  
    call remote_send(name, ":call server2client(expand('<client>'), 'got it')\<CR>", 'g:myserverid')
    call assert_equal('got it', remote_read(g:myserverid))
  
    call remote_send(name, ":qa!\<CR>")
    call WaitFor('job_status(g:job) == "dead"')
    if job_status(g:job) != 'dead'
!     call assert_true(0, 'Server did not exit')
      call job_stop(g:job, 'kill')
    endif
  endfunc
--- 53,92 ----
      " Need to wait for the GUI to start up, otherwise the send hangs in trying
      " to send to the terminal window.
      call remote_send(name, ":gui -f\<CR>")
+     let s:where = 8
      sleep 500m
      call remote_send(name, ":let testvar = 'maybe'\<CR>")
+     let s:where = 9
      call WaitFor('remote_expr("' . name . '", "testvar") == "maybe"')
+     let s:where = 10
      call assert_equal('maybe', remote_expr(name, "testvar"))
+     let s:where = 11
    endif
  
    call assert_fails('call remote_send("XXX", ":let testvar = ''yes''\<CR>")', 'E241')
+   let s:where = 12
  
    " Expression evaluated locally.
    if v:servername == ''
      call remote_startserver('MYSELF')
+     let s:where = 13
      call assert_equal('MYSELF', v:servername)
    endif
    let g:testvar = 'myself'
    call assert_equal('myself', remote_expr(v:servername, 'testvar'))
+   let s:where = 14
  
    call remote_send(name, ":call server2client(expand('<client>'), 'got it')\<CR>", 'g:myserverid')
+   let s:where = 15
    call assert_equal('got it', remote_read(g:myserverid))
+   let s:where = 16
  
    call remote_send(name, ":qa!\<CR>")
+   let s:where = 17
    call WaitFor('job_status(g:job) == "dead"')
+   let s:where = 18
    if job_status(g:job) != 'dead'
!     call assert_report('Server did not exit')
      call job_stop(g:job, 'kill')
    endif
  endfunc
*** ../vim-8.0.0476/src/testdir/runtest.vim	2017-03-16 22:30:33.658413403 +0100
--- src/testdir/runtest.vim	2017-03-18 19:31:56.276347722 +0100
***************
*** 86,92 ****
    return lnum - top - 1
  endfunc
  
! function RunTheTest(test)
    echo 'Executing ' . a:test
  
    " Avoid stopping at the "hit enter" prompt
--- 86,92 ----
    return lnum - top - 1
  endfunc
  
! func RunTheTest(test)
    echo 'Executing ' . a:test
  
    " Avoid stopping at the "hit enter" prompt
***************
*** 142,147 ****
--- 142,201 ----
    set nomodified
  endfunc
  
+ func AfterTheTest()
+   if len(v:errors) > 0
+     let s:fail += 1
+     call add(s:errors, 'Found errors in ' . s:test . ':')
+     call extend(s:errors, v:errors)
+     let v:errors = []
+   endif
+ endfunc
+ 
+ " This function can be called by a test if it wants to abort testing.
+ func FinishTesting()
+   call AfterTheTest()
+ 
+   " Don't write viminfo on exit.
+   set viminfo=
+ 
+   if s:fail == 0
+     " Success, create the .res file so that make knows it's done.
+     exe 'split ' . fnamemodify(g:testname, ':r') . '.res'
+     write
+   endif
+ 
+   if len(s:errors) > 0
+     " Append errors to test.log
+     split test.log
+     call append(line('$'), '')
+     call append(line('$'), 'From ' . g:testname . ':')
+     call append(line('$'), s:errors)
+     write
+   endif
+ 
+   let message = 'Executed ' . s:done . (s:done > 1 ? ' tests' : ' test')
+   echo message
+   call add(s:messages, message)
+   if s:fail > 0
+     let message = s:fail . ' FAILED:'
+     echo message
+     call add(s:messages, message)
+     call extend(s:messages, s:errors)
+   endif
+ 
+   " Add SKIPPED messages
+   call extend(s:messages, s:skipped)
+ 
+   " Append messages to the file "messages"
+   split messages
+   call append(line('$'), '')
+   call append(line('$'), 'From ' . g:testname . ':')
+   call append(line('$'), s:messages)
+   write
+ 
+   qall!
+ endfunc
+ 
  " Source the test script.  First grab the file name, in case the script
  " navigates away.  g:testname can be used by the tests.
  let g:testname = expand('%')
***************
*** 164,169 ****
--- 218,224 ----
  
  " Names of flaky tests.
  let s:flaky = [
+       \ 'Test_client_server()',
        \ 'Test_close_and_exit_cb()',
        \ 'Test_collapse_buffers()',
        \ 'Test_communicate()',
***************
*** 197,248 ****
      call RunTheTest(s:test)
    endif
  
!   if len(v:errors) > 0
!     let s:fail += 1
!     call add(s:errors, 'Found errors in ' . s:test . ':')
!     call extend(s:errors, v:errors)
!     let v:errors = []
!   endif
  endfor
  
! " Don't write viminfo on exit.
! set viminfo=
! 
! if s:fail == 0
!   " Success, create the .res file so that make knows it's done.
!   exe 'split ' . fnamemodify(g:testname, ':r') . '.res'
!   write
! endif
! 
! if len(s:errors) > 0
!   " Append errors to test.log
!   split test.log
!   call append(line('$'), '')
!   call append(line('$'), 'From ' . g:testname . ':')
!   call append(line('$'), s:errors)
!   write
! endif
! 
! let message = 'Executed ' . s:done . (s:done > 1 ? ' tests' : ' test')
! echo message
! call add(s:messages, message)
! if s:fail > 0
!   let message = s:fail . ' FAILED:'
!   echo message
!   call add(s:messages, message)
!   call extend(s:messages, s:errors)
! endif
! 
! " Add SKIPPED messages
! call extend(s:messages, s:skipped)
! 
! " Append messages to the file "messages"
! split messages
! call append(line('$'), '')
! call append(line('$'), 'From ' . g:testname . ':')
! call append(line('$'), s:messages)
! write
! 
! qall!
  
  " vim: shiftwidth=2 sts=2 expandtab
--- 252,260 ----
      call RunTheTest(s:test)
    endif
  
!   call AfterTheTest()
  endfor
  
! call FinishTesting()
  
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0476/src/eval.c	2017-03-16 19:04:15.271616151 +0100
--- src/eval.c	2017-03-18 19:12:54.036634715 +0100
***************
*** 9084,9089 ****
--- 9084,9100 ----
  }
  
      void
+ assert_report(typval_T *argvars)
+ {
+     garray_T	ga;
+ 
+     prepare_assert_error(&ga);
+     ga_concat(&ga, get_tv_string(&argvars[0]));
+     assert_error(&ga);
+     ga_clear(&ga);
+ }
+ 
+     void
  assert_exception(typval_T *argvars)
  {
      garray_T	ga;
*** ../vim-8.0.0476/src/evalfunc.c	2017-03-18 18:10:08.767696888 +0100
--- src/evalfunc.c	2017-03-18 19:10:16.969775345 +0100
***************
*** 52,57 ****
--- 52,58 ----
  static void f_assert_match(typval_T *argvars, typval_T *rettv);
  static void f_assert_notequal(typval_T *argvars, typval_T *rettv);
  static void f_assert_notmatch(typval_T *argvars, typval_T *rettv);
+ static void f_assert_report(typval_T *argvars, typval_T *rettv);
  static void f_assert_true(typval_T *argvars, typval_T *rettv);
  #ifdef FEAT_FLOAT
  static void f_asin(typval_T *argvars, typval_T *rettv);
***************
*** 483,488 ****
--- 484,490 ----
      {"assert_match",	2, 3, f_assert_match},
      {"assert_notequal",	2, 3, f_assert_notequal},
      {"assert_notmatch",	2, 3, f_assert_notmatch},
+     {"assert_report",	1, 1, f_assert_report},
      {"assert_true",	1, 2, f_assert_true},
  #ifdef FEAT_FLOAT
      {"atan",		1, 1, f_atan},
***************
*** 1314,1319 ****
--- 1316,1330 ----
  }
  
  /*
+  * "assert_report(msg)" function
+  */
+     static void
+ f_assert_report(typval_T *argvars, typval_T *rettv UNUSED)
+ {
+     assert_report(argvars);
+ }
+ 
+ /*
   * "assert_true(actual[, msg])" function
   */
      static void
*** ../vim-8.0.0476/src/proto/eval.pro	2017-02-17 16:31:16.929294079 +0100
--- src/proto/eval.pro	2017-03-18 19:08:31.066544037 +0100
***************
*** 123,128 ****
--- 123,129 ----
  void assert_match_common(typval_T *argvars, assert_type_T atype);
  void assert_inrange(typval_T *argvars);
  void assert_bool(typval_T *argvars, int isTrue);
+ void assert_report(typval_T *argvars);
  void assert_exception(typval_T *argvars);
  void assert_fails(typval_T *argvars);
  void fill_assert_error(garray_T *gap, typval_T *opt_msg_tv, char_u *exp_str, typval_T *exp_tv, typval_T *got_tv, assert_type_T atype);
*** ../vim-8.0.0476/src/if_xcmdsrv.c	2017-03-18 18:10:08.763696917 +0100
--- src/if_xcmdsrv.c	2017-03-18 19:28:50.833693143 +0100
***************
*** 596,601 ****
--- 596,605 ----
  	if (seconds >= 0 && (now - start) >= seconds)
  	    break;
  
+ #ifdef FEAT_TIMERS
+ 	check_due_timer();
+ #endif
+ 
  	/* Just look out for the answer without calling back into Vim */
  	if (localLoop)
  	{
*** ../vim-8.0.0476/src/os_mswin.c	2017-03-18 18:10:08.767696888 +0100
--- src/os_mswin.c	2017-03-18 19:30:54.676794586 +0100
***************
*** 2570,2575 ****
--- 2570,2578 ----
  	/* Loop until we receive a reply */
  	while (reply_received == 0)
  	{
+ #ifdef FEAT_TIMERS
+ 	    check_due_timer();
+ #endif
  	    /* Wait for a SendMessage() call to us.  This could be the reply
  	     * we are waiting for.  Use a timeout of a second, to catch the
  	     * situation that the server died unexpectedly. */
*** ../vim-8.0.0476/runtime/doc/eval.txt	2017-03-18 18:10:08.771696859 +0100
--- runtime/doc/eval.txt	2017-03-18 19:40:20.068694890 +0100
***************
*** 1983,1998 ****
  arglistid([{winnr} [, {tabnr}]]) Number	argument list id
  argv({nr})			String	{nr} entry of the argument list
  argv()				List	the argument list
! assert_equal({exp}, {act} [, {msg}])  none  assert {exp} is equal to {act}
! assert_exception({error} [, {msg}])   none  assert {error} is in v:exception
! assert_fails({cmd} [, {error}])	      none  assert {cmd} fails
! assert_false({actual} [, {msg}])      none  assert {actual} is false
  assert_inrange({lower}, {upper}, {actual} [, {msg}])
  				none	assert {actual} is inside the range
! assert_match({pat}, {text} [, {msg}])	 none  assert {pat} matches {text}
! assert_notequal({exp}, {act} [, {msg}])  none  assert {exp} is not equal {act}
! assert_notmatch({pat}, {text} [, {msg}]) none  assert {pat} not matches {text}
! assert_true({actual} [, {msg}])		 none  assert {actual} is true
  asin({expr})			Float	arc sine of {expr}
  atan({expr})			Float	arc tangent of {expr}
  atan2({expr1}, {expr2})		Float	arc tangent of {expr1} / {expr2}
--- 1986,2008 ----
  arglistid([{winnr} [, {tabnr}]]) Number	argument list id
  argv({nr})			String	{nr} entry of the argument list
  argv()				List	the argument list
! assert_equal({exp}, {act} [, {msg}])
! 				none	assert {exp} is equal to {act}
! assert_exception({error} [, {msg}])
! 				none	assert {error} is in v:exception
! assert_fails({cmd} [, {error}])	none	assert {cmd} fails
! assert_false({actual} [, {msg}])
! 				none	assert {actual} is false
  assert_inrange({lower}, {upper}, {actual} [, {msg}])
  				none	assert {actual} is inside the range
! assert_match({pat}, {text} [, {msg}])
! 				none	assert {pat} matches {text}
! assert_notequal({exp}, {act} [, {msg}])
! 				none	assert {exp} is not equal {act}
! assert_notmatch({pat}, {text} [, {msg}])
! 				none	assert {pat} not matches {text}
! assert_report({msg})		none	report a test failure
! assert_true({actual} [, {msg}])	none	assert {actual} is true
  asin({expr})			Float	arc sine of {expr}
  atan({expr})			Float	arc tangent of {expr}
  atan2({expr1}, {expr2})		Float	arc tangent of {expr1} / {expr2}
***************
*** 2580,2586 ****
  		The opposite of `assert_match()`: add an error message to
  		|v:errors| when {pattern} matches {actual}.
  
! assert_true({actual} [, {msg}])					*assert_true()*
  		When {actual} is not true an error message is added to
  		|v:errors|, like with |assert_equal()|.
  		A value is TRUE when it is a non-zero number.  When {actual}
--- 2590,2599 ----
  		The opposite of `assert_match()`: add an error message to
  		|v:errors| when {pattern} matches {actual}.
  
! assert_report({msg})					*assert_report()*
! 		Report a test failure directly, using {msg}.
! 
! assert_true({actual} [, {msg}])				*assert_true()*
  		When {actual} is not true an error message is added to
  		|v:errors|, like with |assert_equal()|.
  		A value is TRUE when it is a non-zero number.  When {actual}
*** ../vim-8.0.0476/src/version.c	2017-03-18 18:15:12.681524375 +0100
--- src/version.c	2017-03-18 19:37:05.370106207 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     477,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
150. You find yourself counting emoticons to get to sleep.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
