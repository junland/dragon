To: vim_dev@googlegroups.com
Subject: Patch 8.0.0848
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0848
Problem:    Using multiple ch_log functions is clumsy.
Solution:   Use variable arguments. (Ozaki Kiichi, closes #1919)
Files:      src/channel.c, src/message.c, src/proto/channel.pro,
            src/terminal.c


*** ../vim-8.0.0847/src/channel.c	2017-08-03 13:51:02.380784846 +0200
--- src/channel.c	2017-08-03 14:37:55.376002166 +0200
***************
*** 159,196 ****
  static int did_log_msg = TRUE;
  
      void
! ch_log(channel_T *ch, char *msg)
  {
      if (log_fd != NULL)
      {
! 	ch_log_lead("", ch);
! 	fputs(msg, log_fd);
! 	fputc('\n', log_fd);
! 	fflush(log_fd);
! 	did_log_msg = TRUE;
!     }
! }
! 
!     void
! ch_logn(channel_T *ch, char *msg, int nr)
! {
!     if (log_fd != NULL)
!     {
! 	ch_log_lead("", ch);
! 	fprintf(log_fd, msg, nr);
! 	fputc('\n', log_fd);
! 	fflush(log_fd);
! 	did_log_msg = TRUE;
!     }
! }
  
-     void
- ch_logs(channel_T *ch, char *msg, char *name)
- {
-     if (log_fd != NULL)
-     {
  	ch_log_lead("", ch);
! 	fprintf(log_fd, msg, name);
  	fputc('\n', log_fd);
  	fflush(log_fd);
  	did_log_msg = TRUE;
--- 159,174 ----
  static int did_log_msg = TRUE;
  
      void
! ch_log(channel_T *ch, const char *fmt, ...)
  {
      if (log_fd != NULL)
      {
! 	va_list ap;
  
  	ch_log_lead("", ch);
! 	va_start(ap, fmt);
! 	vfprintf(log_fd, fmt, ap);
! 	va_end(ap);
  	fputc('\n', log_fd);
  	fflush(log_fd);
  	did_log_msg = TRUE;
***************
*** 198,248 ****
  }
  
      static void
! ch_logsn(channel_T *ch, char *msg, char *name, int nr)
  {
      if (log_fd != NULL)
      {
! 	ch_log_lead("", ch);
! 	fprintf(log_fd, msg, name, nr);
! 	fputc('\n', log_fd);
! 	fflush(log_fd);
! 	did_log_msg = TRUE;
!     }
! }
  
-     static void
- ch_error(channel_T *ch, char *msg)
- {
-     if (log_fd != NULL)
-     {
- 	ch_log_lead("ERR ", ch);
- 	fputs(msg, log_fd);
- 	fputc('\n', log_fd);
- 	fflush(log_fd);
- 	did_log_msg = TRUE;
-     }
- }
- 
-     static void
- ch_errorn(channel_T *ch, char *msg, int nr)
- {
-     if (log_fd != NULL)
-     {
  	ch_log_lead("ERR ", ch);
! 	fprintf(log_fd, msg, nr);
! 	fputc('\n', log_fd);
! 	fflush(log_fd);
! 	did_log_msg = TRUE;
!     }
! }
! 
!     static void
! ch_errors(channel_T *ch, char *msg, char *arg)
! {
!     if (log_fd != NULL)
!     {
! 	ch_log_lead("ERR ", ch);
! 	fprintf(log_fd, msg, arg);
  	fputc('\n', log_fd);
  	fflush(log_fd);
  	did_log_msg = TRUE;
--- 176,191 ----
  }
  
      static void
! ch_error(channel_T *ch, const char *fmt, ...)
  {
      if (log_fd != NULL)
      {
! 	va_list ap;
  
  	ch_log_lead("ERR ", ch);
! 	va_start(ap, fmt);
! 	vfprintf(log_fd, fmt, ap);
! 	va_end(ap);
  	fputc('\n', log_fd);
  	fflush(log_fd);
  	did_log_msg = TRUE;
***************
*** 513,519 ****
  
      channel = channel_fd2channel(fd, &part);
      if (channel == NULL)
! 	ch_errorn(NULL, "Channel for fd %d not found", fd);
      else
  	channel_read(channel, part, "channel_read_fd");
  }
--- 456,462 ----
  
      channel = channel_fd2channel(fd, &part);
      if (channel == NULL)
! 	ch_error(NULL, "Channel for fd %d not found", fd);
      else
  	channel_read(channel, part, "channel_read_fd");
  }
***************
*** 757,763 ****
  	       )
  	    {
  		SOCK_ERRNO;
! 		ch_errorn(channel,
  			 "channel_open: Connect failed with errno %d", errno);
  		sock_close(sd);
  		channel_free(channel);
--- 700,706 ----
  	       )
  	    {
  		SOCK_ERRNO;
! 		ch_error(channel,
  			 "channel_open: Connect failed with errno %d", errno);
  		sock_close(sd);
  		channel_free(channel);
***************
*** 766,772 ****
  	}
  
  	/* Try connecting to the server. */
! 	ch_logsn(channel, "Connecting to %s port %d", hostname, port);
  	ret = connect(sd, (struct sockaddr *)&server, sizeof(server));
  
  	if (ret == 0)
--- 709,715 ----
  	}
  
  	/* Try connecting to the server. */
! 	ch_log(channel, "Connecting to %s port %d", hostname, port);
  	ret = connect(sd, (struct sockaddr *)&server, sizeof(server));
  
  	if (ret == 0)
***************
*** 781,787 ****
  #endif
  		))
  	{
! 	    ch_errorn(channel,
  			 "channel_open: Connect failed with errno %d", errno);
  	    PERROR(_(e_cannot_connect));
  	    sock_close(sd);
--- 724,730 ----
  #endif
  		))
  	{
! 	    ch_error(channel,
  			 "channel_open: Connect failed with errno %d", errno);
  	    PERROR(_(e_cannot_connect));
  	    sock_close(sd);
***************
*** 818,831 ****
  #ifndef WIN32
  	    gettimeofday(&start_tv, NULL);
  #endif
! 	    ch_logn(channel,
  		    "Waiting for connection (waiting %d msec)...", waitnow);
  	    ret = select((int)sd + 1, &rfds, &wfds, NULL, &tv);
  
  	    if (ret < 0)
  	    {
  		SOCK_ERRNO;
! 		ch_errorn(channel,
  			"channel_open: Connect failed with errno %d", errno);
  		PERROR(_(e_cannot_connect));
  		sock_close(sd);
--- 761,774 ----
  #ifndef WIN32
  	    gettimeofday(&start_tv, NULL);
  #endif
! 	    ch_log(channel,
  		    "Waiting for connection (waiting %d msec)...", waitnow);
  	    ret = select((int)sd + 1, &rfds, &wfds, NULL, &tv);
  
  	    if (ret < 0)
  	    {
  		SOCK_ERRNO;
! 		ch_error(channel,
  			"channel_open: Connect failed with errno %d", errno);
  		PERROR(_(e_cannot_connect));
  		sock_close(sd);
***************
*** 864,870 ****
  # endif
  			))
  		{
! 		    ch_errorn(channel,
  			    "channel_open: Connect failed with errno %d",
  			    so_error);
  		    PERROR(_(e_cannot_connect));
--- 807,813 ----
  # endif
  			))
  		{
! 		    ch_error(channel,
  			    "channel_open: Connect failed with errno %d",
  			    so_error);
  		    PERROR(_(e_cannot_connect));
***************
*** 1077,1083 ****
  	chanpart_T *in_part = &channel->ch_part[PART_IN];
  
  	set_bufref(&in_part->ch_bufref, job->jv_in_buf);
! 	ch_logs(channel, "reading from buffer '%s'",
  				 (char *)in_part->ch_bufref.br_buf->b_ffname);
  	if (options->jo_set & JO_IN_TOP)
  	{
--- 1020,1026 ----
  	chanpart_T *in_part = &channel->ch_part[PART_IN];
  
  	set_bufref(&in_part->ch_bufref, job->jv_in_buf);
! 	ch_log(channel, "reading from buffer '%s'",
  				 (char *)in_part->ch_bufref.br_buf->b_ffname);
  	if (options->jo_set & JO_IN_TOP)
  	{
***************
*** 1244,1250 ****
  	    }
  	    else
  	    {
! 		ch_logs(channel, "writing out to buffer '%s'",
  						       (char *)buf->b_ffname);
  		set_bufref(&channel->ch_part[PART_OUT].ch_bufref, buf);
  	    }
--- 1187,1193 ----
  	    }
  	    else
  	    {
! 		ch_log(channel, "writing out to buffer '%s'",
  						       (char *)buf->b_ffname);
  		set_bufref(&channel->ch_part[PART_OUT].ch_bufref, buf);
  	    }
***************
*** 1287,1293 ****
  	    }
  	    else
  	    {
! 		ch_logs(channel, "writing err to buffer '%s'",
  						       (char *)buf->b_ffname);
  		set_bufref(&channel->ch_part[PART_ERR].ch_bufref, buf);
  	    }
--- 1230,1236 ----
  	    }
  	    else
  	    {
! 		ch_log(channel, "writing err to buffer '%s'",
  						       (char *)buf->b_ffname);
  		set_bufref(&channel->ch_part[PART_ERR].ch_bufref, buf);
  	    }
***************
*** 1460,1468 ****
      }
  
      if (written == 1)
! 	ch_logn(channel, "written line %d to channel", (int)lnum - 1);
      else if (written > 1)
! 	ch_logn(channel, "written %d lines to channel", written);
  
      in_part->ch_buf_top = lnum;
      if (lnum > buf->b_ml.ml_line_count || lnum > in_part->ch_buf_bot)
--- 1403,1411 ----
      }
  
      if (written == 1)
! 	ch_log(channel, "written line %d to channel", (int)lnum - 1);
      else if (written > 1)
! 	ch_log(channel, "written %d lines to channel", written);
  
      in_part->ch_buf_top = lnum;
      if (lnum > buf->b_ml.ml_line_count || lnum > in_part->ch_buf_bot)
***************
*** 1475,1481 ****
  	ch_close_part(channel, PART_IN);
      }
      else
! 	ch_logn(channel, "Still %d more lines to write",
  					  buf->b_ml.ml_line_count - lnum + 1);
  }
  
--- 1418,1424 ----
  	ch_close_part(channel, PART_IN);
      }
      else
! 	ch_log(channel, "Still %d more lines to write",
  					  buf->b_ml.ml_line_count - lnum + 1);
  }
  
***************
*** 1495,1501 ****
  
  	    if (ch_part->ch_bufref.br_buf == buf)
  	    {
! 		ch_logs(channel, "%s buffer has been wiped out",
  							    part_names[part]);
  		ch_part->ch_bufref.br_buf = NULL;
  	    }
--- 1438,1444 ----
  
  	    if (ch_part->ch_bufref.br_buf == buf)
  	    {
! 		ch_log(channel, "%s buffer has been wiped out",
  							    part_names[part]);
  		ch_part->ch_bufref.br_buf = NULL;
  	    }
***************
*** 1556,1566 ****
  	    }
  
  	    if (written == 1)
! 		ch_logn(channel, "written line %d to channel", (int)lnum - 1);
  	    else if (written > 1)
! 		ch_logn(channel, "written %d lines to channel", written);
  	    if (lnum < buf->b_ml.ml_line_count)
! 		ch_logn(channel, "Still %d more lines to write",
  					      buf->b_ml.ml_line_count - lnum);
  
  	    in_part->ch_buf_bot = lnum;
--- 1499,1509 ----
  	    }
  
  	    if (written == 1)
! 		ch_log(channel, "written line %d to channel", (int)lnum - 1);
  	    else if (written > 1)
! 		ch_log(channel, "written %d lines to channel", written);
  	    if (lnum < buf->b_ml.ml_line_count)
! 		ch_log(channel, "Still %d more lines to write",
  					      buf->b_ml.ml_line_count - lnum);
  
  	    in_part->ch_buf_bot = lnum;
***************
*** 1929,1935 ****
  	    if (listtv.v_type != VAR_LIST)
  		ch_error(channel, "Did not receive a list, discarding");
  	    else
! 		ch_errorn(channel, "Expected list with two items, got %d",
  						  listtv.vval.v_list->lv_len);
  	    clear_tv(&listtv);
  	}
--- 1872,1878 ----
  	    if (listtv.v_type != VAR_LIST)
  		ch_error(channel, "Did not receive a list, discarding");
  	    else
! 		ch_error(channel, "Expected list with two items, got %d",
  						  listtv.vval.v_list->lv_len);
  	    clear_tv(&listtv);
  	}
***************
*** 1972,1978 ****
  	{
  	    /* First time encountering incomplete message or after receiving
  	     * more (but still incomplete): set a deadline of 100 msec. */
! 	    ch_logn(channel,
  		    "Incomplete message (%d bytes) - wait 100 msec for more",
  		    (int)buflen);
  	    reader.js_used = 0;
--- 1915,1921 ----
  	{
  	    /* First time encountering incomplete message or after receiving
  	     * more (but still incomplete): set a deadline of 100 msec. */
! 	    ch_log(channel,
  		    "Incomplete message (%d bytes) - wait 100 msec for more",
  		    (int)buflen);
  	    reader.js_used = 0;
***************
*** 2106,2112 ****
  	{
  	    *rettv = item->jq_value;
  	    if (tv->v_type == VAR_NUMBER)
! 		ch_logn(channel, "Getting JSON message %d", tv->vval.v_number);
  	    remove_json_node(head, item);
  	    return OK;
  	}
--- 2049,2055 ----
  	{
  	    *rettv = item->jq_value;
  	    if (tv->v_type == VAR_NUMBER)
! 		ch_log(channel, "Getting JSON message %d", tv->vval.v_number);
  	    remove_json_node(head, item);
  	    return OK;
  	}
***************
*** 2204,2215 ****
  	int save_called_emsg = called_emsg;
  
  	called_emsg = FALSE;
! 	ch_logs(channel, "Executing ex command '%s'", (char *)arg);
  	++emsg_silent;
  	do_cmdline_cmd(arg);
  	--emsg_silent;
  	if (called_emsg)
! 	    ch_logs(channel, "Ex command error: '%s'",
  					  (char *)get_vim_var_str(VV_ERRMSG));
  	called_emsg = save_called_emsg;
      }
--- 2147,2158 ----
  	int save_called_emsg = called_emsg;
  
  	called_emsg = FALSE;
! 	ch_log(channel, "Executing ex command '%s'", (char *)arg);
  	++emsg_silent;
  	do_cmdline_cmd(arg);
  	--emsg_silent;
  	if (called_emsg)
! 	    ch_log(channel, "Ex command error: '%s'",
  					  (char *)get_vim_var_str(VV_ERRMSG));
  	called_emsg = save_called_emsg;
      }
***************
*** 2217,2223 ****
      {
  	exarg_T ea;
  
! 	ch_logs(channel, "Executing normal command '%s'", (char *)arg);
  	ea.arg = arg;
  	ea.addr_count = 0;
  	ea.forceit = TRUE; /* no mapping */
--- 2160,2166 ----
      {
  	exarg_T ea;
  
! 	ch_log(channel, "Executing normal command '%s'", (char *)arg);
  	ea.arg = arg;
  	ea.addr_count = 0;
  	ea.forceit = TRUE; /* no mapping */
***************
*** 2270,2281 ****
  	    ++emsg_skip;
  	    if (!is_call)
  	    {
! 		ch_logs(channel, "Evaluating expression '%s'", (char *)arg);
  		tv = eval_expr(arg, NULL);
  	    }
  	    else
  	    {
! 		ch_logs(channel, "Calling '%s'", (char *)arg);
  		if (func_call(arg, &argv[2], NULL, NULL, &res_tv) == OK)
  		    tv = &res_tv;
  	    }
--- 2213,2224 ----
  	    ++emsg_skip;
  	    if (!is_call)
  	    {
! 		ch_log(channel, "Evaluating expression '%s'", (char *)arg);
  		tv = eval_expr(arg, NULL);
  	    }
  	    else
  	    {
! 		ch_log(channel, "Calling '%s'", (char *)arg);
  		if (func_call(arg, &argv[2], NULL, NULL, &res_tv) == OK)
  		    tv = &res_tv;
  	    }
***************
*** 2312,2318 ****
      }
      else if (p_verbose > 2)
      {
! 	ch_errors(channel, "Received unknown command: %s", (char *)cmd);
  	EMSG2(_("E905: received unknown command: %s"), cmd);
      }
  }
--- 2255,2261 ----
      }
      else if (p_verbose > 2)
      {
! 	ch_error(channel, "Received unknown command: %s", (char *)cmd);
  	EMSG2(_("E905: received unknown command: %s"), cmd);
      }
  }
***************
*** 2328,2334 ****
  	cbq_T	    *item,
  	typval_T    *argv)
  {
!     ch_logs(channel, "Invoking one-time callback %s",
  						   (char *)item->cq_callback);
      /* Remove the item from the list first, if the callback
       * invokes ch_close() the list will be cleared. */
--- 2271,2277 ----
  	cbq_T	    *item,
  	typval_T    *argv)
  {
!     ch_log(channel, "Invoking one-time callback %s",
  						   (char *)item->cq_callback);
      /* Remove the item from the list first, if the callback
       * invokes ch_close() the list will be cleared. */
***************
*** 2367,2373 ****
      }
  
      /* Append to the buffer */
!     ch_logn(channel, "appending line %d to buffer", (int)lnum + 1 - empty);
  
      buffer->b_p_ma = TRUE;
      curbuf = buffer;
--- 2310,2316 ----
      }
  
      /* Append to the buffer */
!     ch_log(channel, "appending line %d to buffer", (int)lnum + 1 - empty);
  
      buffer->b_p_ma = TRUE;
      curbuf = buffer;
***************
*** 2442,2448 ****
  
      while ((msg = channel_get(channel, part)) != NULL)
      {
! 	ch_logs(channel, "Dropping message '%s'", (char *)msg);
  	vim_free(msg);
      }
  }
--- 2385,2391 ----
  
      while ((msg = channel_get(channel, part)) != NULL)
      {
! 	ch_log(channel, "Dropping message '%s'", (char *)msg);
  	vim_free(msg);
      }
  }
***************
*** 2497,2503 ****
  					       || buffer->b_ml.ml_mfp == NULL))
      {
  	/* buffer was wiped out or unloaded */
! 	ch_logs(channel, "%s buffer has been wiped out", part_names[part]);
  	ch_part->ch_bufref.br_buf = NULL;
  	buffer = NULL;
      }
--- 2440,2446 ----
  					       || buffer->b_ml.ml_mfp == NULL))
      {
  	/* buffer was wiped out or unloaded */
! 	ch_log(channel, "%s buffer has been wiped out", part_names[part]);
  	ch_part->ch_bufref.br_buf = NULL;
  	buffer = NULL;
      }
***************
*** 2651,2657 ****
  		listtv = NULL;
  	    }
  	    else
! 		ch_logn(channel, "Dropping message %d without callback",
  								       seq_nr);
  	}
      }
--- 2594,2600 ----
  		listtv = NULL;
  	    }
  	    else
! 		ch_log(channel, "Dropping message %d without callback",
  								       seq_nr);
  	}
      }
***************
*** 2680,2693 ****
  	    else
  	    {
  		/* invoke the channel callback */
! 		ch_logs(channel, "Invoking channel callback %s",
  							    (char *)callback);
  		invoke_callback(channel, callback, partial, argv);
  	    }
  	}
      }
      else
! 	ch_logn(channel, "Dropping message %d", seq_nr);
  
      if (listtv != NULL)
  	free_tv(listtv);
--- 2623,2636 ----
  	    else
  	    {
  		/* invoke the channel callback */
! 		ch_log(channel, "Invoking channel callback %s",
  							    (char *)callback);
  		invoke_callback(channel, callback, partial, argv);
  	    }
  	}
      }
      else
! 	ch_log(channel, "Dropping message %d", seq_nr);
  
      if (listtv != NULL)
  	free_tv(listtv);
***************
*** 2888,2894 ****
  	  /* Invoke the close callback, if still set. */
  	  if (channel->ch_close_cb != NULL)
  	  {
! 	      ch_logs(channel, "Invoking close callback %s",
  						(char *)channel->ch_close_cb);
  	      argv[0].v_type = VAR_CHANNEL;
  	      argv[0].vval.v_channel = channel;
--- 2831,2837 ----
  	  /* Invoke the close callback, if still set. */
  	  if (channel->ch_close_cb != NULL)
  	  {
! 	      ch_log(channel, "Invoking close callback %s",
  						(char *)channel->ch_close_cb);
  	      argv[0].v_type = VAR_CHANNEL;
  	      argv[0].vval.v_channel = channel;
***************
*** 3074,3080 ****
  channel_wait(channel_T *channel, sock_T fd, int timeout)
  {
      if (timeout > 0)
! 	ch_logn(channel, "Waiting for up to %d msec", timeout);
  
  # ifdef WIN32
      if (fd != channel->CH_SOCK_FD)
--- 3017,3023 ----
  channel_wait(channel_T *channel, sock_T fd, int timeout)
  {
      if (timeout > 0)
! 	ch_log(channel, "Waiting for up to %d msec", timeout);
  
  # ifdef WIN32
      if (fd != channel->CH_SOCK_FD)
***************
*** 3175,3191 ****
  ch_close_part_on_error(
  	channel_T *channel, ch_part_T part, int is_err, char *func)
  {
!     char	msgbuf[80];
! 
!     vim_snprintf(msgbuf, sizeof(msgbuf),
! 	    "%%s(): Read %s from ch_part[%d], closing",
! 					    (is_err ? "error" : "EOF"), part);
  
      if (is_err)
  	/* Do not call emsg(), most likely the other end just exited. */
! 	ch_errors(channel, msgbuf, func);
      else
! 	ch_logs(channel, msgbuf, func);
  
      /* Queue a "DETACH" netbeans message in the command queue in order to
       * terminate the netbeans session later. Do not end the session here
--- 3118,3130 ----
  ch_close_part_on_error(
  	channel_T *channel, ch_part_T part, int is_err, char *func)
  {
!     char	msg[] = "%s(): Read %s from ch_part[%d], closing";
  
      if (is_err)
  	/* Do not call emsg(), most likely the other end just exited. */
! 	ch_error(channel, msg, func, "error", part);
      else
! 	ch_log(channel, msg, func, "EOF", part);
  
      /* Queue a "DETACH" netbeans message in the command queue in order to
       * terminate the netbeans session later. Do not end the session here
***************
*** 3238,3244 ****
      fd = channel->ch_part[part].ch_fd;
      if (fd == INVALID_FD)
      {
! 	ch_errors(channel, "channel_read() called while %s part is closed",
  							    part_names[part]);
  	return;
      }
--- 3177,3183 ----
      fd = channel->ch_part[part].ch_fd;
      if (fd == INVALID_FD)
      {
! 	ch_error(channel, "channel_read() called while %s part is closed",
  							    part_names[part]);
  	return;
      }
***************
*** 3300,3306 ****
      char_u	*nl;
      readq_T	*node;
  
!     ch_logsn(channel, "Blocking %s read, timeout: %d msec",
  				    mode == MODE_RAW ? "RAW" : "NL", timeout);
  
      while (TRUE)
--- 3239,3245 ----
      char_u	*nl;
      readq_T	*node;
  
!     ch_log(channel, "Blocking %s read, timeout: %d msec",
  				    mode == MODE_RAW ? "RAW" : "NL", timeout);
  
      while (TRUE)
***************
*** 3359,3365 ****
  	}
      }
      if (log_fd != NULL)
! 	ch_logn(channel, "Returning %d bytes", (int)STRLEN(msg));
      return msg;
  }
  
--- 3298,3304 ----
  	}
      }
      if (log_fd != NULL)
! 	ch_log(channel, "Returning %d bytes", (int)STRLEN(msg));
      return msg;
  }
  
***************
*** 3591,3597 ****
      {
  	if (!channel->ch_error && fun != NULL)
  	{
! 	    ch_errors(channel, "%s(): write while not connected", fun);
  	    EMSG2(_("E630: %s(): write while not connected"), fun);
  	}
  	channel->ch_error = TRUE;
--- 3530,3536 ----
      {
  	if (!channel->ch_error && fun != NULL)
  	{
! 	    ch_error(channel, "%s(): write while not connected", fun);
  	    EMSG2(_("E630: %s(): write while not connected"), fun);
  	}
  	channel->ch_error = TRUE;
***************
*** 3616,3622 ****
      {
  	if (!channel->ch_error && fun != NULL)
  	{
! 	    ch_errors(channel, "%s(): write failed", fun);
  	    EMSG2(_("E631: %s(): write failed"), fun);
  	}
  	channel->ch_error = TRUE;
--- 3555,3561 ----
      {
  	if (!channel->ch_error && fun != NULL)
  	{
! 	    ch_error(channel, "%s(): write failed", fun);
  	    EMSG2(_("E631: %s(): write failed"), fun);
  	}
  	channel->ch_error = TRUE;
***************
*** 5089,5100 ****
  		ga_concat(&ga, (char_u *)"  ");
  	    ga_concat(&ga, (char_u *)argv[i]);
  	}
! 	ch_logs(NULL, "Starting job: %s", (char *)ga.ga_data);
  	ga_clear(&ga);
      }
      mch_job_start(argv, job, &opt);
  #else
!     ch_logs(NULL, "Starting job: %s", (char *)cmd);
      mch_job_start((char *)cmd, job, &opt);
  #endif
  
--- 5028,5039 ----
  		ga_concat(&ga, (char_u *)"  ");
  	    ga_concat(&ga, (char_u *)argv[i]);
  	}
! 	ch_log(NULL, "Starting job: %s", (char *)ga.ga_data);
  	ga_clear(&ga);
      }
      mch_job_start(argv, job, &opt);
  #else
!     ch_log(NULL, "Starting job: %s", (char *)cmd);
      mch_job_start((char *)cmd, job, &opt);
  #endif
  
***************
*** 5204,5210 ****
  	ch_log(job->jv_channel, "Job has already ended, job_stop() skipped");
  	return 0;
      }
!     ch_logs(job->jv_channel, "Stopping job with '%s'", (char *)arg);
      if (mch_stop_job(job, arg) == FAIL)
  	return 0;
  
--- 5143,5149 ----
  	ch_log(job->jv_channel, "Job has already ended, job_stop() skipped");
  	return 0;
      }
!     ch_log(job->jv_channel, "Stopping job with '%s'", (char *)arg);
      if (mch_stop_job(job, arg) == FAIL)
  	return 0;
  
*** ../vim-8.0.0847/src/message.c	2017-07-11 22:34:47.519932150 +0200
--- src/message.c	2017-08-03 14:43:43.481419808 +0200
***************
*** 171,180 ****
  
  #ifdef FEAT_JOB_CHANNEL
      if (emsg_to_channel_log)
-     {
  	/* Write message in the channel log. */
! 	ch_logs(NULL, "ERROR: %s", (char *)s);
!     }
  #endif
  
      /* When displaying keep_msg, don't let msg_start() free it, caller must do
--- 171,178 ----
  
  #ifdef FEAT_JOB_CHANNEL
      if (emsg_to_channel_log)
  	/* Write message in the channel log. */
! 	ch_log(NULL, "ERROR: %s", (char *)s);
  #endif
  
      /* When displaying keep_msg, don't let msg_start() free it, caller must do
***************
*** 667,673 ****
  		redir_write(s, -1);
  	    }
  #ifdef FEAT_JOB_CHANNEL
! 	    ch_logs(NULL, "ERROR: %s", (char *)s);
  #endif
  	    return TRUE;
  	}
--- 665,671 ----
  		redir_write(s, -1);
  	    }
  #ifdef FEAT_JOB_CHANNEL
! 	    ch_log(NULL, "ERROR: %s", (char *)s);
  #endif
  	    return TRUE;
  	}
***************
*** 5145,5151 ****
  		{
  		    if (str_l < str_m)
  		    {
! 			size_t avail = str_m-str_l;
  
  			vim_memset(str + str_l, '0',
  					     (size_t)zn > avail ? avail
--- 5143,5149 ----
  		{
  		    if (str_l < str_m)
  		    {
! 			size_t avail = str_m - str_l;
  
  			vim_memset(str + str_l, '0',
  					     (size_t)zn > avail ? avail
*** ../vim-8.0.0847/src/proto/channel.pro	2017-07-22 16:14:39.272915812 +0200
--- src/proto/channel.pro	2017-08-03 14:37:55.380002136 +0200
***************
*** 1,9 ****
  /* channel.c */
  void ch_logfile(char_u *fname, char_u *opt);
  int ch_log_active(void);
! void ch_log(channel_T *ch, char *msg);
! void ch_logn(channel_T *ch, char *msg, int nr);
! void ch_logs(channel_T *ch, char *msg, char *name);
  channel_T *add_channel(void);
  int has_any_channel(void);
  int channel_unref(channel_T *channel);
--- 1,7 ----
  /* channel.c */
  void ch_logfile(char_u *fname, char_u *opt);
  int ch_log_active(void);
! void ch_log(channel_T *ch, const char *fmt, ...);
  channel_T *add_channel(void);
  int has_any_channel(void);
  int channel_unref(channel_T *channel);
*** ../vim-8.0.0847/src/terminal.c	2017-08-03 13:51:02.384784816 +0200
--- src/terminal.c	2017-08-03 14:37:55.380002136 +0200
***************
*** 389,398 ****
  
      if (term->tl_vterm == NULL)
      {
! 	ch_logn(channel, "NOT writing %d bytes to terminal", (int)len);
  	return;
      }
!     ch_logn(channel, "writing %d bytes to terminal", (int)len);
      term_write_job_output(term, msg, len);
  
      if (!term->tl_terminal_mode)
--- 389,398 ----
  
      if (term->tl_vterm == NULL)
      {
! 	ch_log(channel, "NOT writing %d bytes to terminal", (int)len);
  	return;
      }
!     ch_log(channel, "writing %d bytes to terminal", (int)len);
      term_write_job_output(term, msg, len);
  
      if (!term->tl_terminal_mode)
***************
*** 1475,1481 ****
  	}
  
  	vterm_set_size(vterm, rows, cols);
! 	ch_logn(term->tl_job->jv_channel, "Resizing terminal to %d lines",
  									 rows);
  	term_report_winsize(term, rows, cols);
      }
--- 1475,1481 ----
  	}
  
  	vterm_set_size(vterm, rows, cols);
! 	ch_log(term->tl_job->jv_channel, "Resizing terminal to %d lines",
  									 rows);
  	term_report_winsize(term, rows, cols);
      }
*** ../vim-8.0.0847/src/version.c	2017-08-03 14:29:09.895896191 +0200
--- src/version.c	2017-08-03 14:40:12.206986834 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     848,
  /**/

-- 
I'm sure that I asked CBuilder to do a "full" install.  Looks like I got
a "fool" install, instead.		Charles E Campbell, Jr, PhD


 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
