To: vim_dev@googlegroups.com
Subject: Patch 8.0.1245
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1245
Problem:    When WaitFor() has a wrong expression it just waits a second,
            which goes unnoticed. (James McCoy)
Solution:   When WaitFor() times out throw an exception.  Fix places where the
            expression was wrong.
Files:      src/testdir/shared.vim, src/testdir/test_channel.vim,
            src/testdir/test_netbeans.vim, src/testdir/test_terminal.vim


*** ../vim-8.0.1244/src/testdir/shared.vim	2017-10-07 20:03:19.323835305 +0200
--- src/testdir/shared.vim	2017-11-02 16:24:57.703180540 +0100
***************
*** 139,145 ****
      endif
      sleep 10m
    endfor
!   return timeout
  endfunc
  
  " Wait for up to a given milliseconds.
--- 139,145 ----
      endif
      sleep 10m
    endfor
!   throw 'WaitFor() timed out after ' . timeout . ' msec'
  endfunc
  
  " Wait for up to a given milliseconds.
*** ../vim-8.0.1244/src/testdir/test_channel.vim	2017-10-06 01:07:32.056360695 +0200
--- src/testdir/test_channel.vim	2017-11-02 16:50:08.030199053 +0100
***************
*** 709,715 ****
      call ch_sendraw(handle, "double this\n")
      call ch_sendraw(handle, "quit\n")
      sp pipe-output
!     call WaitFor('line("$") >= 6 && g:Ch_bufClosed == "yes"')
      call assert_equal(expected, getline(1, '$'))
      if a:nomod
        call assert_equal(0, &modifiable)
--- 709,715 ----
      call ch_sendraw(handle, "double this\n")
      call ch_sendraw(handle, "quit\n")
      sp pipe-output
!     call WaitFor('line("$") == ' . len(expected) . ' && g:Ch_bufClosed == "yes"')
      call assert_equal(expected, getline(1, '$'))
      if a:nomod
        call assert_equal(0, &modifiable)
***************
*** 804,810 ****
      call ch_sendraw(handle, "doubleerr this\n")
      call ch_sendraw(handle, "quit\n")
      sp pipe-err
!     call WaitFor('line("$") >= 5')
      call assert_equal(expected, getline(1, '$'))
      if a:nomod
        call assert_equal(0, &modifiable)
--- 804,810 ----
      call ch_sendraw(handle, "doubleerr this\n")
      call ch_sendraw(handle, "quit\n")
      sp pipe-err
!     call WaitFor('line("$") == ' . len(expected))
      call assert_equal(expected, getline(1, '$'))
      if a:nomod
        call assert_equal(0, &modifiable)
***************
*** 1130,1141 ****
    let job = job_start([s:python, '-c', 
          \ 'import sys; [sys.stdout.write(".") and sys.stdout.flush() for _ in range(10000)]'], options)
    call assert_equal("run", job_status(job))
!   call WaitFor('len(join(getline(2,line("$")),"") >= 10000')
    try
!     for line in getline(2, '$')
!       let line = substitute(line, '^\.*', '', '')
!       call assert_equal('', line)
      endfor
    finally
      call job_stop(job)
      bwipe!
--- 1130,1143 ----
    let job = job_start([s:python, '-c', 
          \ 'import sys; [sys.stdout.write(".") and sys.stdout.flush() for _ in range(10000)]'], options)
    call assert_equal("run", job_status(job))
!   call WaitFor('len(join(getline(1, "$"), "")) >= 10000', 3000)
    try
!     let totlen = 0
!     for line in getline(1, '$')
!       call assert_equal('', substitute(line, '^\.*', '', ''))
!       let totlen += len(line)
      endfor
+     call assert_equal(10000, totlen)
    finally
      call job_stop(job)
      bwipe!
***************
*** 1300,1323 ****
    endif
    call ch_log('Test_close_and_exit_cb')
  
!   let dict = {'ret': {}}
!   func dict.close_cb(ch) dict
      let self.ret['close_cb'] = job_status(ch_getjob(a:ch))
    endfunc
!   func dict.exit_cb(job, status) dict
      let self.ret['exit_cb'] = job_status(a:job)
    endfunc
  
    let g:job = job_start('echo', {
!         \ 'close_cb': dict.close_cb,
!         \ 'exit_cb': dict.exit_cb,
          \ })
    call assert_equal('run', job_status(g:job))
    unlet g:job
!   call WaitFor('len(dict.ret) >= 2')
!   call assert_equal(2, len(dict.ret))
!   call assert_match('^\%(dead\|run\)', dict.ret['close_cb'])
!   call assert_equal('dead', dict.ret['exit_cb'])
  endfunc
  
  """"""""""
--- 1302,1326 ----
    endif
    call ch_log('Test_close_and_exit_cb')
  
!   let g:retdict = {'ret': {}}
!   func g:retdict.close_cb(ch) dict
      let self.ret['close_cb'] = job_status(ch_getjob(a:ch))
    endfunc
!   func g:retdict.exit_cb(job, status) dict
      let self.ret['exit_cb'] = job_status(a:job)
    endfunc
  
    let g:job = job_start('echo', {
!         \ 'close_cb': g:retdict.close_cb,
!         \ 'exit_cb': g:retdict.exit_cb,
          \ })
    call assert_equal('run', job_status(g:job))
    unlet g:job
!   call WaitFor('len(g:retdict.ret) >= 2')
!   call assert_equal(2, len(g:retdict.ret))
!   call assert_match('^\%(dead\|run\)', g:retdict.ret['close_cb'])
!   call assert_equal('dead', g:retdict.ret['exit_cb'])
!   unlet g:retdict
  endfunc
  
  """"""""""
***************
*** 1547,1559 ****
      return
    endif
  
!   let job = job_start([s:python, '-c', 'import time;time.sleep(10)'])
    try
!     call job_stop(job)
!     call WaitFor('"dead" == job_status(job)')
!     call assert_equal('dead', job_status(job))
    finally
!     call job_stop(job, 'kill')
    endtry
  endfunc
  
--- 1550,1563 ----
      return
    endif
  
!   let g:job = job_start([s:python, '-c', 'import time;time.sleep(10)'])
    try
!     call job_stop(g:job)
!     call WaitFor('"dead" == job_status(g:job)')
!     call assert_equal('dead', job_status(g:job))
    finally
!     call job_stop(g:job, 'kill')
!     unlet g:job
    endtry
  endfunc
  
***************
*** 1585,1591 ****
    split testout
    1,$delete
    call job_start('cat test_channel.vim', {'out_io': 'buffer', 'out_name': 'testout'})
!   call WaitFor('line("$") > g:linecount')
    call assert_inrange(g:linecount, g:linecount + 1, line('$'))
    bwipe!
  endfunc
--- 1589,1595 ----
    split testout
    1,$delete
    call job_start('cat test_channel.vim', {'out_io': 'buffer', 'out_name': 'testout'})
!   call WaitFor('line("$") >= g:linecount')
    call assert_inrange(g:linecount, g:linecount + 1, line('$'))
    bwipe!
  endfunc
*** ../vim-8.0.1244/src/testdir/test_netbeans.vim	2016-10-09 15:43:22.455026647 +0200
--- src/testdir/test_netbeans.vim	2017-11-02 16:51:28.337734457 +0100
***************
*** 27,33 ****
  
    " Opening README.txt will result in a setDot command
    call WaitFor('len(readfile("Xnetbeans")) > 4')
!   call WaitFor('getcurpos()[1] == 2')
    let pos = getcurpos()
    call assert_equal(3, pos[1])
    call assert_equal(20, pos[2])
--- 27,33 ----
  
    " Opening README.txt will result in a setDot command
    call WaitFor('len(readfile("Xnetbeans")) > 4')
!   call WaitFor('getcurpos()[1] == 3')
    let pos = getcurpos()
    call assert_equal(3, pos[1])
    call assert_equal(20, pos[2])
*** ../vim-8.0.1244/src/testdir/test_terminal.vim	2017-10-30 21:56:18.619439283 +0100
--- src/testdir/test_terminal.vim	2017-11-02 16:52:50.689257703 +0100
***************
*** 705,711 ****
  
    enew
    let buf = term_start(cmd, {'curwin': bufnr('')})
!   let job = term_getjob(buf)
    call term_wait(buf, 50)
  
    " ascii + composing
--- 705,711 ----
  
    enew
    let buf = term_start(cmd, {'curwin': bufnr('')})
!   let g:job = term_getjob(buf)
    call term_wait(buf, 50)
  
    " ascii + composing
***************
*** 742,749 ****
    call assert_equal("\u00a0\u0308", l[3].chars)
  
    call term_sendkeys(buf, "exit\r")
!   call WaitFor('job_status(job) == "dead"')
!   call assert_equal('dead', job_status(job))
    bwipe!
    let &encoding = save_enc
  endfunc
--- 742,750 ----
    call assert_equal("\u00a0\u0308", l[3].chars)
  
    call term_sendkeys(buf, "exit\r")
!   call WaitFor('job_status(g:job) == "dead"')
!   call assert_equal('dead', job_status(g:job))
    bwipe!
+   unlet g:job
    let &encoding = save_enc
  endfunc
*** ../vim-8.0.1244/src/version.c	2017-11-02 16:16:23.286239622 +0100
--- src/version.c	2017-11-02 16:28:54.605768505 +0100
***************
*** 763,764 ****
--- 763,766 ----
  {   /* Add new patch number below this line */
+ /**/
+     1245,
  /**/

-- 
BEDEVERE: How do you know so much about swallows?
ARTHUR:   Well you have to know these things when you're a king, you know.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
