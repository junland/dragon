To: vim_dev@googlegroups.com
Subject: Patch 8.0.0520
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0520
Problem:    Using a function pointer instead of the actual function, which we
            know.
Solution:   Change mb_ functions to utf_ functions when already checked for
            Unicode. (Dominique Pelle, closes #1582)
Files:      src/message.c, src/misc2.c, src/regexp.c, src/regexp_nfa.c,
            src/screen.c, src/spell.c


*** ../vim-8.0.0519/src/message.c	2017-03-16 19:58:19.416253412 +0100
--- src/message.c	2017-03-29 17:29:30.108452015 +0200
***************
*** 315,321 ****
  	for (;;)
  	{
  	    do
! 		half = half - (*mb_head_off)(s, s + half - 1) - 1;
  	    while (half > 0 && utf_iscomposing(utf_ptr2char(s + half)));
  	    n = ptr2cells(s + half);
  	    if (len + n > room || half == 0)
--- 315,321 ----
  	for (;;)
  	{
  	    do
! 		half = half - utf_head_off(s, s + half - 1) - 1;
  	    while (half > 0 && utf_iscomposing(utf_ptr2char(s + half)));
  	    n = ptr2cells(s + half);
  	    if (len + n > room || half == 0)
*** ../vim-8.0.0519/src/misc2.c	2017-03-19 21:36:52.825933116 +0100
--- src/misc2.c	2017-03-29 17:21:00.895473402 +0200
***************
*** 1874,1880 ****
      {
  	while (*p != NUL)
  	{
! 	    int l = (*mb_ptr2len)(p);
  
  	    /* Avoid matching an illegal byte here. */
  	    if (utf_ptr2char(p) == c && l > 1)
--- 1874,1880 ----
      {
  	while (*p != NUL)
  	{
! 	    int l = utfc_ptr2len(p);
  
  	    /* Avoid matching an illegal byte here. */
  	    if (utf_ptr2char(p) == c && l > 1)
*** ../vim-8.0.0519/src/regexp.c	2017-03-29 15:31:15.031397364 +0200
--- src/regexp.c	2017-03-29 17:21:00.895473402 +0200
***************
*** 4732,4738 ****
  		    break;
  		}
  		if (enc_utf8)
! 		    opndc = mb_ptr2char(opnd);
  		if (enc_utf8 && utf_iscomposing(opndc))
  		{
  		    /* When only a composing char is given match at any
--- 4732,4738 ----
  		    break;
  		}
  		if (enc_utf8)
! 		    opndc = utf_ptr2char(opnd);
  		if (enc_utf8 && utf_iscomposing(opndc))
  		{
  		    /* When only a composing char is given match at any
***************
*** 4741,4747 ****
  		    for (i = 0; reginput[i] != NUL;
  						i += utf_ptr2len(reginput + i))
  		    {
! 			inpc = mb_ptr2char(reginput + i);
  			if (!utf_iscomposing(inpc))
  			{
  			    if (i > 0)
--- 4741,4747 ----
  		    for (i = 0; reginput[i] != NUL;
  						i += utf_ptr2len(reginput + i))
  		    {
! 			inpc = utf_ptr2char(reginput + i);
  			if (!utf_iscomposing(inpc))
  			{
  			    if (i > 0)
***************
*** 4750,4756 ****
  			else if (opndc == inpc)
  			{
  			    /* Include all following composing chars. */
! 			    len = i + mb_ptr2len(reginput + i);
  			    status = RA_MATCH;
  			    break;
  			}
--- 4750,4756 ----
  			else if (opndc == inpc)
  			{
  			    /* Include all following composing chars. */
! 			    len = i + utfc_ptr2len(reginput + i);
  			    status = RA_MATCH;
  			    break;
  			}
*** ../vim-8.0.0519/src/regexp_nfa.c	2017-03-29 15:31:15.031397364 +0200
--- src/regexp_nfa.c	2017-03-29 17:21:00.899473378 +0200
***************
*** 1974,1980 ****
  nfa_do_multibyte:
  		/* plen is length of current char with composing chars */
  		if (enc_utf8 && ((*mb_char2len)(c)
! 			    != (plen = (*mb_ptr2len)(old_regparse))
  						       || utf_iscomposing(c)))
  		{
  		    int i = 0;
--- 1974,1980 ----
  nfa_do_multibyte:
  		/* plen is length of current char with composing chars */
  		if (enc_utf8 && ((*mb_char2len)(c)
! 			    != (plen = utfc_ptr2len(old_regparse))
  						       || utf_iscomposing(c)))
  		{
  		    int i = 0;
*** ../vim-8.0.0519/src/screen.c	2017-03-29 14:40:38.342357669 +0200
--- src/screen.c	2017-03-29 17:21:00.899473378 +0200
***************
*** 4119,4125 ****
  		c = c_extra;
  #ifdef FEAT_MBYTE
  		mb_c = c;	/* doesn't handle non-utf-8 multi-byte! */
! 		if (enc_utf8 && (*mb_char2len)(c) > 1)
  		{
  		    mb_utf8 = TRUE;
  		    u8cc[0] = 0;
--- 4119,4125 ----
  		c = c_extra;
  #ifdef FEAT_MBYTE
  		mb_c = c;	/* doesn't handle non-utf-8 multi-byte! */
! 		if (enc_utf8 && utf_char2len(c) > 1)
  		{
  		    mb_utf8 = TRUE;
  		    u8cc[0] = 0;
***************
*** 4140,4146 ****
  		    {
  			/* If the UTF-8 character is more than one byte:
  			 * Decode it into "mb_c". */
! 			mb_l = (*mb_ptr2len)(p_extra);
  			mb_utf8 = FALSE;
  			if (mb_l > n_extra)
  			    mb_l = 1;
--- 4140,4146 ----
  		    {
  			/* If the UTF-8 character is more than one byte:
  			 * Decode it into "mb_c". */
! 			mb_l = utfc_ptr2len(p_extra);
  			mb_utf8 = FALSE;
  			if (mb_l > n_extra)
  			    mb_l = 1;
***************
*** 4219,4225 ****
  		{
  		    /* If the UTF-8 character is more than one byte: Decode it
  		     * into "mb_c". */
! 		    mb_l = (*mb_ptr2len)(ptr);
  		    mb_utf8 = FALSE;
  		    if (mb_l > 1)
  		    {
--- 4219,4225 ----
  		{
  		    /* If the UTF-8 character is more than one byte: Decode it
  		     * into "mb_c". */
! 		    mb_l = utfc_ptr2len(ptr);
  		    mb_utf8 = FALSE;
  		    if (mb_l > 1)
  		    {
***************
*** 4612,4618 ****
  		    }
  #ifdef FEAT_MBYTE
  		    mb_c = c;
! 		    if (enc_utf8 && (*mb_char2len)(c) > 1)
  		    {
  			mb_utf8 = TRUE;
  			u8cc[0] = 0;
--- 4612,4618 ----
  		    }
  #ifdef FEAT_MBYTE
  		    mb_c = c;
! 		    if (enc_utf8 && utf_char2len(c) > 1)
  		    {
  			mb_utf8 = TRUE;
  			u8cc[0] = 0;
***************
*** 4634,4640 ****
  		    }
  #ifdef FEAT_MBYTE
  		    mb_c = c;
! 		    if (enc_utf8 && (*mb_char2len)(c) > 1)
  		    {
  			mb_utf8 = TRUE;
  			u8cc[0] = 0;
--- 4634,4640 ----
  		    }
  #ifdef FEAT_MBYTE
  		    mb_c = c;
! 		    if (enc_utf8 && utf_char2len(c) > 1)
  		    {
  			mb_utf8 = TRUE;
  			u8cc[0] = 0;
***************
*** 4765,4771 ****
  			saved_attr2 = char_attr; /* save current attr */
  #ifdef FEAT_MBYTE
  			mb_c = c;
! 			if (enc_utf8 && (*mb_char2len)(c) > 1)
  			{
  			    mb_utf8 = TRUE;
  			    u8cc[0] = 0;
--- 4765,4771 ----
  			saved_attr2 = char_attr; /* save current attr */
  #ifdef FEAT_MBYTE
  			mb_c = c;
! 			if (enc_utf8 && utf_char2len(c) > 1)
  			{
  			    mb_utf8 = TRUE;
  			    u8cc[0] = 0;
***************
*** 4839,4845 ****
  		    }
  #ifdef FEAT_MBYTE
  		    mb_c = c;
! 		    if (enc_utf8 && (*mb_char2len)(c) > 1)
  		    {
  			mb_utf8 = TRUE;
  			u8cc[0] = 0;
--- 4839,4845 ----
  		    }
  #ifdef FEAT_MBYTE
  		    mb_c = c;
! 		    if (enc_utf8 && utf_char2len(c) > 1)
  		    {
  			mb_utf8 = TRUE;
  			u8cc[0] = 0;
***************
*** 5003,5009 ****
  		}
  # ifdef FEAT_MBYTE
  		mb_c = c;
! 		if (enc_utf8 && (*mb_char2len)(c) > 1)
  		{
  		    mb_utf8 = TRUE;
  		    u8cc[0] = 0;
--- 5003,5009 ----
  		}
  # ifdef FEAT_MBYTE
  		mb_c = c;
! 		if (enc_utf8 && utf_char2len(c) > 1)
  		{
  		    mb_utf8 = TRUE;
  		    u8cc[0] = 0;
***************
*** 5110,5116 ****
  		extra_attr = HL_ATTR(HLF_AT);
  	    }
  	    mb_c = c;
! 	    if (enc_utf8 && (*mb_char2len)(c) > 1)
  	    {
  		mb_utf8 = TRUE;
  		u8cc[0] = 0;
--- 5110,5116 ----
  		extra_attr = HL_ATTR(HLF_AT);
  	    }
  	    mb_c = c;
! 	    if (enc_utf8 && utf_char2len(c) > 1)
  	    {
  		mb_utf8 = TRUE;
  		u8cc[0] = 0;
***************
*** 5383,5389 ****
  	    char_attr = HL_ATTR(HLF_AT);
  #ifdef FEAT_MBYTE
  	    mb_c = c;
! 	    if (enc_utf8 && (*mb_char2len)(c) > 1)
  	    {
  		mb_utf8 = TRUE;
  		u8cc[0] = 0;
--- 5383,5389 ----
  	    char_attr = HL_ATTR(HLF_AT);
  #ifdef FEAT_MBYTE
  	    mb_c = c;
! 	    if (enc_utf8 && utf_char2len(c) > 1)
  	    {
  		mb_utf8 = TRUE;
  		u8cc[0] = 0;
*** ../vim-8.0.0519/src/spell.c	2017-03-12 20:09:59.492468205 +0100
--- src/spell.c	2017-03-29 17:21:00.903473354 +0200
***************
*** 1208,1214 ****
  	/* Need to convert the single byte flags to utf8 characters. */
  	p = uflags;
  	for (i = 0; flags[i] != NUL; ++i)
! 	    p += mb_char2bytes(flags[i], p);
  	*p = NUL;
  	p = uflags;
      }
--- 1208,1214 ----
  	/* Need to convert the single byte flags to utf8 characters. */
  	p = uflags;
  	for (i = 0; flags[i] != NUL; ++i)
! 	    p += utf_char2bytes(flags[i], p);
  	*p = NUL;
  	p = uflags;
      }
***************
*** 5117,5127 ****
  				 * SCORE_SUBCOMP. */
  				if (enc_utf8
  					&& utf_iscomposing(
! 					    mb_ptr2char(tword
  						+ sp->ts_twordlen
  							   - sp->ts_tcharlen))
  					&& utf_iscomposing(
! 					    mb_ptr2char(fword
  							+ sp->ts_fcharstart)))
  				    sp->ts_score -=
  						  SCORE_SUBST - SCORE_SUBCOMP;
--- 5117,5127 ----
  				 * SCORE_SUBCOMP. */
  				if (enc_utf8
  					&& utf_iscomposing(
! 					    utf_ptr2char(tword
  						+ sp->ts_twordlen
  							   - sp->ts_tcharlen))
  					&& utf_iscomposing(
! 					    utf_ptr2char(fword
  							+ sp->ts_fcharstart)))
  				    sp->ts_score -=
  						  SCORE_SUBST - SCORE_SUBCOMP;
*** ../vim-8.0.0519/src/version.c	2017-03-29 15:31:15.035397340 +0200
--- src/version.c	2017-03-29 17:23:02.806750569 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     520,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
232. You start conversations with, "Have you gotten an ISDN line?"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
