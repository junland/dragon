To: vim_dev@googlegroups.com
Subject: Patch 8.0.0591
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0591
Problem:    Changes to eval functionality not documented.
Solution:   Include all the changes.
Files:      runtime/doc/eval.txt


*** ../vim-8.0.0590/runtime/doc/eval.txt	2017-04-22 21:20:42.355092203 +0200
--- runtime/doc/eval.txt	2017-04-30 13:59:57.946287189 +0200
***************
*** 1329,1335 ****
  		    :	let my_changedtick = b:changedtick
  		    :	call My_Update()
  		    :endif
! <
  						*window-variable* *w:var* *w:*
  A variable name that is preceded with "w:" is local to the current window.  It
  is deleted when the window is closed.
--- 1329,1336 ----
  		    :	let my_changedtick = b:changedtick
  		    :	call My_Update()
  		    :endif
! <		You cannot change or delete the b:changedtick variable.
! 
  						*window-variable* *w:var* *w:*
  A variable name that is preceded with "w:" is local to the current window.  It
  is deleted when the window is closed.
***************
*** 1903,1908 ****
--- 1904,1911 ----
  
  					*v:testing* *testing-variable*
  v:testing	Must be set before using `test_garbagecollect_now()`.
+ 		Also, when set certain error messages won't be shown for 2
+ 		seconds. (e.g. "'dictionary' option is empty") 
  
  				*v:this_session* *this_session-variable*
  v:this_session	Full filename of the last loaded or saved session file.  See
***************
*** 2233,2240 ****
  				String	{count}'th match of {pat} in {expr}
  matchstrpos({expr}, {pat}[, {start}[, {count}]])
  				List	{count}'th match of {pat} in {expr}
! max({list})			Number	maximum value of items in {list}
! min({list})			Number	minimum value of items in {list}
  mkdir({name} [, {path} [, {prot}]])
  				Number	create directory {name}
  mode([expr])			String	current editing mode
--- 2236,2243 ----
  				String	{count}'th match of {pat} in {expr}
  matchstrpos({expr}, {pat}[, {start}[, {count}]])
  				List	{count}'th match of {pat} in {expr}
! max({expr})			Number	maximum value of items in {expr}
! min({expr})			Number	minimum value of items in {expr}
  mkdir({name} [, {path} [, {prot}]])
  				Number	create directory {name}
  mode([expr])			String	current editing mode
***************
*** 2258,2269 ****
  reltime([{start} [, {end}]])	List	get time value
  reltimefloat({time})		Float	turn the time value into a Float
  reltimestr({time})		String	turn time value into a String
! remote_expr({server}, {string} [, {idvar}])
  				String	send expression
  remote_foreground({server})	Number	bring Vim server to the foreground
  remote_peek({serverid} [, {retvar}])
  				Number	check for reply string
! remote_read({serverid})		String	read reply string
  remote_send({server}, {string} [, {idvar}])
  				String	send key sequence
  remote_startserver({name})	none	become server {name}
--- 2261,2273 ----
  reltime([{start} [, {end}]])	List	get time value
  reltimefloat({time})		Float	turn the time value into a Float
  reltimestr({time})		String	turn time value into a String
! remote_expr({server}, {string} [, {idvar} [, {timeout}]])
  				String	send expression
  remote_foreground({server})	Number	bring Vim server to the foreground
  remote_peek({serverid} [, {retvar}])
  				Number	check for reply string
! remote_read({serverid} [, {timeout}])
! 				String	read reply string
  remote_send({server}, {string} [, {idvar}])
  				String	send key sequence
  remote_startserver({name})	none	become server {name}
***************
*** 2634,2642 ****
  <			2.356194
  		{only available when compiled with the |+float| feature}
  
! balloon_show({msg})                                     *balloon_show()*
!                 Show {msg} inside the balloon.
!                 Example: >
  			func GetBalloonContent()
  			   " initiate getting the content
  			   return ''
--- 2638,2646 ----
  <			2.356194
  		{only available when compiled with the |+float| feature}
  
! balloon_show({msg})					*balloon_show()*
! 		Show {msg} inside the balloon.
! 		Example: >
  			func GetBalloonContent()
  			   " initiate getting the content
  			   return ''
***************
*** 2644,2650 ****
  			set balloonexpr=GetBalloonContent()
  
  			func BalloonCallback(result)
!                           call balloon_show(a:result)
  			endfunc
  <
  		The intended use is that fetching the content of the balloon
--- 2648,2654 ----
  			set balloonexpr=GetBalloonContent()
  
  			func BalloonCallback(result)
! 			  call balloon_show(a:result)
  			endfunc
  <
  		The intended use is that fetching the content of the balloon
***************
*** 2652,2658 ****
  		asynchronous method, in which a callback invokes
  		balloon_show().  The 'balloonexpr' itself can return an
  		empty string or a placeholder.
!                 {only available when compiled with the +beval feature}
  
  							*browse()*
  browse({save}, {title}, {initdir}, {default})
--- 2656,2665 ----
  		asynchronous method, in which a callback invokes
  		balloon_show().  The 'balloonexpr' itself can return an
  		empty string or a placeholder.
! 
! 		When showing a balloon is not possible nothing happens, no
! 		error message.
! 		{only available when compiled with the +balloon_eval feature}
  
  							*browse()*
  browse({save}, {title}, {initdir}, {default})
***************
*** 2848,3023 ****
  <			4.0
  		{only available when compiled with the |+float| feature}
  
- changenr()						*changenr()*
- 		Return the number of the most recent change.  This is the same
- 		number as what is displayed with |:undolist| and can be used
- 		with the |:undo| command.
- 		When a change was made it is the number of that change.  After
- 		redo it is the number of the redone change.  After undo it is
- 		one less than the number of the undone change.
- 
- char2nr({expr}[, {utf8}])					*char2nr()*
- 		Return number value of the first char in {expr}.  Examples: >
- 			char2nr(" ")		returns 32
- 			char2nr("ABC")		returns 65
- <		When {utf8} is omitted or zero, the current 'encoding' is used.
- 		Example for "utf-8": >
- 			char2nr("치")		returns 225
- 			char2nr("치"[0])		returns 195
- <		With {utf8} set to 1, always treat as utf-8 characters.
- 		A combining character is a separate character.
- 		|nr2char()| does the opposite.
- 
- cindent({lnum})						*cindent()*
- 		Get the amount of indent for line {lnum} according the C
- 		indenting rules, as with 'cindent'.
- 		The indent is counted in spaces, the value of 'tabstop' is
- 		relevant.  {lnum} is used just like in |getline()|.
- 		When {lnum} is invalid or Vim was not compiled the |+cindent|
- 		feature, -1 is returned.
- 		See |C-indenting|.
- 
- clearmatches()						*clearmatches()*
- 		Clears all matches previously defined by |matchadd()| and the
- 		|:match| commands.
- 
- 							*col()*
- col({expr})	The result is a Number, which is the byte index of the column
- 		position given with {expr}.  The accepted positions are:
- 		    .	    the cursor position
- 		    $	    the end of the cursor line (the result is the
- 			    number of bytes in the cursor line plus one)
- 		    'x	    position of mark x (if the mark is not set, 0 is
- 			    returned)
- 		    v       In Visual mode: the start of the Visual area (the
- 			    cursor is the end).  When not in Visual mode
- 			    returns the cursor position.  Differs from |'<| in
- 			    that it's updated right away.
- 		Additionally {expr} can be [lnum, col]: a |List| with the line
- 		and column number. Most useful when the column is "$", to get
- 		the last column of a specific line.  When "lnum" or "col" is
- 		out of range then col() returns zero.
- 		To get the line number use |line()|.  To get both use
- 		|getpos()|.
- 		For the screen column position use |virtcol()|.
- 		Note that only marks in the current file can be used.
- 		Examples: >
- 			col(".")		column of cursor
- 			col("$")		length of cursor line plus one
- 			col("'t")		column of mark t
- 			col("'" . markname)	column of mark markname
- <		The first column is 1.  0 is returned for an error.
- 		For an uppercase mark the column may actually be in another
- 		buffer.
- 		For the cursor position, when 'virtualedit' is active, the
- 		column is one higher if the cursor is after the end of the
- 		line.  This can be used to obtain the column in Insert mode: >
- 			:imap <F2> <C-O>:let save_ve = &ve<CR>
- 				\<C-O>:set ve=all<CR>
- 				\<C-O>:echo col(".") . "\n" <Bar>
- 				\let &ve = save_ve<CR>
- <
- 
- complete({startcol}, {matches})			*complete()* *E785*
- 		Set the matches for Insert mode completion.
- 		Can only be used in Insert mode.  You need to use a mapping
- 		with CTRL-R = (see |i_CTRL-R|).  It does not work after CTRL-O
- 		or with an expression mapping.
- 		{startcol} is the byte offset in the line where the completed
- 		text start.  The text up to the cursor is the original text
- 		that will be replaced by the matches.  Use col('.') for an
- 		empty string.  "col('.') - 1" will replace one character by a
- 		match.
- 		{matches} must be a |List|.  Each |List| item is one match.
- 		See |complete-items| for the kind of items that are possible.
- 		Note that the after calling this function you need to avoid
- 		inserting anything that would cause completion to stop.
- 		The match can be selected with CTRL-N and CTRL-P as usual with
- 		Insert mode completion.  The popup menu will appear if
- 		specified, see |ins-completion-menu|.
- 		Example: >
- 	inoremap <F5> <C-R>=ListMonths()<CR>
- 
- 	func! ListMonths()
- 	  call complete(col('.'), ['January', 'February', 'March',
- 		\ 'April', 'May', 'June', 'July', 'August', 'September',
- 		\ 'October', 'November', 'December'])
- 	  return ''
- 	endfunc
- <		This isn't very useful, but it shows how it works.  Note that
- 		an empty string is returned to avoid a zero being inserted.
- 
- complete_add({expr})				*complete_add()*
- 		Add {expr} to the list of matches.  Only to be used by the
- 		function specified with the 'completefunc' option.
- 		Returns 0 for failure (empty string or out of memory),
- 		1 when the match was added, 2 when the match was already in
- 		the list.
- 		See |complete-functions| for an explanation of {expr}.  It is
- 		the same as one item in the list that 'omnifunc' would return.
- 
- complete_check()				*complete_check()*
- 		Check for a key typed while looking for completion matches.
- 		This is to be used when looking for matches takes some time.
- 		Returns |TRUE| when searching for matches is to be aborted,
- 		zero otherwise.
- 		Only to be used by the function specified with the
- 		'completefunc' option.
- 
- 						*confirm()*
- confirm({msg} [, {choices} [, {default} [, {type}]]])
- 		Confirm() offers the user a dialog, from which a choice can be
- 		made.  It returns the number of the choice.  For the first
- 		choice this is 1.
- 		Note: confirm() is only supported when compiled with dialog
- 		support, see |+dialog_con| and |+dialog_gui|.
- 
- 		{msg} is displayed in a |dialog| with {choices} as the
- 		alternatives.  When {choices} is missing or empty, "&OK" is
- 		used (and translated).
- 		{msg} is a String, use '\n' to include a newline.  Only on
- 		some systems the string is wrapped when it doesn't fit.
- 
- 		{choices} is a String, with the individual choices separated
- 		by '\n', e.g. >
- 			confirm("Save changes?", "&Yes\n&No\n&Cancel")
- <		The letter after the '&' is the shortcut key for that choice.
- 		Thus you can type 'c' to select "Cancel".  The shortcut does
- 		not need to be the first letter: >
- 			confirm("file has been modified", "&Save\nSave &All")
- <		For the console, the first letter of each choice is used as
- 		the default shortcut key.
- 
- 		The optional {default} argument is the number of the choice
- 		that is made if the user hits <CR>.  Use 1 to make the first
- 		choice the default one.  Use 0 to not set a default.  If
- 		{default} is omitted, 1 is used.
- 
- 		The optional {type} argument gives the type of dialog.  This
- 		is only used for the icon of the GTK, Mac, Motif and Win32
- 		GUI.  It can be one of these values: "Error", "Question",
- 		"Info", "Warning" or "Generic".  Only the first character is
- 		relevant.  When {type} is omitted, "Generic" is used.
- 
- 		If the user aborts the dialog by pressing <Esc>, CTRL-C,
- 		or another valid interrupt key, confirm() returns 0.
- 
- 		An example: >
-    :let choice = confirm("What do you want?", "&Apples\n&Oranges\n&Bananas", 2)
-    :if choice == 0
-    :	echo "make up your mind!"
-    :elseif choice == 3
-    :	echo "tasteful"
-    :else
-    :	echo "I prefer bananas myself."
-    :endif
- <		In a GUI dialog, buttons are used.  The layout of the buttons
- 		depends on the 'v' flag in 'guioptions'.  If it is included,
- 		the buttons are always put vertically.  Otherwise,  confirm()
- 		tries to put the buttons in one horizontal line.  If they
- 		don't fit, a vertical layout is used anyway.  For some systems
- 		the horizontal layout is always used.
- 
  ch_canread({handle})						*ch_canread()*
  		Return non-zero when there is something to read from {handle}.
  		{handle} can be a Channel or a Job that has a Channel.
--- 2855,2860 ----
***************
*** 3121,3127 ****
  		|ch_logfile()|.
  		When {handle} is passed the channel number is used for the
  		message.
! 		{handle} can be Channel or a Job that has a Channel.  The
  		Channel must be open for the channel number to be used.
  
  ch_logfile({fname} [, {mode}])					*ch_logfile()*
--- 2958,2964 ----
  		|ch_logfile()|.
  		When {handle} is passed the channel number is used for the
  		message.
! 		{handle} can be a Channel or a Job that has a Channel.  The
  		Channel must be open for the channel number to be used.
  
  ch_logfile({fname} [, {mode}])					*ch_logfile()*
***************
*** 3207,3212 ****
--- 3044,3219 ----
  		"err".  For example, to get the error status: >
  			ch_status(job, {"part": "err"})
  <
+ changenr()						*changenr()*
+ 		Return the number of the most recent change.  This is the same
+ 		number as what is displayed with |:undolist| and can be used
+ 		with the |:undo| command.
+ 		When a change was made it is the number of that change.  After
+ 		redo it is the number of the redone change.  After undo it is
+ 		one less than the number of the undone change.
+ 
+ char2nr({expr}[, {utf8}])					*char2nr()*
+ 		Return number value of the first char in {expr}.  Examples: >
+ 			char2nr(" ")		returns 32
+ 			char2nr("ABC")		returns 65
+ <		When {utf8} is omitted or zero, the current 'encoding' is used.
+ 		Example for "utf-8": >
+ 			char2nr("치")		returns 225
+ 			char2nr("치"[0])		returns 195
+ <		With {utf8} set to 1, always treat as utf-8 characters.
+ 		A combining character is a separate character.
+ 		|nr2char()| does the opposite.
+ 
+ cindent({lnum})						*cindent()*
+ 		Get the amount of indent for line {lnum} according the C
+ 		indenting rules, as with 'cindent'.
+ 		The indent is counted in spaces, the value of 'tabstop' is
+ 		relevant.  {lnum} is used just like in |getline()|.
+ 		When {lnum} is invalid or Vim was not compiled the |+cindent|
+ 		feature, -1 is returned.
+ 		See |C-indenting|.
+ 
+ clearmatches()						*clearmatches()*
+ 		Clears all matches previously defined by |matchadd()| and the
+ 		|:match| commands.
+ 
+ 							*col()*
+ col({expr})	The result is a Number, which is the byte index of the column
+ 		position given with {expr}.  The accepted positions are:
+ 		    .	    the cursor position
+ 		    $	    the end of the cursor line (the result is the
+ 			    number of bytes in the cursor line plus one)
+ 		    'x	    position of mark x (if the mark is not set, 0 is
+ 			    returned)
+ 		    v       In Visual mode: the start of the Visual area (the
+ 			    cursor is the end).  When not in Visual mode
+ 			    returns the cursor position.  Differs from |'<| in
+ 			    that it's updated right away.
+ 		Additionally {expr} can be [lnum, col]: a |List| with the line
+ 		and column number. Most useful when the column is "$", to get
+ 		the last column of a specific line.  When "lnum" or "col" is
+ 		out of range then col() returns zero.
+ 		To get the line number use |line()|.  To get both use
+ 		|getpos()|.
+ 		For the screen column position use |virtcol()|.
+ 		Note that only marks in the current file can be used.
+ 		Examples: >
+ 			col(".")		column of cursor
+ 			col("$")		length of cursor line plus one
+ 			col("'t")		column of mark t
+ 			col("'" . markname)	column of mark markname
+ <		The first column is 1.  0 is returned for an error.
+ 		For an uppercase mark the column may actually be in another
+ 		buffer.
+ 		For the cursor position, when 'virtualedit' is active, the
+ 		column is one higher if the cursor is after the end of the
+ 		line.  This can be used to obtain the column in Insert mode: >
+ 			:imap <F2> <C-O>:let save_ve = &ve<CR>
+ 				\<C-O>:set ve=all<CR>
+ 				\<C-O>:echo col(".") . "\n" <Bar>
+ 				\let &ve = save_ve<CR>
+ <
+ 
+ complete({startcol}, {matches})			*complete()* *E785*
+ 		Set the matches for Insert mode completion.
+ 		Can only be used in Insert mode.  You need to use a mapping
+ 		with CTRL-R = (see |i_CTRL-R|).  It does not work after CTRL-O
+ 		or with an expression mapping.
+ 		{startcol} is the byte offset in the line where the completed
+ 		text start.  The text up to the cursor is the original text
+ 		that will be replaced by the matches.  Use col('.') for an
+ 		empty string.  "col('.') - 1" will replace one character by a
+ 		match.
+ 		{matches} must be a |List|.  Each |List| item is one match.
+ 		See |complete-items| for the kind of items that are possible.
+ 		Note that the after calling this function you need to avoid
+ 		inserting anything that would cause completion to stop.
+ 		The match can be selected with CTRL-N and CTRL-P as usual with
+ 		Insert mode completion.  The popup menu will appear if
+ 		specified, see |ins-completion-menu|.
+ 		Example: >
+ 	inoremap <F5> <C-R>=ListMonths()<CR>
+ 
+ 	func! ListMonths()
+ 	  call complete(col('.'), ['January', 'February', 'March',
+ 		\ 'April', 'May', 'June', 'July', 'August', 'September',
+ 		\ 'October', 'November', 'December'])
+ 	  return ''
+ 	endfunc
+ <		This isn't very useful, but it shows how it works.  Note that
+ 		an empty string is returned to avoid a zero being inserted.
+ 
+ complete_add({expr})				*complete_add()*
+ 		Add {expr} to the list of matches.  Only to be used by the
+ 		function specified with the 'completefunc' option.
+ 		Returns 0 for failure (empty string or out of memory),
+ 		1 when the match was added, 2 when the match was already in
+ 		the list.
+ 		See |complete-functions| for an explanation of {expr}.  It is
+ 		the same as one item in the list that 'omnifunc' would return.
+ 
+ complete_check()				*complete_check()*
+ 		Check for a key typed while looking for completion matches.
+ 		This is to be used when looking for matches takes some time.
+ 		Returns |TRUE| when searching for matches is to be aborted,
+ 		zero otherwise.
+ 		Only to be used by the function specified with the
+ 		'completefunc' option.
+ 
+ 						*confirm()*
+ confirm({msg} [, {choices} [, {default} [, {type}]]])
+ 		Confirm() offers the user a dialog, from which a choice can be
+ 		made.  It returns the number of the choice.  For the first
+ 		choice this is 1.
+ 		Note: confirm() is only supported when compiled with dialog
+ 		support, see |+dialog_con| and |+dialog_gui|.
+ 
+ 		{msg} is displayed in a |dialog| with {choices} as the
+ 		alternatives.  When {choices} is missing or empty, "&OK" is
+ 		used (and translated).
+ 		{msg} is a String, use '\n' to include a newline.  Only on
+ 		some systems the string is wrapped when it doesn't fit.
+ 
+ 		{choices} is a String, with the individual choices separated
+ 		by '\n', e.g. >
+ 			confirm("Save changes?", "&Yes\n&No\n&Cancel")
+ <		The letter after the '&' is the shortcut key for that choice.
+ 		Thus you can type 'c' to select "Cancel".  The shortcut does
+ 		not need to be the first letter: >
+ 			confirm("file has been modified", "&Save\nSave &All")
+ <		For the console, the first letter of each choice is used as
+ 		the default shortcut key.
+ 
+ 		The optional {default} argument is the number of the choice
+ 		that is made if the user hits <CR>.  Use 1 to make the first
+ 		choice the default one.  Use 0 to not set a default.  If
+ 		{default} is omitted, 1 is used.
+ 
+ 		The optional {type} argument gives the type of dialog.  This
+ 		is only used for the icon of the GTK, Mac, Motif and Win32
+ 		GUI.  It can be one of these values: "Error", "Question",
+ 		"Info", "Warning" or "Generic".  Only the first character is
+ 		relevant.  When {type} is omitted, "Generic" is used.
+ 
+ 		If the user aborts the dialog by pressing <Esc>, CTRL-C,
+ 		or another valid interrupt key, confirm() returns 0.
+ 
+ 		An example: >
+    :let choice = confirm("What do you want?", "&Apples\n&Oranges\n&Bananas", 2)
+    :if choice == 0
+    :	echo "make up your mind!"
+    :elseif choice == 3
+    :	echo "tasteful"
+    :else
+    :	echo "I prefer bananas myself."
+    :endif
+ <		In a GUI dialog, buttons are used.  The layout of the buttons
+ 		depends on the 'v' flag in 'guioptions'.  If it is included,
+ 		the buttons are always put vertically.  Otherwise,  confirm()
+ 		tries to put the buttons in one horizontal line.  If they
+ 		don't fit, a vertical layout is used anyway.  For some systems
+ 		the horizontal layout is always used.
+ 
  							*copy()*
  copy({expr})	Make a copy of {expr}.  For Numbers and Strings this isn't
  		different from using {expr} directly.
***************
*** 3463,3469 ****
  			""		no `:silent` used
  			"silent"	`:silent` used
  			"silent!"	`:silent!` used
! 		The default is 'silent'.  Note that with "silent!", unlike
  		`:redir`, error messages are dropped.  When using an external
  		command the screen may be messed up, use `system()` instead.
  							*E930*
--- 3470,3476 ----
  			""		no `:silent` used
  			"silent"	`:silent` used
  			"silent!"	`:silent!` used
! 		The default is "silent".  Note that with "silent!", unlike
  		`:redir`, error messages are dropped.  When using an external
  		command the screen may be messed up, use `system()` instead.
  							*E930*
***************
*** 3929,3939 ****
  		|v:foldstart|, |v:foldend| and |v:folddashes| variables.
  		The returned string looks like this: >
  			+-- 45 lines: abcdef
! <		The number of dashes depends on the foldlevel.  The "45" is
! 		the number of lines in the fold.  "abcdef" is the text in the
! 		first non-blank line of the fold.  Leading white space, "//"
! 		or "/*" and the text from the 'foldmarker' and 'commentstring'
! 		options is removed.
  		{not available when compiled without the |+folding| feature}
  
  foldtextresult({lnum})					*foldtextresult()*
--- 3936,3949 ----
  		|v:foldstart|, |v:foldend| and |v:folddashes| variables.
  		The returned string looks like this: >
  			+-- 45 lines: abcdef
! <		The number of leading dashes depends on the foldlevel.  The
! 		"45" is the number of lines in the fold.  "abcdef" is the text
! 		in the first non-blank line of the fold.  Leading white space,
! 		"//" or "/*" and the text from the 'foldmarker' and
! 		'commentstring' options is removed.
! 		When used to draw the actual foldtext, the rest of the line
! 		will be filled with the fold char from the 'fillchars'
! 		setting.
  		{not available when compiled without the |+folding| feature}
  
  foldtextresult({lnum})					*foldtextresult()*
***************
*** 4065,4074 ****
  get({func}, {what})
  		Get an item with from Funcref {func}.  Possible values for
  		{what} are:
! 			'name'	The function name
! 			'func'	The function
! 			'dict'	The dictionary
! 			'args'	The list with arguments
  
  							*getbufinfo()*
  getbufinfo([{expr}])
--- 4075,4084 ----
  get({func}, {what})
  		Get an item with from Funcref {func}.  Possible values for
  		{what} are:
! 			"name"	The function name
! 			"func"	The function
! 			"dict"	The dictionary
! 			"args"	The list with arguments
  
  							*getbufinfo()*
  getbufinfo([{expr}])
***************
*** 4208,4213 ****
--- 4218,4227 ----
  			  exe "normal " . v:mouse_col . "|"
  			endif
  <
+ 		When using bracketed paste only the first character is
+ 		returned, the rest of the pasted text is dropped.
+ 		|xterm-bracketed-paste|.
+ 
  		There is no prompt, you will somehow have to make clear to the
  		user that a character has to be typed.
  		There is no mapping for the character.
***************
*** 4365,4376 ****
  		includes an extra item in the list:
  		    [bufnum, lnum, col, off, curswant] ~
  		The "curswant" number is the preferred column when moving the
! 		cursor vertically.
  		This can be used to save and restore the cursor position: >
  			let save_cursor = getcurpos()
  			MoveTheCursorAround
  			call setpos('.', save_cursor)
! <
  							*getcwd()*
  getcwd([{winnr} [, {tabnr}]])
  		The result is a String, which is the name of the current
--- 4379,4392 ----
  		includes an extra item in the list:
  		    [bufnum, lnum, col, off, curswant] ~
  		The "curswant" number is the preferred column when moving the
! 		cursor vertically.  Also see |getpos()|.
! 
  		This can be used to save and restore the cursor position: >
  			let save_cursor = getcurpos()
  			MoveTheCursorAround
  			call setpos('.', save_cursor)
! <		Note that this only works within the window.  See
! 		|winrestview()| for restoring more state.
  							*getcwd()*
  getcwd([{winnr} [, {tabnr}]])
  		The result is a String, which is the name of the current
***************
*** 4403,4410 ****
  		Only works when the GUI is running, thus not in your vimrc or
  		gvimrc file.  Use the |GUIEnter| autocommand to use this
  		function just after the GUI has started.
! 		Note that the GTK 2 GUI accepts any font name, thus checking
! 		for a valid name does not work.
  
  getfperm({fname})					*getfperm()*
  		The result is a String, which is the read, write, and execute
--- 4419,4426 ----
  		Only works when the GUI is running, thus not in your vimrc or
  		gvimrc file.  Use the |GUIEnter| autocommand to use this
  		function just after the GUI has started.
! 		Note that the GTK GUI accepts any font name, thus checking for
! 		a valid name does not work.
  
  getfperm({fname})					*getfperm()*
  		The result is a String, which is the read, write, and execute
***************
*** 4568,4573 ****
--- 4584,4590 ----
  		If the optional {what} dictionary argument is supplied, then
  		returns only the items listed in {what} as a dictionary. The
  		following string items are supported in {what}:
+ 			context	get the context stored with |setqflist()|
  			nr	get information for this quickfix list; zero
  				means the current quickfix list
  			title	get the list title
***************
*** 4579,4584 ****
--- 4596,4602 ----
  		returned.
  
  		The returned dictionary contains the following entries:
+ 			context	context information stored with |setqflist()|
  			nr	quickfix list number
  			title	quickfix list title text
  			winid	quickfix |window-ID| (if opened)
***************
*** 4668,4680 ****
  <
  							*getwinposx()*
  getwinposx()	The result is a Number, which is the X coordinate in pixels of
! 		the left hand side of the GUI Vim window.  The result will be
! 		-1 if the information is not available.
  
  							*getwinposy()*
  getwinposy()	The result is a Number, which is the Y coordinate in pixels of
! 		the top of the GUI Vim window.  The result will be -1 if the
! 		information is not available.
  
  getwininfo([{winid}])					*getwininfo()*
  		Returns information about windows as a List with Dictionaries.
--- 4686,4701 ----
  <
  							*getwinposx()*
  getwinposx()	The result is a Number, which is the X coordinate in pixels of
! 		the left hand side of the GUI Vim window. Also works for an
! 		xterm.
! 		The result will be -1 if the information is not available.
! 		The value can be used with `:winpos`.
  
  							*getwinposy()*
  getwinposy()	The result is a Number, which is the Y coordinate in pixels of
! 		the top of the GUI Vim window.  Also works for an xterm.
! 		The result will be -1 if the information is not available.
! 		The value can be used with `:winpos`.
  
  getwininfo([{winid}])					*getwininfo()*
  		Returns information about windows as a List with Dictionaries.
***************
*** 5246,5254 ****
  		0 if "how" is not supported on the system.
  		Note that even when the operation was executed, whether the
  		job was actually stopped needs to be checked with
! 		job_status().
! 		The status of the job isn't checked, the operation will even
! 		be done when Vim thinks the job isn't running.
  
  		{only available when compiled with the |+job| feature}
  
--- 5267,5280 ----
  		0 if "how" is not supported on the system.
  		Note that even when the operation was executed, whether the
  		job was actually stopped needs to be checked with
! 		|job_status()|.
! 
! 		If the status of the job is "dead", the signal will not be
! 		sent.  This is to avoid to stop the wrong job (esp. on Unix,
! 		where process numbers are recycled).
! 
! 		When using "kill" Vim will assume the job will die and close
! 		the channel.
  
  		{only available when compiled with the |+job| feature}
  
***************
*** 5290,5301 ****
  		in Vim values.  See |json_encode()| for the relation between
  		JSON and Vim values.
  		The decoding is permissive:
! 		- A trailing comma in an array and object is ignored.
  		- More floating point numbers are recognized, e.g. "1." for
! 		  "1.0".
! 		The result must be a valid Vim type:
! 		- An empty object member name is not allowed.
! 		- Duplicate object member names are not allowed.
  
  json_encode({expr})					*json_encode()*
  		Encode {expr} as JSON and return this as a string.
--- 5316,5344 ----
  		in Vim values.  See |json_encode()| for the relation between
  		JSON and Vim values.
  		The decoding is permissive:
! 		- A trailing comma in an array and object is ignored, e.g.
! 		  "[1, 2, ]" is the same as "[1, 2]".
  		- More floating point numbers are recognized, e.g. "1." for
! 		  "1.0", or "001.2" for "1.2". Special floating point values
! 		  "Infinity" and "NaN" (capitalization ignored) are accepted.
! 		- Leading zeroes in integer numbers are ignored, e.g. "012"
! 		  for "12" or "-012" for "-12".
! 		- Capitalization is ignored in literal names null, true or
! 		  false, e.g. "NULL" for "null", "True" for "true".
! 		- Control characters U+0000 through U+001F which are not
! 		  escaped in strings are accepted, e.g. "	" (tab
! 		  character in string) for "\t".
! 		- Backslash in an invalid 2-character sequence escape is
! 		  ignored, e.g. "\a" is decoded as "a".
! 		- A correct surrogate pair in JSON strings should normally be
! 		  a 12 character sequence such as "\uD834\uDD1E", but
! 		  json_decode() silently accepts truncated surrogate pairs
! 		  such as "\uD834" or "\uD834\u"
! 								*E938*
! 		A duplicate key in an object, valid in rfc7159, is not
! 		accepted by json_decode() as the result must be a valid Vim
! 		type, e.g. this fails: {"a":"b", "a":"c"}
! 
  
  json_encode({expr})					*json_encode()*
  		Encode {expr} as JSON and return this as a string.
***************
*** 5834,5849 ****
  		The type isn't changed, it's not necessarily a String.
  
  							*max()*
! max({list})	Return the maximum value of all items in {list}.
! 		If {list} is not a list or one of the items in {list} cannot
! 		be used as a Number this results in an error.
! 		An empty |List| results in zero.
  
  							*min()*
! min({list})	Return the minimum value of all items in {list}.
! 		If {list} is not a list or one of the items in {list} cannot
! 		be used as a Number this results in an error.
! 		An empty |List| results in zero.
  
  							*mkdir()* *E739*
  mkdir({name} [, {path} [, {prot}]])
--- 5877,5896 ----
  		The type isn't changed, it's not necessarily a String.
  
  							*max()*
! max({expr})	Return the maximum value of all items in {expr}.
! 		{expr} can be a list or a dictionary.  For a dictionary,
! 		it returns the maximum of all values in the dictionary.
! 		If {expr} is neither a list nor a dictionary, or one of the
! 		items in {expr} cannot be used as a Number this results in
!                 an error.  An empty |List| or |Dictionary| results in zero.
  
  							*min()*
! min({expr})	Return the minimum value of all items in {expr}.
! 		{expr} can be a list or a dictionary.  For a dictionary,
! 		it returns the minimum of all values in the dictionary.
! 		If {expr} is neither a list nor a dictionary, or one of the
! 		items in {expr} cannot be used as a Number this results in
!                 an error.  An empty |List| or |Dictionary| results in zero.
  
  							*mkdir()* *E739*
  mkdir({name} [, {path} [, {prot}]])
***************
*** 6007,6013 ****
  		  %e	floating point number as 1.23e3, inf, -inf or nan
  		  %E	floating point number as 1.23E3, INF, -INF or NAN
  		  %g	floating point number, as %f or %e depending on value
! 		  %G	floating point number, as %f or %E depending on value
  		  %%	the % character itself
  
  		Conversion specifications start with '%' and end with the
--- 6054,6060 ----
  		  %e	floating point number as 1.23e3, inf, -inf or nan
  		  %E	floating point number as 1.23E3, INF, -INF or NAN
  		  %g	floating point number, as %f or %e depending on value
! 		  %G	floating point number, as %F or %E depending on value
  		  %%	the % character itself
  
  		Conversion specifications start with '%' and end with the
***************
*** 6942,6947 ****
--- 6989,6995 ----
  		only the items listed in {what} are set. The first {list}
  		argument is ignored.  The following items can be specified in
  		{what}:
+ 		    context	any Vim type can be stored as a context
  		    nr		list number in the quickfix stack
  		    title	quickfix list title text
  		Unsupported keys in {what} are ignored.
***************
*** 6956,6962 ****
  
  		This function can be used to create a quickfix list
  		independent of the 'errorformat' setting.  Use a command like
! 		":cc 1" to jump to the first position.
  
  
  							*setreg()*
--- 7004,7010 ----
  
  		This function can be used to create a quickfix list
  		independent of the 'errorformat' setting.  Use a command like
! 		`:cc 1` to jump to the first position.
  
  
  							*setreg()*
***************
*** 7318,7324 ****
  		Like |strpart()| but using character index and length instead
  		of byte index and length.
  		When a character index is used where a character does not
! 		exist it is assumed to be one byte.  For example: >
  			strcharpart('abc', -1, 2)
  <		results in 'a'.
  
--- 7366,7372 ----
  		Like |strpart()| but using character index and length instead
  		of byte index and length.
  		When a character index is used where a character does not
! 		exist it is assumed to be one character.  For example: >
  			strcharpart('abc', -1, 2)
  <		results in 'a'.
  
***************
*** 7685,7691 ****
  		Same as |system()|, but returns a |List| with lines (parts of 
  		output separated by NL) with NULs transformed into NLs. Output 
  		is the same as |readfile()| will output with {binary} argument 
! 		set to "b".
  
  		Returns an empty string on error.
  
--- 7733,7740 ----
  		Same as |system()|, but returns a |List| with lines (parts of 
  		output separated by NL) with NULs transformed into NLs. Output 
  		is the same as |readfile()| will output with {binary} argument 
! 		set to "b".  Note that on MS-Windows you may get trailing CR
! 		characters.
  
  		Returns an empty string on error.
  
***************
*** 7759,7765 ****
  		may appear, they give the name of the entity the tag is
  		contained in.
  
! 		The ex-command 'cmd' can be either an ex search pattern, a
  		line number or a line number followed by a byte number.
  
  		If there are no matching tags, then an empty list is returned.
--- 7808,7814 ----
  		may appear, they give the name of the entity the tag is
  		contained in.
  
! 		The ex-command "cmd" can be either an ex search pattern, a
  		line number or a line number followed by a byte number.
  
  		If there are no matching tags, then an empty list is returned.
***************
*** 7818,7831 ****
  		Set a flag to enable the effect of 'autochdir' before Vim
  		startup has finished.
  
- 						*test_disable_char_avail()*
- test_disable_char_avail({expr})
- 		When {expr} is 1 the internal char_avail() function will
- 		return |FALSE|.  When {expr} is 0 the char_avail() function will
- 		function normally.
- 		Only use this for a test where typeahead causes the test not
- 		to work.  E.g., to trigger the CursorMovedI autocommand event.
- 
  test_garbagecollect_now()			 *test_garbagecollect_now()*
  		Like garbagecollect(), but executed right away.  This must
  		only be called directly to avoid any structure to exist
--- 7867,7872 ----
***************
*** 8230,8236 ****
  		is returned.
  		The number can be used with |CTRL-W_w| and ":wincmd w"
  		|:wincmd|.
! 		Also see |tabpagewinnr()|.
  
  							*winrestcmd()*
  winrestcmd()	Returns a sequence of |:resize| commands that should restore
--- 8271,8277 ----
  		is returned.
  		The number can be used with |CTRL-W_w| and ":wincmd w"
  		|:wincmd|.
! 		Also see |tabpagewinnr()| and |win_getid()|.
  
  							*winrestcmd()*
  winrestcmd()	Returns a sequence of |:resize| commands that should restore
***************
*** 8463,8471 ****
  			and the argument list |arglist|.
  localmap		Compiled with local mappings and abbr. |:map-local|
  lua			Compiled with Lua interface |Lua|.
! mac			Any Macintosh version of Vim.
! macunix			Compiled for OS X, with darwin
! osx			Compiled for OS X, with or without darwin
  menu			Compiled with support for |:menu|.
  mksession		Compiled with support for |:mksession|.
  modify_fname		Compiled with file name modifiers. |filename-modifiers|
--- 8504,8512 ----
  			and the argument list |arglist|.
  localmap		Compiled with local mappings and abbr. |:map-local|
  lua			Compiled with Lua interface |Lua|.
! mac			Any Macintosh version of Vim, but not all OS X.
! macunix			Compiled for OS X, with |mac-darwin-feature|
! osx			Compiled for OS X, with or w/o |mac-darwin-feature|
  menu			Compiled with support for |:menu|.
  mksession		Compiled with support for |:mksession|.
  modify_fname		Compiled with file name modifiers. |filename-modifiers|
***************
*** 8535,8540 ****
--- 8576,8582 ----
  ttyin			input is a terminal (tty)
  ttyout			output is a terminal (tty)
  unix			Unix version of Vim.
+ unnamedplus		Compiled with support for "unnamedplus" in 'clipboard'
  user_commands		User-defined commands.
  vertsplit		Compiled with vertically split windows |:vsplit|.
  vim_starting		True while initial source'ing takes place. |startup|
***************
*** 9038,9043 ****
--- 9080,9090 ----
  			value and the global value are changed.
  			Example: >
  				:let &path = &path . ',/usr/local/include'
+ <			This also works for terminal codes in the form t_xx.
+ 			But only for alphanumerical names.  Example: >
+ 				:let &t_k1 = "\<Esc>[234;"
+ <			When the code does not exist yet it will be created as
+ 			a terminal key code, there is no error.
  
  :let &{option-name} .= {expr1}
  			For a string option: Append {expr1} to the value.
***************
*** 10634,10639 ****
--- 10681,10703 ----
  	:  echo "You will _never_ see this message"
  	:endif
  
+ To execute a command only when the |+eval| feature is disabled requires a trick,
+ as this example shows: >
+ 
+ 	silent! while 0
+ 	  set history=111
+ 	silent! endwhile
+ 
+ When the |+eval| feature is available the command is skipped because of the
+ "while 0".  Without the |+eval| feature the "while 0" is an error, which is
+ silently ignored, and the command is executed.
+ 
+ The "<CR>" here is a real CR character, type CTRL-V Enter to get it.
+ 
+ When the |+eval| feature is available the ":" is remapped to add a double
+ quote, which has the effect of commenting-out the command.  Without the
+ |+eval| feature the nnoremap command is skipped and the command is executed.
+ 
  ==============================================================================
  11. The sandbox					*eval-sandbox* *sandbox* *E48*
  
*** ../vim-8.0.0590/src/version.c	2017-04-30 14:20:53.346830850 +0200
--- src/version.c	2017-04-30 16:34:38.282418524 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     591,
  /**/

-- 
Compilation process failed successfully.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
