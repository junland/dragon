To: vim_dev@googlegroups.com
Subject: Patch 8.0.0627
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0627
Problem:    When 'wrapscan' is off "gn" does not select the whole pattern when
            it's the last one in the text. (KeyboardFire)
Solution:   Check if the search fails. (Christian Brabandt, closes #1683)
Files:      src/search.c, src/testdir/test_gn.vim


*** ../vim-8.0.0626/src/search.c	2017-06-05 16:37:03.327465111 +0200
--- src/search.c	2017-06-05 19:52:46.874300600 +0200
***************
*** 4599,4605 ****
  
  #endif /* FEAT_TEXTOBJ */
  
! static int is_one_char(char_u *pattern, int move);
  
  /*
   * Find next search match under cursor, cursor at end.
--- 4599,4605 ----
  
  #endif /* FEAT_TEXTOBJ */
  
! static int is_one_char(char_u *pattern, int move, pos_T *cur);
  
  /*
   * Find next search match under cursor, cursor at end.
***************
*** 4647,4653 ****
  	orig_pos = pos = curwin->w_cursor;
  
      /* Is the pattern is zero-width? */
!     one_char = is_one_char(spats[last_idx].pat, TRUE);
      if (one_char == -1)
      {
  	p_ws = old_p_ws;
--- 4647,4653 ----
  	orig_pos = pos = curwin->w_cursor;
  
      /* Is the pattern is zero-width? */
!     one_char = is_one_char(spats[last_idx].pat, TRUE, &curwin->w_cursor);
      if (one_char == -1)
      {
  	p_ws = old_p_ws;
***************
*** 4710,4716 ****
  
      /* Check again from the current cursor position,
       * since the next match might actually by only one char wide */
!     one_char = is_one_char(spats[last_idx].pat, FALSE);
  
      /* move to match, except for zero-width matches, in which case, we are
       * already on the next match */
--- 4710,4719 ----
  
      /* Check again from the current cursor position,
       * since the next match might actually by only one char wide */
!     one_char = is_one_char(spats[last_idx].pat, FALSE, &pos);
!     if (one_char < 0)
! 	/* search failed, abort */
! 	return FAIL;
  
      /* move to match, except for zero-width matches, in which case, we are
       * already on the next match */
***************
*** 4761,4772 ****
  
  /*
   * Check if the pattern is one character long or zero-width.
!  * If move is TRUE, check from the beginning of the buffer, else from the
!  * current cursor position.
   * Returns TRUE, FALSE or -1 for failure.
   */
      static int
! is_one_char(char_u *pattern, int move)
  {
      regmmatch_T	regmatch;
      int		nmatched = 0;
--- 4764,4775 ----
  
  /*
   * Check if the pattern is one character long or zero-width.
!  * If move is TRUE, check from the beginning of the buffer, else from position
!  * "cur".
   * Returns TRUE, FALSE or -1 for failure.
   */
      static int
! is_one_char(char_u *pattern, int move, pos_T *cur)
  {
      regmmatch_T	regmatch;
      int		nmatched = 0;
***************
*** 4791,4797 ****
      }
      else
      {
! 	pos = curwin->w_cursor;
  	/* accept a match at the cursor position */
  	flag = SEARCH_START;
      }
--- 4794,4800 ----
      }
      else
      {
! 	pos = *cur;
  	/* accept a match at the cursor position */
  	flag = SEARCH_START;
      }
*** ../vim-8.0.0626/src/testdir/test_gn.vim	2016-08-18 22:59:22.000000000 +0200
--- src/testdir/test_gn.vim	2017-06-05 19:49:06.911817326 +0200
***************
*** 1,43 ****
  " Test for gn command
  
  func Test_gn_command()
!   noa new
    " replace a single char by itsself quoted:
    call setline('.', 'abc x def x ghi x jkl')
    let @/='x'
    exe "norm! cgn'x'\<esc>.."
    call assert_equal("abc 'x' def 'x' ghi 'x' jkl", getline('.'))
    sil! %d_
    " simple search match
    call setline('.', 'foobar')
    let @/='foobar'
    exe "norm! gncsearchmatch"
    call assert_equal('searchmatch', getline('.'))
    sil! %d _
    " replace a multi-line match
    call setline('.', ['', 'one', 'two'])
    let @/='one\_s*two\_s'
    exe "norm! gnceins\<CR>zwei"
    call assert_equal(['','eins','zwei'], getline(1,'$'))
    sil! %d _
    " test count argument
    call setline('.', ['', 'abcdx | abcdx | abcdx'])
    let @/='[a]bcdx'
    exe "norm! 2gnd"
    call assert_equal(['','abcdx |  | abcdx'], getline(1,'$'))
    sil! %d _
    " join lines
    call setline('.', ['join ', 'lines'])
    let @/='$'
    exe "norm! 0gnd"
    call assert_equal(['join lines'], getline(1,'$'))
    sil! %d _
    " zero-width match
    call setline('.', ['', 'zero width pattern'])
    let @/='\>\zs'
    exe "norm! 0gnd"
    call assert_equal(['', 'zerowidth pattern'], getline(1,'$'))
    sil! %d _
    " delete first and last chars
    call setline('.', ['delete first and last chars'])
    let @/='^'
--- 1,50 ----
  " Test for gn command
  
  func Test_gn_command()
!   set belloff=all
!   noautocmd new
    " replace a single char by itsself quoted:
    call setline('.', 'abc x def x ghi x jkl')
    let @/='x'
    exe "norm! cgn'x'\<esc>.."
    call assert_equal("abc 'x' def 'x' ghi 'x' jkl", getline('.'))
    sil! %d_
+ 
    " simple search match
    call setline('.', 'foobar')
    let @/='foobar'
    exe "norm! gncsearchmatch"
    call assert_equal('searchmatch', getline('.'))
    sil! %d _
+ 
    " replace a multi-line match
    call setline('.', ['', 'one', 'two'])
    let @/='one\_s*two\_s'
    exe "norm! gnceins\<CR>zwei"
    call assert_equal(['','eins','zwei'], getline(1,'$'))
    sil! %d _
+ 
    " test count argument
    call setline('.', ['', 'abcdx | abcdx | abcdx'])
    let @/='[a]bcdx'
    exe "norm! 2gnd"
    call assert_equal(['','abcdx |  | abcdx'], getline(1,'$'))
    sil! %d _
+ 
    " join lines
    call setline('.', ['join ', 'lines'])
    let @/='$'
    exe "norm! 0gnd"
    call assert_equal(['join lines'], getline(1,'$'))
    sil! %d _
+ 
    " zero-width match
    call setline('.', ['', 'zero width pattern'])
    let @/='\>\zs'
    exe "norm! 0gnd"
    call assert_equal(['', 'zerowidth pattern'], getline(1,'$'))
    sil! %d _
+ 
    " delete first and last chars
    call setline('.', ['delete first and last chars'])
    let @/='^'
***************
*** 46,68 ****
--- 53,79 ----
    exe "norm! gnd"
    call assert_equal(['elete first and last char'], getline(1,'$'))
    sil! %d _
+ 
    " using visual mode
    call setline('.', ['', 'uniquepattern uniquepattern'])
    exe "norm! /[u]niquepattern/s\<cr>vlgnd"
    call assert_equal(['', ' uniquepattern'], getline(1,'$'))
    sil! %d _
+ 
    " backwards search
    call setline('.', ['my very excellent mother just served us nachos'])
    let @/='mother'
    exe "norm! $cgNmongoose"
    call assert_equal(['my very excellent mongoose just served us nachos'], getline(1,'$'))
    sil! %d _
+ 
    " search for single char
    call setline('.', ['','for (i=0; i<=10; i++)'])
    let @/='i'
    exe "norm! cgnj"
    call assert_equal(['','for (j=0; i<=10; i++)'], getline(1,'$'))
    sil! %d _
+ 
    " search hex char
    call setline('.', ['','Y'])
    set noignorecase
***************
*** 70,93 ****
--- 81,118 ----
    exe "norm! gnd"
    call assert_equal(['',''], getline(1,'$'))
    sil! %d _
+ 
    " test repeating gdn
    call setline('.', ['', '1', 'Johnny', '2', 'Johnny', '3'])
    let @/='Johnny'
    exe "norm! dgn."
    call assert_equal(['','1', '', '2', '', '3'], getline(1,'$'))
    sil! %d _
+ 
    " test repeating gUgn
    call setline('.', ['', '1', 'Depp', '2', 'Depp', '3'])
    let @/='Depp'
    exe "norm! gUgn."
    call assert_equal(['', '1', 'DEPP', '2', 'DEPP', '3'], getline(1,'$'))
    sil! %d _
+ 
    " test using look-ahead assertions
    call setline('.', ['a:10', '', 'a:1', '', 'a:20'])
    let @/='a:0\@!\zs\d\+'
    exe "norm! 2nygno\<esc>p"
    call assert_equal(['a:10', '', 'a:1', '1', '', 'a:20'], getline(1,'$'))
    sil! %d _
+ 
+   " test using nowrapscan
+   set nowrapscan
+   call setline(1, 'foo bar baz')
+   exe "norm! /bar/e\<cr>"
+   exe "norm! gnd"
+   call assert_equal(['foo  baz'], getline(1,'$'))
+   sil! %d_
+ 
+   set wrapscan&vim
+   set belloff&vim
  endfu
  
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0626/src/version.c	2017-06-05 19:32:28.702723156 +0200
--- src/version.c	2017-06-05 19:55:18.557257362 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     627,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
11. You find yourself typing "com" after every period when using a word
    processor.com

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
