To: vim_dev@googlegroups.com
Subject: Patch 8.0.0517
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0517
Problem:    There is no way to remove quickfix lists (for testing).
Solution:   Add the 'f' action to setqflist(). Add tests. (Yegappan
            Lakshmanan)
Files:      runtime/doc/eval.txt, src/evalfunc.c, src/quickfix.c,
            src/testdir/test_quickfix.vim


*** ../vim-8.0.0516/runtime/doc/eval.txt	2017-03-21 17:08:46.674923913 +0100
--- runtime/doc/eval.txt	2017-03-29 13:54:21.043320416 +0200
***************
*** 6917,6932 ****
  		Note that the list is not exactly the same as what
  		|getqflist()| returns.
  
! 							*E927*
! 		If {action} is set to 'a', then the items from {list} are
! 		added to the existing quickfix list. If there is no existing
! 		list, then a new list is created.
  		
! 		If {action} is set to 'r', then the items from the current
! 		quickfix list are replaced with the items from {list}.  This
! 		can also be used to clear the list: >
! 			:call setqflist([], 'r')
  <	
  		If {action} is not present or is set to ' ', then a new list
  		is created.
  
--- 6936,6954 ----
  		Note that the list is not exactly the same as what
  		|getqflist()| returns.
  
! 		{action} values:				*E927*
! 		'a'	The items from {list} are added to the existing
! 			quickfix list. If there is no existing list, then a
! 			new list is created.
  		
! 		'r'	The items from the current quickfix list are replaced
! 			with the items from {list}.  This can also be used to
! 			clear the list: >
! 				:call setqflist([], 'r')
  <	
+ 		'f'	All the quickfix lists in the quickfix stack are
+ 			freed.
+ 
  		If {action} is not present or is set to ' ', then a new list
  		is created.
  
*** ../vim-8.0.0516/src/evalfunc.c	2017-03-26 13:50:02.532929428 +0200
--- src/evalfunc.c	2017-03-29 13:51:18.160429885 +0200
***************
*** 10038,10044 ****
  	    act = get_tv_string_chk(action_arg);
  	    if (act == NULL)
  		return;		/* type error; errmsg already given */
! 	    if ((*act == 'a' || *act == 'r' || *act == ' ') && act[1] == NUL)
  		action = *act;
  	    else
  		EMSG2(_(e_invact), act);
--- 10038,10045 ----
  	    act = get_tv_string_chk(action_arg);
  	    if (act == NULL)
  		return;		/* type error; errmsg already given */
! 	    if ((*act == 'a' || *act == 'r' || *act == ' ' || *act == 'f') &&
! 		    act[1] == NUL)
  		action = *act;
  	    else
  		EMSG2(_(e_invact), act);
*** ../vim-8.0.0516/src/quickfix.c	2017-03-19 14:19:46.489645443 +0100
--- src/quickfix.c	2017-03-29 14:18:44.998423072 +0200
***************
*** 717,723 ****
  
  #ifdef FEAT_MBYTE
      /* Convert a line if it contains a non-ASCII character. */
!     if (state->vc.vc_type != CONV_NONE && has_non_ascii(state->linebuf)) {
  	char_u	*line;
  
  	line = string_convert(&state->vc, state->linebuf, &state->linelen);
--- 717,724 ----
  
  #ifdef FEAT_MBYTE
      /* Convert a line if it contains a non-ASCII character. */
!     if (state->vc.vc_type != CONV_NONE && has_non_ascii(state->linebuf))
!     {
  	char_u	*line;
  
  	line = string_convert(&state->vc, state->linebuf, &state->linelen);
***************
*** 917,923 ****
  	    }
  	    if (fmt_ptr->flags == '+' && !qi->qf_multiscan)	/* %+ */
  	    {
! 		if (linelen > fields->errmsglen) {
  		    /* linelen + null terminator */
  		    if ((fields->errmsg = vim_realloc(fields->errmsg,
  				    linelen + 1)) == NULL)
--- 918,925 ----
  	    }
  	    if (fmt_ptr->flags == '+' && !qi->qf_multiscan)	/* %+ */
  	    {
! 		if (linelen > fields->errmsglen)
! 		{
  		    /* linelen + null terminator */
  		    if ((fields->errmsg = vim_realloc(fields->errmsg,
  				    linelen + 1)) == NULL)
***************
*** 931,937 ****
  		if (regmatch.startp[i] == NULL || regmatch.endp[i] == NULL)
  		    continue;
  		len = (int)(regmatch.endp[i] - regmatch.startp[i]);
! 		if (len > fields->errmsglen) {
  		    /* len + null terminator */
  		    if ((fields->errmsg = vim_realloc(fields->errmsg, len + 1))
  			    == NULL)
--- 933,940 ----
  		if (regmatch.startp[i] == NULL || regmatch.endp[i] == NULL)
  		    continue;
  		len = (int)(regmatch.endp[i] - regmatch.startp[i]);
! 		if (len > fields->errmsglen)
! 		{
  		    /* len + null terminator */
  		    if ((fields->errmsg = vim_realloc(fields->errmsg, len + 1))
  			    == NULL)
***************
*** 1013,1019 ****
  	fields->namebuf[0] = NUL;	/* no match found, remove file name */
  	fields->lnum = 0;			/* don't jump to this line */
  	fields->valid = FALSE;
! 	if (linelen > fields->errmsglen) {
  	    /* linelen + null terminator */
  	    if ((fields->errmsg = vim_realloc(fields->errmsg,
  			    linelen + 1)) == NULL)
--- 1016,1023 ----
  	fields->namebuf[0] = NUL;	/* no match found, remove file name */
  	fields->lnum = 0;			/* don't jump to this line */
  	fields->valid = FALSE;
! 	if (linelen > fields->errmsglen)
! 	{
  	    /* linelen + null terminator */
  	    if ((fields->errmsg = vim_realloc(fields->errmsg,
  			    linelen + 1)) == NULL)
***************
*** 4798,4804 ****
  	qi->qf_lists[qi->qf_curlist].qf_nonevalid = TRUE;
      else
  	qi->qf_lists[qi->qf_curlist].qf_nonevalid = FALSE;
!     if (action != 'a') {
  	qi->qf_lists[qi->qf_curlist].qf_ptr =
  	    qi->qf_lists[qi->qf_curlist].qf_start;
  	if (qi->qf_lists[qi->qf_curlist].qf_count > 0)
--- 4802,4809 ----
  	qi->qf_lists[qi->qf_curlist].qf_nonevalid = TRUE;
      else
  	qi->qf_lists[qi->qf_curlist].qf_nonevalid = FALSE;
!     if (action != 'a')
!     {
  	qi->qf_lists[qi->qf_curlist].qf_ptr =
  	    qi->qf_lists[qi->qf_curlist].qf_start;
  	if (qi->qf_lists[qi->qf_curlist].qf_count > 0)
***************
*** 4861,4866 ****
--- 4866,4883 ----
      return retval;
  }
  
+     static void
+ qf_free_stack(win_T *wp, qf_info_T *qi)
+ {
+     qf_free_all(wp);
+     if (wp == NULL)
+     {
+ 	/* quickfix list */
+ 	qi->qf_curlist = 0;
+ 	qi->qf_listcount = 0;
+     }
+ }
+ 
  /*
   * Populate the quickfix list with the items supplied in the list
   * of dictionaries. "title" will be copied to w:quickfix_title.
***************
*** 4884,4890 ****
  	    return FAIL;
      }
  
!     if (what != NULL)
  	retval = qf_set_properties(qi, what, action);
      else
  	retval = qf_add_entries(qi, list, title, action);
--- 4901,4912 ----
  	    return FAIL;
      }
  
!     if (action == 'f')
!     {
! 	/* Free the entire quickfix or location list stack */
! 	qf_free_stack(wp, qi);
!     }
!     else if (what != NULL)
  	retval = qf_set_properties(qi, what, action);
      else
  	retval = qf_add_entries(qi, list, title, action);
***************
*** 5187,5193 ****
  			    /* Convert a line if 'encoding' is not utf-8 and
  			     * the line contains a non-ASCII character. */
  			    if (vc.vc_type != CONV_NONE
! 						   && has_non_ascii(IObuff)) {
  				line = string_convert(&vc, IObuff, NULL);
  				if (line == NULL)
  				    line = IObuff;
--- 5209,5216 ----
  			    /* Convert a line if 'encoding' is not utf-8 and
  			     * the line contains a non-ASCII character. */
  			    if (vc.vc_type != CONV_NONE
! 						   && has_non_ascii(IObuff))
! 			    {
  				line = string_convert(&vc, IObuff, NULL);
  				if (line == NULL)
  				    line = IObuff;
*** ../vim-8.0.0516/src/testdir/test_quickfix.vim	2017-03-19 14:19:46.493645414 +0100
--- src/testdir/test_quickfix.vim	2017-03-29 13:51:18.160429885 +0200
***************
*** 38,43 ****
--- 38,44 ----
      command! -nargs=* Xhelpgrep helpgrep <args>
      let g:Xgetlist = function('getqflist')
      let g:Xsetlist = function('setqflist')
+     call setqflist([], 'f')
    else
      command! -nargs=* -bang Xlist <mods>llist<bang> <args>
      command! -nargs=* Xgetexpr <mods>lgetexpr <args>
***************
*** 69,74 ****
--- 70,76 ----
      command! -nargs=* Xhelpgrep lhelpgrep <args>
      let g:Xgetlist = function('getloclist', [0])
      let g:Xsetlist = function('setloclist', [0])
+     call setloclist(0, [], 'f')
    endif
  endfunc
  
***************
*** 76,81 ****
--- 78,86 ----
  func XlistTests(cchar)
    call s:setup_commands(a:cchar)
  
+   if a:cchar == 'l'
+       call assert_fails('llist', 'E776:')
+   endif
    " With an empty list, command should return error
    Xgetexpr []
    silent! Xlist
***************
*** 146,151 ****
--- 151,159 ----
  func XageTests(cchar)
    call s:setup_commands(a:cchar)
  
+   let list = [{'bufnr': 1, 'lnum': 1}]
+   call g:Xsetlist(list)
+ 
    " Jumping to a non existent list should return error
    silent! Xolder 99
    call assert_true(v:errmsg ==# 'E380: At bottom of quickfix stack')
***************
*** 179,189 ****
  endfunc
  
  func Test_cage()
-   let list = [{'bufnr': 1, 'lnum': 1}]
-   call setqflist(list)
    call XageTests('c')
- 
-   call setloclist(0, list)
    call XageTests('l')
  endfunc
  
--- 187,193 ----
***************
*** 192,197 ****
--- 196,206 ----
  func XwindowTests(cchar)
    call s:setup_commands(a:cchar)
  
+   " Opening the location list window without any errors should fail
+   if a:cchar == 'l'
+       call assert_fails('lopen', 'E776:')
+   endif
+ 
    " Create a list with no valid entries
    Xgetexpr ['non-error 1', 'non-error 2', 'non-error 3']
  
***************
*** 232,237 ****
--- 241,259 ----
    " Calling cwindow should close the quickfix window with no valid errors
    Xwindow
    call assert_true(winnr('$') == 1)
+ 
+   if a:cchar == 'c'
+       " Opening the quickfix window in multiple tab pages should reuse the
+       " quickfix buffer
+       Xgetexpr ['Xtestfile1:1:3:Line1', 'Xtestfile2:2:2:Line2',
+ 		  \ 'Xtestfile3:3:1:Line3']
+       Xopen
+       let qfbufnum = bufnr('%')
+       tabnew
+       Xopen
+       call assert_equal(qfbufnum, bufnr('%'))
+       new | only | tabonly
+   endif
  endfunc
  
  func Test_cwindow()
***************
*** 360,365 ****
--- 382,394 ----
  func Xtest_browse(cchar)
    call s:setup_commands(a:cchar)
  
+   " Jumping to first or next location list entry without any error should
+   " result in failure
+   if a:cchar == 'l'
+       call assert_fails('lfirst', 'E776:')
+       call assert_fails('lnext', 'E776:')
+   endif
+ 
    call s:create_test_file('Xqftestfile1')
    call s:create_test_file('Xqftestfile2')
  
***************
*** 1550,1555 ****
--- 1579,1589 ----
  func XbottomTests(cchar)
    call s:setup_commands(a:cchar)
  
+   " Calling lbottom without any errors should fail
+   if a:cchar == 'l'
+       call assert_fails('lbottom', 'E776:')
+   endif
+ 
    call g:Xsetlist([{'filename': 'foo', 'lnum': 42}]) 
    Xopen
    let wid = win_getid()
***************
*** 1571,1580 ****
  func HistoryTest(cchar)
    call s:setup_commands(a:cchar)
  
-   call assert_fails(a:cchar . 'older 99', 'E380:')
    " clear all lists after the first one, then replace the first one.
    call g:Xsetlist([])
!   Xolder
    let entry = {'filename': 'foo', 'lnum': 42}
    call g:Xsetlist([entry], 'r')
    call g:Xsetlist([entry, entry])
--- 1605,1613 ----
  func HistoryTest(cchar)
    call s:setup_commands(a:cchar)
  
    " clear all lists after the first one, then replace the first one.
    call g:Xsetlist([])
!   call assert_fails('Xolder 99', 'E380:')
    let entry = {'filename': 'foo', 'lnum': 42}
    call g:Xsetlist([entry], 'r')
    call g:Xsetlist([entry, entry])
***************
*** 1617,1622 ****
--- 1650,1656 ----
      call assert_fails('call g:Xsetlist([], "a", [])', 'E715:')
  
      " Set and get the title
+     call g:Xsetlist([])
      Xopen
      wincmd p
      call g:Xsetlist([{'filename':'foo', 'lnum':27}])
*** ../vim-8.0.0516/src/version.c	2017-03-29 13:08:31.011872289 +0200
--- src/version.c	2017-03-29 13:51:00.056539735 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     517,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
230. You spend your Friday nights typing away at your keyboard

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
