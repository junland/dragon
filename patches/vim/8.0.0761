To: vim_dev@googlegroups.com
Subject: Patch 8.0.0761
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0761
Problem:    Options of a buffer for a terminal window are not set properly.
Solution:   Add "terminal" value for 'buftype'.  Make 'buftype' and
            'bufhidden' not depend on the quickfix feature.
            Also set the buffer name and show "running" or "finished" in the
            window title.
Files:      src/option.c, src/terminal.c, src/proto/terminal.pro,
            runtime/doc/options.txt, src/quickfix.c, src/proto/quickfix.pro,
            src/structs.h, src/buffer.c, src/ex_docmd.c, src/fileio.c,
            src/channel.c


*** ../vim-8.0.0760/src/option.c	2017-07-22 17:03:57.371802012 +0200
--- src/option.c	2017-07-23 18:54:09.946776210 +0200
***************
*** 287,296 ****
  #ifdef FEAT_MBYTE
  static int	p_bomb;
  #endif
- #if defined(FEAT_QUICKFIX)
  static char_u	*p_bh;
  static char_u	*p_bt;
- #endif
  static int	p_bl;
  static int	p_ci;
  #ifdef FEAT_CINDENT
--- 287,294 ----
***************
*** 720,745 ****
  #endif
  			    SCRIPTID_INIT},
      {"bufhidden",   "bh",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB,
- #if defined(FEAT_QUICKFIX)
  			    (char_u *)&p_bh, PV_BH,
  			    {(char_u *)"", (char_u *)0L}
- #else
- 			    (char_u *)NULL, PV_NONE,
- 			    {(char_u *)0L, (char_u *)0L}
- #endif
  			    SCRIPTID_INIT},
      {"buflisted",   "bl",   P_BOOL|P_VI_DEF|P_NOGLOB,
  			    (char_u *)&p_bl, PV_BL,
  			    {(char_u *)1L, (char_u *)0L}
  			    SCRIPTID_INIT},
      {"buftype",	    "bt",   P_STRING|P_ALLOCED|P_VI_DEF|P_NOGLOB,
- #if defined(FEAT_QUICKFIX)
  			    (char_u *)&p_bt, PV_BT,
  			    {(char_u *)"", (char_u *)0L}
- #else
- 			    (char_u *)NULL, PV_NONE,
- 			    {(char_u *)0L, (char_u *)0L}
- #endif
  			    SCRIPTID_INIT},
      {"casemap",	    "cmp",   P_STRING|P_VI_DEF|P_ONECOMMA|P_NODUP,
  #ifdef FEAT_MBYTE
--- 718,733 ----
***************
*** 3254,3267 ****
  #ifdef FEAT_WINDOWS
  static char *(p_ead_values[]) = {"both", "ver", "hor", NULL};
  #endif
! #if defined(FEAT_QUICKFIX)
! # ifdef FEAT_AUTOCMD
! static char *(p_buftype_values[]) = {"nofile", "nowrite", "quickfix", "help", "acwrite", NULL};
! # else
! static char *(p_buftype_values[]) = {"nofile", "nowrite", "quickfix", "help", NULL};
! # endif
! static char *(p_bufhidden_values[]) = {"hide", "unload", "delete", "wipe", NULL};
  #endif
  static char *(p_bs_values[]) = {"indent", "eol", "start", NULL};
  #ifdef FEAT_FOLDING
  static char *(p_fdm_values[]) = {"manual", "expr", "marker", "indent", "syntax",
--- 3242,3253 ----
  #ifdef FEAT_WINDOWS
  static char *(p_ead_values[]) = {"both", "ver", "hor", NULL};
  #endif
! #ifdef FEAT_AUTOCMD
! static char *(p_buftype_values[]) = {"nofile", "nowrite", "quickfix", "help", "terminal", "acwrite", NULL};
! #else
! static char *(p_buftype_values[]) = {"nofile", "nowrite", "quickfix", "help", "terminal", NULL};
  #endif
+ static char *(p_bufhidden_values[]) = {"hide", "unload", "delete", "wipe", NULL};
  static char *(p_bs_values[]) = {"indent", "eol", "start", NULL};
  #ifdef FEAT_FOLDING
  static char *(p_fdm_values[]) = {"manual", "expr", "marker", "indent", "syntax",
***************
*** 5649,5658 ****
      void
  check_buf_options(buf_T *buf)
  {
- #if defined(FEAT_QUICKFIX)
      check_string_option(&buf->b_p_bh);
      check_string_option(&buf->b_p_bt);
- #endif
  #ifdef FEAT_MBYTE
      check_string_option(&buf->b_p_fenc);
  #endif
--- 5635,5642 ----
***************
*** 7115,7121 ****
      }
  #endif
  
- #ifdef FEAT_QUICKFIX
      /* When 'bufhidden' is set, check for valid value. */
      else if (gvarp == &p_bh)
      {
--- 7099,7104 ----
***************
*** 7130,7149 ****
  	    errmsg = e_invarg;
  	else
  	{
! # ifdef FEAT_WINDOWS
  	    if (curwin->w_status_height)
  	    {
  		curwin->w_redr_status = TRUE;
  		redraw_later(VALID);
  	    }
! # endif
  	    curbuf->b_help = (curbuf->b_p_bt[0] == 'h');
! # ifdef FEAT_TITLE
  	    redraw_titles();
! # endif
  	}
      }
- #endif
  
  #ifdef FEAT_STL_OPT
      /* 'statusline' or 'rulerformat' */
--- 7113,7131 ----
  	    errmsg = e_invarg;
  	else
  	{
! #ifdef FEAT_WINDOWS
  	    if (curwin->w_status_height)
  	    {
  		curwin->w_redr_status = TRUE;
  		redraw_later(VALID);
  	    }
! #endif
  	    curbuf->b_help = (curbuf->b_p_bt[0] == 'h');
! #ifdef FEAT_TITLE
  	    redraw_titles();
! #endif
  	}
      }
  
  #ifdef FEAT_STL_OPT
      /* 'statusline' or 'rulerformat' */
***************
*** 10722,10731 ****
  #ifdef FEAT_MBYTE
  	case PV_BOMB:	return (char_u *)&(curbuf->b_p_bomb);
  #endif
- #if defined(FEAT_QUICKFIX)
  	case PV_BH:	return (char_u *)&(curbuf->b_p_bh);
  	case PV_BT:	return (char_u *)&(curbuf->b_p_bt);
- #endif
  	case PV_BL:	return (char_u *)&(curbuf->b_p_bl);
  	case PV_CI:	return (char_u *)&(curbuf->b_p_ci);
  #ifdef FEAT_CINDENT
--- 10704,10711 ----
***************
*** 11119,11128 ****
  		}
  		if (buf->b_p_ff != NULL)
  		    buf->b_start_ffc = *buf->b_p_ff;
- #if defined(FEAT_QUICKFIX)
  		buf->b_p_bh = empty_option;
  		buf->b_p_bt = empty_option;
- #endif
  	    }
  	    else
  		free_buf_options(buf, FALSE);
--- 11099,11106 ----
***************
*** 11284,11293 ****
  		did_isk = TRUE;
  		buf->b_p_ts = p_ts;
  		buf->b_help = FALSE;
- #ifdef FEAT_QUICKFIX
  		if (buf->b_p_bt[0] == 'h')
  		    clear_string_option(&buf->b_p_bt);
- #endif
  		buf->b_p_ma = p_ma;
  	    }
  	}
--- 11262,11269 ----
*** ../vim-8.0.0760/src/terminal.c	2017-07-23 18:07:51.046808263 +0200
--- src/terminal.c	2017-07-23 19:44:38.271722006 +0200
***************
*** 33,41 ****
   * while, if the terminal window is visible, the screen contents is drawn.
   *
   * TODO:
!  * - cursor flickers when moving the cursor
!  * - set buffer options to be scratch, hidden, nomodifiable, etc.
!  * - set buffer name to command, add (1) to avoid duplicates.
   * - Add a scrollback buffer (contains lines to scroll off the top).
   *   Can use the buf_T lines, store attributes somewhere else?
   * - When the job ends:
--- 33,40 ----
   * while, if the terminal window is visible, the screen contents is drawn.
   *
   * TODO:
!  * - do not store terminal buffer in viminfo
!  * - put terminal title in the statusline
   * - Add a scrollback buffer (contains lines to scroll off the top).
   *   Can use the buf_T lines, store attributes somewhere else?
   * - When the job ends:
***************
*** 53,59 ****
   * - support minimal size when 'termsize' is empty?
   * - implement "term" for job_start(): more job options when starting a
   *   terminal.
-  * - implement ":buf {term-buf-name}"
   * - implement term_list()			list of buffers with a terminal
   * - implement term_getsize(buf)
   * - implement term_setsize(buf)
--- 52,57 ----
***************
*** 192,198 ****
      term->tl_next = first_term;
      first_term = term;
  
!     /* TODO: set buffer type, hidden, etc. */
  
      set_term_and_win_size(term);
  
--- 190,220 ----
      term->tl_next = first_term;
      first_term = term;
  
!     if (buflist_findname(cmd) == NULL)
! 	curbuf->b_ffname = vim_strsave(cmd);
!     else
!     {
! 	int	i;
! 	size_t	len = STRLEN(cmd) + 10;
! 	char_u	*p = alloc(len);
! 
! 	for (i = 1; p != NULL; ++i)
! 	{
! 	    vim_snprintf((char *)p, len, "%s (%d)", cmd, i);
! 	    if (buflist_findname(p) == NULL)
! 	    {
! 		curbuf->b_ffname = p;
! 		break;
! 	    }
! 	}
!     }
!     curbuf->b_fname = curbuf->b_ffname;
! 
!     /* Mark the buffer as changed, so that it's not easy to abandon the job. */
!     curbuf->b_changed = TRUE;
!     curbuf->b_p_ma = FALSE;
!     set_string_option_direct((char_u *)"buftype", -1,
! 				  (char_u *)"terminal", OPT_FREE|OPT_LOCAL, 0);
  
      set_term_and_win_size(term);
  
***************
*** 490,495 ****
--- 512,537 ----
      }
  }
  
+ /*
+  * Called when a job has finished.
+  */
+     void
+ term_job_ended(job_T *job)
+ {
+     if (curbuf->b_term != NULL && curbuf->b_term->tl_job == job)
+ 	maketitle();
+ }
+ 
+ /*
+  * Return TRUE if the job for "buf" is still running.
+  */
+     int
+ term_job_running(buf_T *buf)
+ {
+     return buf->b_term != NULL && buf->b_term->tl_job != NULL
+ 	&& buf->b_term->tl_job->jv_status == JOB_STARTED;
+ }
+ 
      static void
  position_cursor(win_T *wp, VTermPos *pos)
  {
***************
*** 850,862 ****
      opt->jo_out_mode = MODE_RAW;
      opt->jo_err_mode = MODE_RAW;
      opt->jo_set = JO_MODE | JO_OUT_MODE | JO_ERR_MODE;
      opt->jo_io[PART_OUT] = JIO_BUFFER;
      opt->jo_io[PART_ERR] = JIO_BUFFER;
!     opt->jo_set |= JO_OUT_IO + (JO_OUT_IO << (PART_ERR - PART_OUT));
      opt->jo_io_buf[PART_OUT] = curbuf->b_fnum;
      opt->jo_io_buf[PART_ERR] = curbuf->b_fnum;
      opt->jo_pty = TRUE;
!     opt->jo_set |= JO_OUT_BUF + (JO_OUT_BUF << (PART_ERR - PART_OUT));
      opt->jo_term_rows = rows;
      opt->jo_term_cols = cols;
  }
--- 892,911 ----
      opt->jo_out_mode = MODE_RAW;
      opt->jo_err_mode = MODE_RAW;
      opt->jo_set = JO_MODE | JO_OUT_MODE | JO_ERR_MODE;
+ 
      opt->jo_io[PART_OUT] = JIO_BUFFER;
      opt->jo_io[PART_ERR] = JIO_BUFFER;
!     opt->jo_set |= JO_OUT_IO + JO_ERR_IO;
! 
!     opt->jo_modifiable[PART_OUT] = 0;
!     opt->jo_modifiable[PART_ERR] = 0;
!     opt->jo_set |= JO_OUT_MODIFIABLE + JO_ERR_MODIFIABLE;
! 
      opt->jo_io_buf[PART_OUT] = curbuf->b_fnum;
      opt->jo_io_buf[PART_ERR] = curbuf->b_fnum;
      opt->jo_pty = TRUE;
!     opt->jo_set |= JO_OUT_BUF + JO_ERR_BUF;
! 
      opt->jo_term_rows = rows;
      opt->jo_term_cols = cols;
  }
*** ../vim-8.0.0760/src/proto/terminal.pro	2017-07-17 23:20:18.335903533 +0200
--- src/proto/terminal.pro	2017-07-23 19:43:12.536384376 +0200
***************
*** 2,7 ****
  void ex_terminal(exarg_T *eap);
  void free_terminal(term_T *term);
  void write_to_term(buf_T *buffer, char_u *msg, channel_T *channel);
- void term_update_window(win_T *wp);
  void terminal_loop(void);
  /* vim: set ft=c : */
--- 2,9 ----
  void ex_terminal(exarg_T *eap);
  void free_terminal(term_T *term);
  void write_to_term(buf_T *buffer, char_u *msg, channel_T *channel);
  void terminal_loop(void);
+ void term_job_ended(job_T *job);
+ int term_job_running(buf_T *buf);
+ void term_update_window(win_T *wp);
  /* vim: set ft=c : */
*** ../vim-8.0.0760/runtime/doc/options.txt	2017-07-15 19:22:33.646179881 +0200
--- runtime/doc/options.txt	2017-07-23 18:47:49.461575415 +0200
***************
*** 1295,1302 ****
  'bufhidden' 'bh'	string (default: "")
  			local to buffer
  			{not in Vi}
- 			{not available when compiled without the |+quickfix|
- 			feature}
  	This option specifies what happens when a buffer is no longer
  	displayed in a window:
  	  <empty>	follow the global 'hidden' option
--- 1319,1324 ----
***************
*** 1331,1338 ****
  'buftype' 'bt'		string (default: "")
  			local to buffer
  			{not in Vi}
- 			{not available when compiled without the |+quickfix|
- 			feature}
  	The value of this option specifies the type of a buffer:
  	  <empty>	normal buffer
  	  nofile	buffer which is not related to a file and will not be
--- 1353,1358 ----
***************
*** 1345,1350 ****
--- 1365,1372 ----
  			or list of locations |:lwindow|
  	  help		help buffer (you are not supposed to set this
  			manually)
+ 	  terminal	buffer for a |terminal| (you are not supposed to set
+ 			this manually)
  
  	This option is used together with 'bufhidden' and 'swapfile' to
  	specify special kinds of buffers.   See |special-buffers|.
*** ../vim-8.0.0760/src/quickfix.c	2017-07-19 17:05:55.179185982 +0200
--- src/quickfix.c	2017-07-23 18:59:27.596364626 +0200
***************
*** 2169,2175 ****
  	     * quickfix window. */
  	    FOR_ALL_WINDOWS(usable_win_ptr)
  		if (usable_win_ptr->w_llist == ll_ref
! 			&& usable_win_ptr->w_buffer->b_p_bt[0] != 'q')
  		{
  		    usable_win = 1;
  		    break;
--- 2169,2175 ----
  	     * quickfix window. */
  	    FOR_ALL_WINDOWS(usable_win_ptr)
  		if (usable_win_ptr->w_llist == ll_ref
! 			&& !bt_quickfix(usable_win_ptr->w_buffer))
  		{
  		    usable_win = 1;
  		    break;
***************
*** 3450,3513 ****
  #endif /* FEAT_WINDOWS */
  
  /*
-  * Return TRUE if "buf" is the quickfix buffer.
-  */
-     int
- bt_quickfix(buf_T *buf)
- {
-     return buf != NULL && buf->b_p_bt[0] == 'q';
- }
- 
- /*
-  * Return TRUE if "buf" is a "nofile" or "acwrite" buffer.
-  * This means the buffer name is not a file name.
-  */
-     int
- bt_nofile(buf_T *buf)
- {
-     return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')
- 	    || buf->b_p_bt[0] == 'a');
- }
- 
- /*
-  * Return TRUE if "buf" is a "nowrite" or "nofile" buffer.
-  */
-     int
- bt_dontwrite(buf_T *buf)
- {
-     return buf != NULL && buf->b_p_bt[0] == 'n';
- }
- 
-     int
- bt_dontwrite_msg(buf_T *buf)
- {
-     if (bt_dontwrite(buf))
-     {
- 	EMSG(_("E382: Cannot write, 'buftype' option is set"));
- 	return TRUE;
-     }
-     return FALSE;
- }
- 
- /*
-  * Return TRUE if the buffer should be hidden, according to 'hidden', ":hide"
-  * and 'bufhidden'.
-  */
-     int
- buf_hide(buf_T *buf)
- {
-     /* 'bufhidden' overrules 'hidden' and ":hide", check it first */
-     switch (buf->b_p_bh[0])
-     {
- 	case 'u':		    /* "unload" */
- 	case 'w':		    /* "wipe" */
- 	case 'd': return FALSE;	    /* "delete" */
- 	case 'h': return TRUE;	    /* "hide" */
-     }
-     return (p_hid || cmdmod.hide);
- }
- 
- /*
   * Return TRUE when using ":vimgrep" for ":grep".
   */
      int
--- 3450,3455 ----
***************
*** 5584,5586 ****
--- 5526,5597 ----
  }
  
  #endif /* FEAT_QUICKFIX */
+ 
+ /*
+  * Return TRUE if "buf" is the quickfix buffer.
+  */
+     int
+ bt_quickfix(buf_T *buf)
+ {
+     return buf != NULL && buf->b_p_bt[0] == 'q';
+ }
+ 
+ /*
+  * Return TRUE if "buf" is a terminal buffer.
+  */
+     int
+ bt_terminal(buf_T *buf)
+ {
+     return buf != NULL && buf->b_p_bt[0] == 't';
+ }
+ 
+ /*
+  * Return TRUE if "buf" is a "nofile", "acwrite" or "terminal" buffer.
+  * This means the buffer name is not a file name.
+  */
+     int
+ bt_nofile(buf_T *buf)
+ {
+     return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')
+ 	    || buf->b_p_bt[0] == 'a'
+ 	    || buf->b_p_bt[0] == 't');
+ }
+ 
+ /*
+  * Return TRUE if "buf" is a "nowrite", "nofile" or "terminal" buffer.
+  */
+     int
+ bt_dontwrite(buf_T *buf)
+ {
+     return buf != NULL && (buf->b_p_bt[0] == 'n' || buf->b_p_bt[0] == 't');
+ }
+ 
+     int
+ bt_dontwrite_msg(buf_T *buf)
+ {
+     if (bt_dontwrite(buf))
+     {
+ 	EMSG(_("E382: Cannot write, 'buftype' option is set"));
+ 	return TRUE;
+     }
+     return FALSE;
+ }
+ 
+ /*
+  * Return TRUE if the buffer should be hidden, according to 'hidden', ":hide"
+  * and 'bufhidden'.
+  */
+     int
+ buf_hide(buf_T *buf)
+ {
+     /* 'bufhidden' overrules 'hidden' and ":hide", check it first */
+     switch (buf->b_p_bh[0])
+     {
+ 	case 'u':		    /* "unload" */
+ 	case 'w':		    /* "wipe" */
+ 	case 'd': return FALSE;	    /* "delete" */
+ 	case 'h': return TRUE;	    /* "hide" */
+     }
+     return (p_hid || cmdmod.hide);
+ }
+ 
*** ../vim-8.0.0760/src/proto/quickfix.pro	2017-04-30 14:20:53.342830874 +0200
--- src/proto/quickfix.pro	2017-07-23 19:00:02.184102487 +0200
***************
*** 12,22 ****
  void ex_copen(exarg_T *eap);
  void ex_cbottom(exarg_T *eap);
  linenr_T qf_current_entry(win_T *wp);
- int bt_quickfix(buf_T *buf);
- int bt_nofile(buf_T *buf);
- int bt_dontwrite(buf_T *buf);
- int bt_dontwrite_msg(buf_T *buf);
- int buf_hide(buf_T *buf);
  int grep_internal(cmdidx_T cmdidx);
  void ex_make(exarg_T *eap);
  int qf_get_size(exarg_T *eap);
--- 12,17 ----
***************
*** 33,36 ****
--- 28,37 ----
  void ex_cbuffer(exarg_T *eap);
  void ex_cexpr(exarg_T *eap);
  void ex_helpgrep(exarg_T *eap);
+ int bt_quickfix(buf_T *buf);
+ int bt_terminal(buf_T *buf);
+ int bt_nofile(buf_T *buf);
+ int bt_dontwrite(buf_T *buf);
+ int bt_dontwrite_msg(buf_T *buf);
+ int buf_hide(buf_T *buf);
  /* vim: set ft=c : */
*** ../vim-8.0.0760/src/structs.h	2017-07-22 18:04:04.305865781 +0200
--- src/structs.h	2017-07-23 18:49:04.485034901 +0200
***************
*** 2088,2096 ****
  #ifdef FEAT_MBYTE
      int		b_p_bomb;	/* 'bomb' */
  #endif
- #ifdef FEAT_QUICKFIX
      char_u	*b_p_bh;	/* 'bufhidden' */
      char_u	*b_p_bt;	/* 'buftype' */
  #define BUF_HAS_QF_ENTRY 1
  #define BUF_HAS_LL_ENTRY 2
      int		b_has_qf_entry;
--- 2088,2096 ----
  #ifdef FEAT_MBYTE
      int		b_p_bomb;	/* 'bomb' */
  #endif
      char_u	*b_p_bh;	/* 'bufhidden' */
      char_u	*b_p_bt;	/* 'buftype' */
+ #ifdef FEAT_QUICKFIX
  #define BUF_HAS_QF_ENTRY 1
  #define BUF_HAS_LL_ENTRY 2
      int		b_has_qf_entry;
*** ../vim-8.0.0760/src/buffer.c	2017-07-17 23:20:18.335903533 +0200
--- src/buffer.c	2017-07-23 19:33:36.988833247 +0200
***************
*** 468,474 ****
      int		del_buf = (action == DOBUF_DEL || action == DOBUF_WIPE);
      int		wipe_buf = (action == DOBUF_WIPE);
  
- #ifdef FEAT_QUICKFIX
      /*
       * Force unloading or deleting when 'bufhidden' says so.
       * The caller must take care of NOT deleting/freeing when 'bufhidden' is
--- 468,473 ----
***************
*** 487,493 ****
      }
      else if (buf->b_p_bh[0] == 'u')	/* 'bufhidden' == "unload" */
  	unload_buf = TRUE;
- #endif
  
  #ifdef FEAT_AUTOCMD
      /* Disallow deleting the buffer when it is locked (already being closed or
--- 486,491 ----
***************
*** 1982,1997 ****
  	    return NULL;
  # endif
  #endif
! #ifdef FEAT_QUICKFIX
! # ifdef FEAT_AUTOCMD
  	if (buf == curbuf)
! # endif
  	{
  	    /* Make sure 'bufhidden' and 'buftype' are empty */
  	    clear_string_option(&buf->b_p_bh);
  	    clear_string_option(&buf->b_p_bt);
  	}
- #endif
      }
      if (buf != curbuf || curbuf == NULL)
      {
--- 1980,1993 ----
  	    return NULL;
  # endif
  #endif
! #ifdef FEAT_AUTOCMD
  	if (buf == curbuf)
! #endif
  	{
  	    /* Make sure 'bufhidden' and 'buftype' are empty */
  	    clear_string_option(&buf->b_p_bh);
  	    clear_string_option(&buf->b_p_bt);
  	}
      }
      if (buf != curbuf || curbuf == NULL)
      {
***************
*** 2165,2174 ****
  	clear_string_option(&buf->b_p_fenc);
  #endif
  	clear_string_option(&buf->b_p_ff);
- #ifdef FEAT_QUICKFIX
  	clear_string_option(&buf->b_p_bh);
  	clear_string_option(&buf->b_p_bt);
- #endif
      }
  #ifdef FEAT_FIND_ID
      clear_string_option(&buf->b_p_def);
--- 2161,2168 ----
***************
*** 3668,3676 ****
  		/* remove the file name */
  		p = gettail_sep(buf + off);
  		if (p == buf + off)
! 		    /* must be a help buffer */
! 		    vim_strncpy(buf + off, (char_u *)_("help"),
  					   (size_t)(SPACE_FOR_DIR - off - 1));
  		else
  		    *p = NUL;
  
--- 3662,3682 ----
  		/* remove the file name */
  		p = gettail_sep(buf + off);
  		if (p == buf + off)
! 		{
! 		    char *txt;
! 
! #ifdef FEAT_TERMINAL
! 		    if (curbuf->b_term != NULL)
! 			txt = term_job_running(curbuf)
! 						? _("running") : _("finished");
! 		    else
! #endif
! 			txt = _("help");
! 
! 		    /* must be a help or terminal buffer */
! 		    vim_strncpy(buf + off, (char_u *)txt,
  					   (size_t)(SPACE_FOR_DIR - off - 1));
+ 		}
  		else
  		    *p = NUL;
  
*** ../vim-8.0.0760/src/ex_docmd.c	2017-07-08 14:44:45.765744977 +0200
--- src/ex_docmd.c	2017-07-23 18:50:44.828312164 +0200
***************
*** 8548,8554 ****
      {
  	if (*eap->arg == '-' || *eap->arg == '+')
  	    n += curwin->w_height;
! 	else if (n == 0 && eap->arg[0] == NUL)	/* default is very wide */
  	    n = 9999;
  	win_setheight_win((int)n, wp);
      }
--- 8548,8554 ----
      {
  	if (*eap->arg == '-' || *eap->arg == '+')
  	    n += curwin->w_height;
! 	else if (n == 0 && eap->arg[0] == NUL)	/* default is very high */
  	    n = 9999;
  	win_setheight_win((int)n, wp);
      }
***************
*** 11679,11688 ****
       */
      if ((*flagp & SSOP_FOLDS)
  	    && wp->w_buffer->b_ffname != NULL
! # ifdef FEAT_QUICKFIX
! 	    && (*wp->w_buffer->b_p_bt == NUL || wp->w_buffer->b_help)
! # endif
! 	    )
      {
  	if (put_folds(fd, wp) == FAIL)
  	    return FAIL;
--- 11679,11685 ----
       */
      if ((*flagp & SSOP_FOLDS)
  	    && wp->w_buffer->b_ffname != NULL
! 	    && (*wp->w_buffer->b_p_bt == NUL || wp->w_buffer->b_help))
      {
  	if (put_folds(fd, wp) == FAIL)
  	    return FAIL;
*** ../vim-8.0.0760/src/fileio.c	2017-07-09 11:07:11.720971332 +0200
--- src/fileio.c	2017-07-23 18:50:54.452242859 +0200
***************
*** 6882,6890 ****
       * this buffer. */
      if (buf->b_ffname == NULL
  	    || buf->b_ml.ml_mfp == NULL
- #if defined(FEAT_QUICKFIX)
  	    || *buf->b_p_bt != NUL
- #endif
  	    || buf->b_saving
  #ifdef FEAT_AUTOCMD
  	    || busy
--- 6882,6888 ----
*** ../vim-8.0.0760/src/channel.c	2017-07-22 18:38:54.978753810 +0200
--- src/channel.c	2017-07-23 19:41:46.333049321 +0200
***************
*** 4696,4701 ****
--- 4696,4705 ----
  	 * not use "job" after this! */
  	job_free(job);
      }
+ 
+ #ifdef FEAT_TERMINAL
+     term_job_ended(job);
+ #endif
  }
  
  /*
*** ../vim-8.0.0760/src/version.c	2017-07-23 18:07:51.050808235 +0200
--- src/version.c	2017-07-23 18:29:16.237612348 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     761,
  /**/

-- 
Your fault: core dumped

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
