To: vim_dev@googlegroups.com
Subject: Patch 8.0.0634
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0634
Problem:    Cannot easily get to the last quickfix list.
Solution:   Add "$" as a value for the "nr" argument of getqflist() and
            setqflist(). (Yegappan Lakshmanan)
Files:      runtime/doc/eval.txt, src/quickfix.c,
            src/testdir/test_quickfix.vim


*** ../vim-8.0.0633/runtime/doc/eval.txt	2017-04-30 16:35:22.678145560 +0200
--- runtime/doc/eval.txt	2017-06-11 14:04:01.993528533 +0200
***************
*** 4586,4597 ****
  		following string items are supported in {what}:
  			context	get the context stored with |setqflist()|
  			nr	get information for this quickfix list; zero
! 				means the current quickfix list
  			title	get the list title
  			winid	get the |window-ID| (if opened)
  			all	all of the above quickfix properties
  		Non-string items in {what} are ignored.
  		If "nr" is not present then the current quickfix list is used.
  		In case of error processing {what}, an empty dictionary is
  		returned.
  
--- 4587,4602 ----
  		following string items are supported in {what}:
  			context	get the context stored with |setqflist()|
  			nr	get information for this quickfix list; zero
! 				means the current quickfix list and '$' means
! 				the last quickfix list
  			title	get the list title
  			winid	get the |window-ID| (if opened)
  			all	all of the above quickfix properties
  		Non-string items in {what} are ignored.
  		If "nr" is not present then the current quickfix list is used.
+ 		To get the number of lists in the quickfix stack, set 'nr' to
+ 		'$' in {what}. The 'nr' value in the returned dictionary
+ 		contains the quickfix stack size.
  		In case of error processing {what}, an empty dictionary is
  		returned.
  
***************
*** 6990,6996 ****
  		argument is ignored.  The following items can be specified in
  		{what}:
  		    context	any Vim type can be stored as a context
! 		    nr		list number in the quickfix stack
  		    title	quickfix list title text
  		Unsupported keys in {what} are ignored.
  		If the "nr" item is not present, then the current quickfix list
--- 6995,7003 ----
  		argument is ignored.  The following items can be specified in
  		{what}:
  		    context	any Vim type can be stored as a context
! 		    nr		list number in the quickfix stack; zero
! 				means the current quickfix list and '$' means
! 				the last quickfix list
  		    title	quickfix list title text
  		Unsupported keys in {what} are ignored.
  		If the "nr" item is not present, then the current quickfix list
*** ../vim-8.0.0633/src/quickfix.c	2017-06-04 15:30:30.038847999 +0200
--- src/quickfix.c	2017-06-11 14:04:01.993528533 +0200
***************
*** 4670,4676 ****
--- 4670,4683 ----
      {
  	qi = GET_LOC_LIST(wp);
  	if (qi == NULL)
+ 	{
+ 	    /* If querying for the size of the location list, return 0 */
+ 	    if (((di = dict_find(what, (char_u *)"nr", -1)) != NULL) &&
+ 		    (di->di_tv.v_type == VAR_STRING) &&
+ 		    (STRCMP(di->di_tv.vval.v_string, "$") == 0))
+ 		    return dict_add_nr_str(retdict, "nr", 0, NULL);
  	    return FAIL;
+ 	}
      }
  
      qf_idx = qi->qf_curlist;		/* default is the current list */
***************
*** 4685,4690 ****
--- 4692,4709 ----
  		qf_idx = di->di_tv.vval.v_number - 1;
  		if (qf_idx < 0 || qf_idx >= qi->qf_listcount)
  		    return FAIL;
+ 	    } else if (qi->qf_listcount == 0)	    /* stack is empty */
+ 		return FAIL;
+ 	    flags |= QF_GETLIST_NR;
+ 	} else if ((di->di_tv.v_type == VAR_STRING) &&
+ 		(STRCMP(di->di_tv.vval.v_string, "$") == 0))
+ 	{
+ 	    {
+ 		/* Get the last quickfix list number */
+ 		if (qi->qf_listcount > 0)
+ 		    qf_idx = qi->qf_listcount - 1;
+ 		else
+ 		    qf_idx = -1;	/* Quickfix stack is empty */
  	    }
  	    flags |= QF_GETLIST_NR;
  	}
***************
*** 4692,4708 ****
  	    return FAIL;
      }
  
!     if (dict_find(what, (char_u *)"all", -1) != NULL)
! 	flags |= QF_GETLIST_ALL;
  
!     if (dict_find(what, (char_u *)"title", -1) != NULL)
! 	flags |= QF_GETLIST_TITLE;
  
!     if (dict_find(what, (char_u *)"winid", -1) != NULL)
! 	flags |= QF_GETLIST_WINID;
  
!     if (dict_find(what, (char_u *)"context", -1) != NULL)
! 	flags |= QF_GETLIST_CONTEXT;
  
      if (flags & QF_GETLIST_TITLE)
      {
--- 4711,4730 ----
  	    return FAIL;
      }
  
!     if (qf_idx != -1)
!     {
! 	if (dict_find(what, (char_u *)"all", -1) != NULL)
! 	    flags |= QF_GETLIST_ALL;
  
! 	if (dict_find(what, (char_u *)"title", -1) != NULL)
! 	    flags |= QF_GETLIST_TITLE;
  
! 	if (dict_find(what, (char_u *)"winid", -1) != NULL)
! 	    flags |= QF_GETLIST_WINID;
  
! 	if (dict_find(what, (char_u *)"context", -1) != NULL)
! 	    flags |= QF_GETLIST_CONTEXT;
!     }
  
      if (flags & QF_GETLIST_TITLE)
      {
***************
*** 4895,4901 ****
  		qf_idx = di->di_tv.vval.v_number - 1;
  	    if (qf_idx < 0 || qf_idx >= qi->qf_listcount)
  		return FAIL;
! 	}
  	else
  	    return FAIL;
  	newlist = FALSE;	/* use the specified list */
--- 4917,4926 ----
  		qf_idx = di->di_tv.vval.v_number - 1;
  	    if (qf_idx < 0 || qf_idx >= qi->qf_listcount)
  		return FAIL;
! 	} else if (di->di_tv.v_type == VAR_STRING &&
! 		STRCMP(di->di_tv.vval.v_string, "$") == 0 &&
! 		qi->qf_listcount > 0)
! 	    qf_idx = qi->qf_listcount - 1;
  	else
  	    return FAIL;
  	newlist = FALSE;	/* use the specified list */
***************
*** 4923,4928 ****
--- 4948,4954 ----
      if ((di = dict_find(what, (char_u *)"context", -1)) != NULL)
      {
  	typval_T	*ctx;
+ 
  	free_tv(qi->qf_lists[qf_idx].qf_ctx);
  	ctx =  alloc_tv();
  	if (ctx != NULL)
*** ../vim-8.0.0633/src/testdir/test_quickfix.vim	2017-05-28 08:16:18.783611080 +0200
--- src/testdir/test_quickfix.vim	2017-06-11 14:06:24.284658903 +0200
***************
*** 1650,1661 ****
        call assert_fails('lbottom', 'E776:')
    endif
  
!   call g:Xsetlist([{'filename': 'foo', 'lnum': 42}]) 
    Xopen
    let wid = win_getid()
    call assert_equal(1, line('.'))
    wincmd w
!   call g:Xsetlist([{'filename': 'var', 'lnum': 24}], 'a') 
    Xbottom
    call win_gotoid(wid)
    call assert_equal(2, line('.'))
--- 1650,1661 ----
        call assert_fails('lbottom', 'E776:')
    endif
  
!   call g:Xsetlist([{'filename': 'foo', 'lnum': 42}])
    Xopen
    let wid = win_getid()
    call assert_equal(1, line('.'))
    wincmd w
!   call g:Xsetlist([{'filename': 'var', 'lnum': 24}], 'a')
    Xbottom
    call win_gotoid(wid)
    call assert_equal(2, line('.'))
***************
*** 2120,2122 ****
--- 2120,2162 ----
    set efm&vim
  endfunc
  
+ func Test_cclose_from_copen()
+     augroup QF_Test
+ 	au!
+ 	au FileType qf :cclose
+     augroup END
+     copen
+     augroup QF_Test
+ 	au!
+     augroup END
+     augroup! QF_Test
+ endfunc
+ 
+ " Tests for getting the quickfix stack size
+ func XsizeTests(cchar)
+   call s:setup_commands(a:cchar)
+ 
+   call g:Xsetlist([], 'f')
+   call assert_equal(0, g:Xgetlist({'nr':'$'}).nr)
+   call assert_equal(1, len(g:Xgetlist({'nr':'$', 'all':1})))
+   call assert_equal(0, len(g:Xgetlist({'nr':0})))
+ 
+   Xexpr "File1:10:Line1"
+   Xexpr "File2:20:Line2"
+   Xexpr "File3:30:Line3"
+   Xolder | Xolder
+   call assert_equal(3, g:Xgetlist({'nr':'$'}).nr)
+   call g:Xsetlist([], 'f')
+ 
+   Xexpr "File1:10:Line1"
+   Xexpr "File2:20:Line2"
+   Xexpr "File3:30:Line3"
+   Xolder | Xolder
+   call g:Xsetlist([], 'a', {'nr':'$', 'title':'Compiler'})
+   call assert_equal('Compiler', g:Xgetlist({'nr':3, 'all':1}).title)
+ endfunc
+ 
+ func Test_Qf_Size()
+   call XsizeTests('c')
+   call XsizeTests('l')
+ endfunc
*** ../vim-8.0.0633/src/version.c	2017-06-10 17:06:12.904454422 +0200
--- src/version.c	2017-06-11 14:05:36.348951853 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     634,
  /**/

-- 
Now it is such a bizarrely improbable coincidence that anything as
mind-bogglingly useful as the Babel fish could have evolved purely by chance
that some thinkers have chosen to see it as a final and clinching proof of the
NON-existence of God.
The argument goes something like this: 'I refuse to prove that I exist,' says
God, 'for proof denies faith, and without faith I am nothing.'
'But,' says Man, 'the Babel fish is a dead giveaway, isn't it?  It could not
have evolved by chance.  It proves you exist, and so therefore, by your own
arguments, you don't.  QED.'
'Oh dear,' says God, 'I hadn't thought of that,' and promptly vanishes in a
puff of logic.
'Oh, that was easy,' says Man, and for an encore goes on to prove that black
is white and gets himself killed on the next pedestrian crossing.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
