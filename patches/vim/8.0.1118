To: vim_dev@googlegroups.com
Subject: Patch 8.0.1118
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1118
Problem:    FEAT_WINDOWS adds a lot of #ifdefs while it is nearly always
            enabled and only adds 7% to the binary size of the tiny build.
Solution:   Graduate FEAT_WINDOWS.
Files:      src/feature.h, src/window.c, src/vim.h, src/structs.h,
            src/globals.h, src/gui.h, src/if_py_both.h, src/option.h,
            src/term.h, src/buffer.c, src/charset.c, src/digraph.c,
            src/edit.c, src/eval.c, src/evalfunc.c, src/ex_cmds.c,
            src/ex_cmds2.c, src/ex_docmd.c, src/ex_getln.c, src/fileio.c,
            src/fold.c, src/getchar.c, src/gui.c, src/gui_athena.c,
            src/gui_beval.c, src/gui_gtk.c, src/gui_motif.c, src/gui_w32.c,
            src/if_cscope.c, src/if_lua.c, src/if_mzsch.c, src/if_python.c,
            src/if_python3.c, src/if_ruby.c, src/if_tcl.c, src/main.c,
            src/mark.c, src/memline.c, src/misc1.c, src/misc2.c, src/move.c,
            src/netbeans.c, src/normal.c, src/option.c, src/popupmnu.c,
            src/quickfix.c, src/screen.c, src/search.c, src/spell.c,
            src/syntax.c, src/tag.c, src/term.c, src/ui.c, src/version.c,
            src/workshop.c, src/if_perl.xs, src/testdir/test_normal.vim


*** ../vim-8.0.1117/src/feature.h	2017-08-22 22:21:33.497436406 +0200
--- src/feature.h	2017-09-16 20:25:43.845009925 +0200
***************
*** 94,106 ****
   */
  
  /*
   * +windows		Multiple windows.  Without this there is no help
   *			window and no status lines.
   * +vertsplit		Vertically split windows.
   */
- #ifdef FEAT_SMALL
- # define FEAT_WINDOWS
- #endif
  
  /*
   * +listcmds		Vim commands for the buffer list and the argument
--- 94,104 ----
   */
  
  /*
+  * These features used to be optional but are now always enabled.
   * +windows		Multiple windows.  Without this there is no help
   *			window and no status lines.
   * +vertsplit		Vertically split windows.
   */
  
  /*
   * +listcmds		Vim commands for the buffer list and the argument
***************
*** 134,141 ****
  # define FEAT_JUMPLIST
  #endif
  
! /* the cmdline-window requires FEAT_WINDOWS and FEAT_CMDHIST */
! #if defined(FEAT_WINDOWS) && defined(FEAT_CMDHIST)
  # define FEAT_CMDWIN
  #endif
  
--- 132,139 ----
  # define FEAT_JUMPLIST
  #endif
  
! /* the cmdline-window requires FEAT_CMDHIST */
! #if defined(FEAT_CMDHIST)
  # define FEAT_CMDWIN
  #endif
  
***************
*** 452,458 ****
   * +diff		Displaying diffs in a nice way.
   *			Requires +windows and +autocmd.
   */
! #if defined(FEAT_NORMAL) && defined(FEAT_WINDOWS) && defined(FEAT_AUTOCMD)
  # define FEAT_DIFF
  #endif
  
--- 450,456 ----
   * +diff		Displaying diffs in a nice way.
   *			Requires +windows and +autocmd.
   */
! #if defined(FEAT_NORMAL) && defined(FEAT_AUTOCMD)
  # define FEAT_DIFF
  #endif
  
***************
*** 490,496 ****
  /*
   * +wildmenu		'wildmenu' option
   */
! #if defined(FEAT_NORMAL) && defined(FEAT_WINDOWS)
  # define FEAT_WILDMENU
  #endif
  
--- 488,494 ----
  /*
   * +wildmenu		'wildmenu' option
   */
! #if defined(FEAT_NORMAL)
  # define FEAT_WILDMENU
  #endif
  
***************
*** 595,601 ****
   * +mksession		":mksession" command.
   *			Requires +windows and +vertsplit.
   */
! #if defined(FEAT_NORMAL) && defined(FEAT_WINDOWS)
  # define FEAT_SESSION
  #endif
  
--- 593,599 ----
   * +mksession		":mksession" command.
   *			Requires +windows and +vertsplit.
   */
! #if defined(FEAT_NORMAL)
  # define FEAT_SESSION
  #endif
  
***************
*** 706,719 ****
  /*
   * +scrollbind		synchronization of split windows
   */
! #if defined(FEAT_NORMAL) && defined(FEAT_WINDOWS)
  # define FEAT_SCROLLBIND
  #endif
  
  /*
   * +cursorbind		synchronization of split windows
   */
! #if defined(FEAT_NORMAL) && defined(FEAT_WINDOWS)
  # define FEAT_CURSORBIND
  #endif
  
--- 704,717 ----
  /*
   * +scrollbind		synchronization of split windows
   */
! #if defined(FEAT_NORMAL)
  # define FEAT_SCROLLBIND
  #endif
  
  /*
   * +cursorbind		synchronization of split windows
   */
! #if defined(FEAT_NORMAL)
  # define FEAT_CURSORBIND
  #endif
  
***************
*** 754,760 ****
  /*
   * GUI tabline
   */
! #if defined(FEAT_WINDOWS) && defined(FEAT_NORMAL) \
      && (defined(FEAT_GUI_GTK) \
  	|| (defined(FEAT_GUI_MOTIF) && defined(HAVE_XM_NOTEBOOK_H)) \
  	|| defined(FEAT_GUI_MAC) \
--- 752,758 ----
  /*
   * GUI tabline
   */
! #if defined(FEAT_NORMAL) \
      && (defined(FEAT_GUI_GTK) \
  	|| (defined(FEAT_GUI_MOTIF) && defined(HAVE_XM_NOTEBOOK_H)) \
  	|| defined(FEAT_GUI_MAC) \
*** ../vim-8.0.1117/src/window.c	2017-08-03 22:44:51.046797665 +0200
--- src/window.c	2017-09-16 18:26:49.611566351 +0200
***************
*** 10,16 ****
  #include "vim.h"
  
  static int path_is_url(char_u *p);
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  static void cmd_with_count(char *cmd, char_u *bufp, size_t bufsize, long Prenum);
  static void win_init(win_T *newp, win_T *oldp, int flags);
  static void win_init_some(win_T *newp, win_T *oldp);
--- 10,15 ----
***************
*** 36,45 ****
  static void frame_add_vsep(frame_T *frp);
  static int frame_minwidth(frame_T *topfrp, win_T *next_curwin);
  static void frame_fix_width(win_T *wp);
- #endif
  static int win_alloc_firstwin(win_T *oldwin);
  static void new_frame(win_T *wp);
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  static tabpage_T *alloc_tabpage(void);
  static int leave_tabpage(buf_T *new_curbuf, int trigger_leave_autocmds);
  static void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, int trigger_enter_autocmds, int trigger_leave_autocmds);
--- 35,42 ----
***************
*** 64,71 ****
  static int frame_check_height(frame_T *topfrp, int height);
  static int frame_check_width(frame_T *topfrp, int width);
  
- #endif /* FEAT_WINDOWS */
- 
  static win_T *win_alloc(win_T *after, int hidden);
  
  #define URL_SLASH	1		/* path_is_url() has found "://" */
--- 61,66 ----
***************
*** 73,85 ****
  
  #define NOWIN		(win_T *)-1	/* non-existing window */
  
! #ifdef FEAT_WINDOWS
! # define ROWS_AVAIL (Rows - p_ch - tabline_height())
! #else
! # define ROWS_AVAIL (Rows - p_ch)
! #endif
! 
! #if defined(FEAT_WINDOWS) || defined(PROTO)
  
  static char *m_onlyone = N_("Already only one window");
  
--- 68,74 ----
  
  #define NOWIN		(win_T *)-1	/* non-existing window */
  
! #define ROWS_AVAIL (Rows - p_ch - tabline_height())
  
  static char *m_onlyone = N_("Already only one window");
  
***************
*** 198,204 ****
  		do_cmdline_cmd(cbuf);
  		break;
  
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  /* close preview window */
      case Ctrl_Z:
      case 'z':
--- 187,193 ----
  		do_cmdline_cmd(cbuf);
  		break;
  
! #if defined(FEAT_QUICKFIX)
  /* close preview window */
      case Ctrl_Z:
      case 'z':
***************
*** 1354,1362 ****
      win_copy_options(oldp, newp);
  }
  
- #endif /* FEAT_WINDOWS */
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * Check if "win" is a pointer to an existing window in the current tab page.
   */
--- 1343,1349 ----
***************
*** 2596,2605 ****
  {
      int		dummy;
  
- # ifdef FEAT_WINDOWS
      while (first_tabpage->tp_next != NULL)
  	tabpage_close(TRUE);
- # endif
  
  # ifdef FEAT_AUTOCMD
      if (aucmd_win != NULL)
--- 2583,2590 ----
***************
*** 3388,3395 ****
  	EMSG(_("E445: Other window contains changes"));
  }
  
- #endif /* FEAT_WINDOWS */
- 
  /*
   * Init the current window "curwin".
   * Called when a new file is being edited.
--- 3373,3378 ----
***************
*** 3441,3453 ****
      if (win_alloc_firstwin(NULL) == FAIL)
  	return FAIL;
  
- #ifdef FEAT_WINDOWS
      first_tabpage = alloc_tabpage();
      if (first_tabpage == NULL)
  	return FAIL;
      first_tabpage->tp_topframe = topframe;
      curtab = first_tabpage;
- #endif
  
      return OK;
  }
--- 3424,3434 ----
***************
*** 3473,3480 ****
  /*
   * Allocate the first window or the first window in a new tab page.
   * When "oldwin" is NULL create an empty buffer for it.
!  * When "oldwin" is not NULL copy info from it to the new window (only with
!  * FEAT_WINDOWS).
   * Return FAIL when something goes wrong (out of memory).
   */
      static int
--- 3454,3460 ----
  /*
   * Allocate the first window or the first window in a new tab page.
   * When "oldwin" is NULL create an empty buffer for it.
!  * When "oldwin" is not NULL copy info from it to the new window.
   * Return FAIL when something goes wrong (out of memory).
   */
      static int
***************
*** 3493,3504 ****
  	curwin->w_s = &(curbuf->b_s);
  #endif
  	curbuf->b_nwindows = 1;	/* there is one window */
- #ifdef FEAT_WINDOWS
  	curwin->w_alist = &global_alist;
- #endif
  	curwin_init();		/* init current window */
      }
- #ifdef FEAT_WINDOWS
      else
      {
  	/* First window in new tab page, initialize it from "oldwin". */
--- 3473,3481 ----
***************
*** 3507,3521 ****
  	/* We don't want cursor- and scroll-binding in the first window. */
  	RESET_BINDING(curwin);
      }
- #endif
  
      new_frame(curwin);
      if (curwin->w_frame == NULL)
  	return FAIL;
      topframe = curwin->w_frame;
- #ifdef FEAT_WINDOWS
      topframe->fr_width = Columns;
- #endif
      topframe->fr_height = Rows - p_ch;
      topframe->fr_win = curwin;
  
--- 3484,3495 ----
***************
*** 3546,3559 ****
  {
      firstwin->w_height = ROWS_AVAIL;
      topframe->fr_height = ROWS_AVAIL;
- #ifdef FEAT_WINDOWS
      firstwin->w_width = Columns;
      topframe->fr_width = Columns;
- #endif
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
- 
  /*
   * Allocate a new tabpage_T and init the values.
   * Returns NULL when out of memory.
--- 3520,3529 ----
***************
*** 4185,4203 ****
  {
      win_T	*wp;
  
- # ifdef FEAT_WINDOWS
      FOR_ALL_WINDOWS(wp)
  	if (--winnr == 0)
  	    break;
      return wp;
- # else
-     return curwin;
- # endif
  }
  #endif
  
! #if (defined(FEAT_WINDOWS) && (defined(FEAT_PYTHON) || defined(FEAT_PYTHON3))) \
! 	|| defined(PROTO)
  /*
   * Find the tabpage for window "win".
   */
--- 4155,4168 ----
  {
      win_T	*wp;
  
      FOR_ALL_WINDOWS(wp)
  	if (--winnr == 0)
  	    break;
      return wp;
  }
  #endif
  
! #if ((defined(FEAT_PYTHON) || defined(FEAT_PYTHON3))) || defined(PROTO)
  /*
   * Find the tabpage for window "win".
   */
***************
*** 4481,4489 ****
      DO_AUTOCHDIR
  }
  
- #endif /* FEAT_WINDOWS */
  
- #if defined(FEAT_WINDOWS) || defined(FEAT_SIGNS) || defined(PROTO)
  /*
   * Jump to the first open window that contains buffer "buf", if one exists.
   * Returns a pointer to the window found, otherwise NULL.
--- 4446,4452 ----
***************
*** 4495,4508 ****
  
      if (curwin->w_buffer == buf)
  	wp = curwin;
- # ifdef FEAT_WINDOWS
      else
  	FOR_ALL_WINDOWS(wp)
  	    if (wp->w_buffer == buf)
  		break;
      if (wp != NULL)
  	win_enter(wp, FALSE);
- # endif
      return wp;
  }
  
--- 4458,4469 ----
***************
*** 4515,4521 ****
  buf_jump_open_tab(buf_T *buf)
  {
      win_T	*wp = buf_jump_open_win(buf);
- # ifdef FEAT_WINDOWS
      tabpage_T	*tp;
  
      if (wp != NULL)
--- 4476,4481 ----
***************
*** 4535,4544 ****
  		break;
  	    }
  	}
- # endif
      return wp;
  }
- #endif
  
  static int last_win_id = LOWEST_WIN_ID - 1;
  
--- 4495,4502 ----
***************
*** 4587,4598 ****
      /*
       * link the window in the window list
       */
- #ifdef FEAT_WINDOWS
      if (!hidden)
  	win_append(after, new_wp);
      new_wp->w_wincol = 0;
      new_wp->w_width = Columns;
- #endif
  
      /* position the display and the cursor at the top of the file. */
      new_wp->w_topline = 1;
--- 4545,4554 ----
***************
*** 4631,4638 ****
      return new_wp;
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
- 
  /*
   * Remove window 'wp' from the window list and free the structure.
   */
--- 4587,4592 ----
***************
*** 4850,4857 ****
  	frp->fr_next->fr_prev = frp->fr_prev;
  }
  
- #endif /* FEAT_WINDOWS */
- 
  /*
   * Allocate w_lines[] for window "wp".
   * Return FAIL for failure, OK for success.
--- 4804,4809 ----
***************
*** 4891,4897 ****
  
      if (firstwin == NULL)	/* not initialized yet */
  	return;
- #ifdef FEAT_WINDOWS
      if (h < frame_minheight(topframe, NULL))
  	h = frame_minheight(topframe, NULL);
  
--- 4843,4848 ----
***************
*** 4902,4916 ****
  	frame_new_height(topframe, h, FALSE, FALSE);
  
      (void)win_comp_pos();		/* recompute w_winrow and w_wincol */
- #else
-     if (h < 1)
- 	h = 1;
-     win_new_height(firstwin, h);
- #endif
      compute_cmdrow();
- #ifdef FEAT_WINDOWS
      curtab->tp_ch_used = p_ch;
- #endif
  
  #if 0
      /* Disabled: don't want making the screen smaller make a window larger. */
--- 4853,4860 ----
***************
*** 4919,4925 ****
  #endif
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * Called from win_new_shellsize() after Columns changed.
   */
--- 4863,4868 ----
***************
*** 4942,4948 ****
  	win_equal(curwin, FALSE, 'h');
  #endif
  }
- #endif
  
  #if defined(FEAT_CMDWIN) || defined(PROTO)
  /*
--- 4885,4890 ----
***************
*** 4993,4999 ****
  }
  #endif /* FEAT_CMDWIN */
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * Update the position for all windows, using the width and height of the
   * frames.
--- 4935,4940 ----
***************
*** 5052,5059 ****
      }
  }
  
- #endif /* FEAT_WINDOWS */
- 
  /*
   * Set current window height and take care of repositioning other windows to
   * fit around it.
--- 4993,4998 ----
***************
*** 5077,5101 ****
      {
  	/* Always keep current window at least one line high, even when
  	 * 'winminheight' is zero. */
- #ifdef FEAT_WINDOWS
  	if (height < p_wmh)
  	    height = p_wmh;
- #endif
  	if (height == 0)
  	    height = 1;
      }
  
- #ifdef FEAT_WINDOWS
      frame_setheight(win->w_frame, height + win->w_status_height);
  
      /* recompute the window positions */
      row = win_comp_pos();
- #else
-     if (height > topframe->fr_height)
- 	height = topframe->fr_height;
-     win->w_height = height;
-     row = height;
- #endif
  
      /*
       * If there is extra space created between the last window and the command
--- 5016,5031 ----
***************
*** 5110,5117 ****
      redraw_all_later(NOT_VALID);
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
- 
  /*
   * Set the height of a frame to "height" and take care that all frames and
   * windows inside it are resized.  Also resize frames on the left and right if
--- 5040,5045 ----
***************
*** 5725,5732 ****
  }
  #endif /* FEAT_MOUSE */
  
- #endif /* FEAT_WINDOWS */
- 
  #define FRACTION_MULT	16384L
  
  /*
--- 5653,5658 ----
***************
*** 5898,5910 ****
  
      win_comp_scroll(wp);
      redraw_win_later(wp, SOME_VALID);
- #ifdef FEAT_WINDOWS
      wp->w_redr_status = TRUE;
- #endif
      invalidate_botline_win(wp);
  }
  
- #ifdef FEAT_WINDOWS
  /*
   * Set the width of a window.
   */
--- 5824,5833 ----
***************
*** 5923,5929 ****
      redraw_win_later(wp, NOT_VALID);
      wp->w_redr_status = TRUE;
  }
- #endif
  
      void
  win_comp_scroll(win_T *wp)
--- 5846,5851 ----
***************
*** 5939,5945 ****
      void
  command_height(void)
  {
- #ifdef FEAT_WINDOWS
      int		h;
      frame_T	*frp;
      int		old_p_ch = curtab->tp_ch_used;
--- 5861,5866 ----
***************
*** 6004,6016 ****
      /* Recompute window positions. */
      if (frp != lastwin->w_frame)
  	(void)win_comp_pos();
- #else
-     cmdline_row = Rows - p_ch;
-     win_setheight(cmdline_row);
- #endif
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * Resize frame "frp" to be "n" lines higher (negative for less high).
   * Also resize the frames it is contained in.
--- 5925,5932 ----
***************
*** 6122,6129 ****
      return 1;
  }
  
- #endif /* FEAT_WINDOWS */
- 
  #if defined(FEAT_SEARCHPATH) || defined(PROTO)
  /*
   * Get the file name at the cursor.
--- 6038,6043 ----
***************
*** 6438,6452 ****
  min_rows(void)
  {
      int		total;
- #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
      int		n;
- #endif
  
      if (firstwin == NULL)	/* not initialized yet */
  	return MIN_LINES;
  
- #ifdef FEAT_WINDOWS
      total = 0;
      FOR_ALL_TABPAGES(tp)
      {
--- 6352,6363 ----
***************
*** 6455,6463 ****
  	    total = n;
      }
      total += tabline_height();
- #else
-     total = 1;		/* at least one window should have a line! */
- #endif
      total += 1;		/* count the room for the command line */
      return total;
  }
--- 6366,6371 ----
***************
*** 6470,6476 ****
      int
  only_one_window(void)
  {
- #ifdef FEAT_WINDOWS
      int		count = 0;
      win_T	*wp;
  
--- 6378,6383 ----
***************
*** 6491,6502 ****
  	   )
  	    ++count;
      return (count <= 1);
- #else
-     return TRUE;
- #endif
  }
  
- #if defined(FEAT_WINDOWS) || defined(FEAT_AUTOCMD) || defined(PROTO)
  /*
   * Correct the cursor line number in other windows.  Used after changing the
   * current buffer, and before applying autocommands.
--- 6398,6405 ----
***************
*** 6506,6521 ****
  check_lnums(int do_curwin)
  {
      win_T	*wp;
- 
- #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
  
      FOR_ALL_TAB_WINDOWS(tp, wp)
  	if ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)
- #else
-     wp = curwin;
-     if (do_curwin)
- #endif
  	{
  	    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)
  		wp->w_cursor.lnum = curbuf->b_ml.ml_line_count;
--- 6409,6418 ----
***************
*** 6523,6531 ****
  		wp->w_topline = curbuf->b_ml.ml_line_count;
  	}
  }
- #endif
- 
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  
  /*
   * A snapshot of the window sizes, to restore them after closing the help
--- 6420,6425 ----
***************
*** 6666,6673 ****
      return wp;
  }
  
- #endif
- 
  #if defined(FEAT_EVAL) || defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) \
  	|| defined(PROTO)
  /*
--- 6560,6565 ----
***************
*** 6689,6695 ****
  # ifdef FEAT_AUTOCMD
      block_autocmds();
  # endif
- # ifdef FEAT_WINDOWS
      *save_curwin = curwin;
      if (tp != NULL)
      {
--- 6581,6586 ----
***************
*** 6709,6715 ****
  	return FAIL;
      curwin = win;
      curbuf = curwin->w_buffer;
- # endif
      return OK;
  }
  
--- 6600,6605 ----
***************
*** 6724,6730 ****
      tabpage_T	*save_curtab UNUSED,
      int		no_display UNUSED)
  {
- # ifdef FEAT_WINDOWS
      if (save_curtab != NULL && valid_tabpage(save_curtab))
      {
  	if (no_display)
--- 6614,6619 ----
***************
*** 6743,6749 ****
  	curwin = save_curwin;
  	curbuf = curwin->w_buffer;
      }
- # endif
  # ifdef FEAT_AUTOCMD
      unblock_autocmds();
  # endif
--- 6632,6637 ----
***************
*** 6786,6792 ****
  }
  #endif
  
! #if (defined(FEAT_GUI) && defined(FEAT_WINDOWS)) || defined(PROTO)
  /*
   * Return TRUE if there is any vertically split window.
   */
--- 6674,6680 ----
  }
  #endif
  
! #if defined(FEAT_GUI) || defined(PROTO)
  /*
   * Return TRUE if there is any vertically split window.
   */
***************
*** 7121,7127 ****
  get_tab_number(tabpage_T *tp UNUSED)
  {
      int		i = 1;
- # ifdef FEAT_WINDOWS
      tabpage_T	*t;
  
      for (t = first_tabpage; t != NULL && t != tp; t = t->tp_next)
--- 7009,7014 ----
***************
*** 7130,7141 ****
      if (t == NULL)
  	return 0;
      else
- # endif
  	return i;
  }
  #endif
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * Return TRUE if "topfrp" and its children are at the right height.
   */
--- 7017,7026 ----
***************
*** 7154,7162 ****
  
      return TRUE;
  }
- #endif
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * Return TRUE if "topfrp" and its children are at the right width.
   */
--- 7039,7045 ----
***************
*** 7175,7181 ****
  
      return TRUE;
  }
- #endif
  
  #if defined(FEAT_EVAL) || defined(PROTO)
      int
--- 7058,7063 ----
*** ../vim-8.0.1117/src/vim.h	2017-09-14 20:37:49.963213752 +0200
--- src/vim.h	2017-09-16 18:27:46.863228312 +0200
***************
*** 859,882 ****
  #define FINDFILE_DIR	1	/* only directories */
  #define FINDFILE_BOTH	2	/* files and directories */
  
! #ifdef FEAT_WINDOWS
! # define W_WINCOL(wp)	(wp->w_wincol)
! # define W_WIDTH(wp)	(wp->w_width)
! # define W_ENDCOL(wp)	(wp->w_wincol + wp->w_width)
! # define W_VSEP_WIDTH(wp) (wp->w_vsep_width)
! #else
! # define W_WINCOL(wp)	0
! # define W_WIDTH(wp)	Columns
! # define W_ENDCOL(wp)	Columns
! # define W_VSEP_WIDTH(wp) 0
! #endif
! #ifdef FEAT_WINDOWS
! # define W_STATUS_HEIGHT(wp) (wp->w_status_height)
! # define W_WINROW(wp)	(wp->w_winrow)
! #else
! # define W_STATUS_HEIGHT(wp) 0
! # define W_WINROW(wp)	0
! #endif
  
  #ifdef NO_EXPANDPATH
  # define gen_expand_wildcards mch_expand_wildcards
--- 859,870 ----
  #define FINDFILE_DIR	1	/* only directories */
  #define FINDFILE_BOTH	2	/* files and directories */
  
! #define W_WINCOL(wp)	(wp->w_wincol)
! #define W_WIDTH(wp)	(wp->w_width)
! #define W_ENDCOL(wp)	(wp->w_wincol + wp->w_width)
! #define W_VSEP_WIDTH(wp) (wp->w_vsep_width)
! #define W_STATUS_HEIGHT(wp) (wp->w_status_height)
! #define W_WINROW(wp)	(wp->w_winrow)
  
  #ifdef NO_EXPANDPATH
  # define gen_expand_wildcards mch_expand_wildcards
*** ../vim-8.0.1117/src/structs.h	2017-09-08 14:39:25.642102863 +0200
--- src/structs.h	2017-09-16 18:29:52.934484052 +0200
***************
*** 205,217 ****
      long	wo_nuw;
  # define w_p_nuw w_onebuf_opt.wo_nuw	/* 'numberwidth' */
  #endif
- #if defined(FEAT_WINDOWS)
      int		wo_wfh;
  # define w_p_wfh w_onebuf_opt.wo_wfh	/* 'winfixheight' */
      int		wo_wfw;
  # define w_p_wfw w_onebuf_opt.wo_wfw	/* 'winfixwidth' */
! #endif
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      int		wo_pvw;
  # define w_p_pvw w_onebuf_opt.wo_pvw	/* 'previewwindow' */
  #endif
--- 205,215 ----
      long	wo_nuw;
  # define w_p_nuw w_onebuf_opt.wo_nuw	/* 'numberwidth' */
  #endif
      int		wo_wfh;
  # define w_p_wfh w_onebuf_opt.wo_wfh	/* 'winfixheight' */
      int		wo_wfw;
  # define w_p_wfw w_onebuf_opt.wo_wfw	/* 'winfixwidth' */
! #if defined(FEAT_QUICKFIX)
      int		wo_pvw;
  # define w_p_pvw w_onebuf_opt.wo_pvw	/* 'previewwindow' */
  #endif
***************
*** 570,579 ****
  # ifdef FEAT_BROWSE_CMD
      int		browse;			/* TRUE to invoke file dialog */
  # endif
- # ifdef FEAT_WINDOWS
      int		split;			/* flags for win_split() */
      int		tab;			/* > 0 when ":tab" was used */
- # endif
  # if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
      int		confirm;		/* TRUE to invoke yes/no dialog */
  # endif
--- 568,575 ----
***************
*** 728,738 ****
      int		ae_fnum;	/* buffer number with expanded file name */
  } aentry_T;
  
! #ifdef FEAT_WINDOWS
! # define ALIST(win) (win)->w_alist
! #else
! # define ALIST(win) (&global_alist)
! #endif
  #define GARGLIST	((aentry_T *)global_alist.al_ga.ga_data)
  #define ARGLIST		((aentry_T *)ALIST(curwin)->al_ga.ga_data)
  #define WARGLIST(wp)	((aentry_T *)ALIST(wp)->al_ga.ga_data)
--- 724,730 ----
      int		ae_fnum;	/* buffer number with expanded file name */
  } aentry_T;
  
! #define ALIST(win)	(win)->w_alist
  #define GARGLIST	((aentry_T *)global_alist.al_ga.ga_data)
  #define ARGLIST		((aentry_T *)ALIST(curwin)->al_ga.ga_data)
  #define WARGLIST(wp)	((aentry_T *)ALIST(wp)->al_ga.ga_data)
***************
*** 2531,2540 ****
  struct frame_S
  {
      char	fr_layout;	/* FR_LEAF, FR_COL or FR_ROW */
- #ifdef FEAT_WINDOWS
      int		fr_width;
      int		fr_newwidth;	/* new width used in win_equal_rec() */
- #endif
      int		fr_height;
      int		fr_newheight;	/* new height used in win_equal_rec() */
      frame_T	*fr_parent;	/* containing frame or NULL */
--- 2523,2530 ----
***************
*** 2637,2646 ****
      synblock_T	*w_s;		    /* for :ownsyntax */
  #endif
  
- #ifdef FEAT_WINDOWS
      win_T	*w_prev;	    /* link to previous window */
      win_T	*w_next;	    /* link to next window */
- #endif
  #ifdef FEAT_AUTOCMD
      int		w_closing;	    /* window is being closed, don't let
  				       autocommands close it too. */
--- 2627,2634 ----
***************
*** 2696,2707 ****
       * Layout of the window in the screen.
       * May need to add "msg_scrolled" to "w_winrow" in rare situations.
       */
- #ifdef FEAT_WINDOWS
      int		w_winrow;	    /* first row of window in screen */
- #endif
      int		w_height;	    /* number of rows in window, excluding
  				       status/command line(s) */
- #ifdef FEAT_WINDOWS
      int		w_status_height;    /* number of status lines (0 or 1) */
      int		w_wincol;	    /* Leftmost column of window in screen.
  				       use W_WINCOL() */
--- 2684,2692 ----
***************
*** 2709,2716 ****
  				       use W_WIDTH() */
      int		w_vsep_width;	    /* Number of separator columns (0 or 1).
  				       use W_VSEP_WIDTH() */
- #endif
- 
      /*
       * === start of cached values ====
       */
--- 2694,2699 ----
***************
*** 2792,2800 ****
  				       w_redr_type is REDRAW_TOP */
      linenr_T	w_redraw_top;	    /* when != 0: first line needing redraw */
      linenr_T	w_redraw_bot;	    /* when != 0: last line needing redraw */
- #ifdef FEAT_WINDOWS
      int		w_redr_status;	    /* if TRUE status line must be redrawn */
- #endif
  
  #ifdef FEAT_CMDL_INFO
      /* remember what is shown in the ruler for this window (if 'ruler' set) */
--- 2775,2781 ----
***************
*** 2810,2818 ****
  
      int		w_alt_fnum;	    /* alternate file (for # and CTRL-^) */
  
- #ifdef FEAT_WINDOWS
      alist_T	*w_alist;	    /* pointer to arglist for this window */
- #endif
      int		w_arg_idx;	    /* current index in argument list (can be
  				       out of range!) */
      int		w_arg_idx_invalid;  /* editing another file than w_arg_idx */
--- 2791,2797 ----
***************
*** 3346,3355 ****
  #ifdef FEAT_EVAL
      int		use_debug_break_level;
  #endif
- #ifdef FEAT_WINDOWS
      int		window_count;		/* number of windows to use */
      int		window_layout;		/* 0, WIN_HOR, WIN_VER or WIN_TABS */
- #endif
  
  #ifdef FEAT_CLIENTSERVER
      int		serverArg;		/* TRUE when argument for a server */
--- 3325,3332 ----
*** ../vim-8.0.1117/src/globals.h	2017-09-06 23:40:05.513366294 +0200
--- src/globals.h	2017-09-16 18:32:38.309500010 +0200
***************
*** 63,69 ****
  EXTERN schar_T	*ScreenLines2 INIT(= NULL);
  #endif
  
- #ifdef FEAT_WINDOWS
  /*
   * Indexes for tab page line:
   *	N > 0 for label of tab page N
--- 63,68 ----
***************
*** 72,78 ****
   *	N == -999 for closing current tab page
   */
  EXTERN short	*TabPageIdxs INIT(= NULL);
- #endif
  
  EXTERN int	screen_Rows INIT(= 0);	    /* actual size of ScreenLines[] */
  EXTERN int	screen_Columns INIT(= 0);   /* actual size of ScreenLines[] */
--- 71,76 ----
***************
*** 440,448 ****
  EXTERN int	drag_status_line INIT(= FALSE);	/* dragging the status line */
  EXTERN int	postponed_mouseshape INIT(= FALSE); /* postponed updating the
  						       mouse pointer shape */
- #  ifdef FEAT_WINDOWS
  EXTERN int	drag_sep_line INIT(= FALSE);	/* dragging vert separator */
- #  endif
  # endif
  
  #endif
--- 438,444 ----
***************
*** 550,558 ****
   * All windows are linked in a list. firstwin points to the first entry,
   * lastwin to the last entry (can be the same as firstwin) and curwin to the
   * currently active window.
-  * Without the FEAT_WINDOWS they are all equal.
   */
- #ifdef FEAT_WINDOWS
  EXTERN win_T	*firstwin;		/* first window */
  EXTERN win_T	*lastwin;		/* last window */
  EXTERN win_T	*prevwin INIT(= NULL);	/* previous window */
--- 546,552 ----
***************
*** 571,586 ****
      for ((tp) = first_tabpage; (tp) != NULL; (tp) = (tp)->tp_next) \
  	for ((wp) = ((tp) == curtab) \
  		? firstwin : (tp)->tp_firstwin; (wp); (wp) = (wp)->w_next)
- #else
- # define firstwin curwin
- # define lastwin curwin
- # define ONE_WINDOW 1
- # define W_NEXT(wp) NULL
- # define FOR_ALL_WINDOWS(wp) wp = curwin;
- # define FOR_ALL_TABPAGES(tp) for (;FALSE;)
- # define FOR_ALL_WINDOWS_IN_TAB(tp, wp) wp = curwin;
- # define FOR_ALL_TAB_WINDOWS(tp, wp) wp = curwin;
- #endif
  
  EXTERN win_T	*curwin;	/* currently active window */
  
--- 565,570 ----
***************
*** 595,601 ****
   */
  EXTERN frame_T	*topframe;	/* top of the window frame tree */
  
- #ifdef FEAT_WINDOWS
  /*
   * Tab pages are alternative topframes.  "first_tabpage" points to the first
   * one in the list, "curtab" is the current one.
--- 579,584 ----
***************
*** 603,609 ****
  EXTERN tabpage_T    *first_tabpage;
  EXTERN tabpage_T    *curtab;
  EXTERN int	    redraw_tabline INIT(= FALSE);  /* need to redraw tabline */
- #endif
  
  /*
   * All buffers are linked in a list. 'firstbuf' points to the first entry,
--- 586,591 ----
***************
*** 1101,1114 ****
  EXTERN buf_T	*last_changedtick_buf INIT(= NULL);
  #endif
  
- #ifdef FEAT_WINDOWS
  EXTERN int	postponed_split INIT(= 0);  /* for CTRL-W CTRL-] command */
  EXTERN int	postponed_split_flags INIT(= 0);  /* args for win_split() */
  EXTERN int	postponed_split_tab INIT(= 0);  /* cmdmod.tab */
! # ifdef FEAT_QUICKFIX
  EXTERN int	g_do_tagpreview INIT(= 0);  /* for tag preview commands:
  					       height of preview window */
- # endif
  #endif
  EXTERN int	replace_offset INIT(= 0);   /* offset for replace_push() */
  
--- 1083,1094 ----
  EXTERN buf_T	*last_changedtick_buf INIT(= NULL);
  #endif
  
  EXTERN int	postponed_split INIT(= 0);  /* for CTRL-W CTRL-] command */
  EXTERN int	postponed_split_flags INIT(= 0);  /* args for win_split() */
  EXTERN int	postponed_split_tab INIT(= 0);  /* cmdmod.tab */
! #ifdef FEAT_QUICKFIX
  EXTERN int	g_do_tagpreview INIT(= 0);  /* for tag preview commands:
  					       height of preview window */
  #endif
  EXTERN int	replace_offset INIT(= 0);   /* offset for replace_push() */
  
***************
*** 1196,1212 ****
  EXTERN int	lcs_conceal INIT(= ' ');
  #endif
  
- #if defined(FEAT_WINDOWS) || defined(FEAT_WILDMENU) || defined(FEAT_STL_OPT) \
- 	|| defined(FEAT_FOLDING)
  /* Characters from 'fillchars' option */
  EXTERN int	fill_stl INIT(= ' ');
  EXTERN int	fill_stlnc INIT(= ' ');
- #endif
- #if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
  EXTERN int	fill_vert INIT(= ' ');
  EXTERN int	fill_fold INIT(= '-');
  EXTERN int	fill_diff INIT(= '-');
- #endif
  
  #ifdef FEAT_FOLDING
  EXTERN int	disable_fold_update INIT(= 0);
--- 1176,1187 ----
***************
*** 1510,1518 ****
  EXTERN char_u e_noprev[]	INIT(= N_("E34: No previous command"));
  EXTERN char_u e_noprevre[]	INIT(= N_("E35: No previous regular expression"));
  EXTERN char_u e_norange[]	INIT(= N_("E481: No range allowed"));
- #ifdef FEAT_WINDOWS
  EXTERN char_u e_noroom[]	INIT(= N_("E36: Not enough room"));
- #endif
  #ifdef FEAT_CLIENTSERVER
  EXTERN char_u e_noserver[]	INIT(= N_("E247: no registered server named \"%s\""));
  #endif
--- 1485,1491 ----
***************
*** 1583,1592 ****
  EXTERN char_u e_trailing[]	INIT(= N_("E488: Trailing characters"));
  EXTERN char_u e_umark[]		INIT(= N_("E78: Unknown mark"));
  EXTERN char_u e_wildexpand[]	INIT(= N_("E79: Cannot expand wildcards"));
- #ifdef FEAT_WINDOWS
  EXTERN char_u e_winheight[]	INIT(= N_("E591: 'winheight' cannot be smaller than 'winminheight'"));
  EXTERN char_u e_winwidth[]	INIT(= N_("E592: 'winwidth' cannot be smaller than 'winminwidth'"));
- #endif
  EXTERN char_u e_write[]		INIT(= N_("E80: Error while writing"));
  EXTERN char_u e_zerocount[]	INIT(= N_("E939: Positive count required"));
  #ifdef FEAT_EVAL
--- 1556,1563 ----
*** ../vim-8.0.1117/src/gui.h	2017-09-02 18:33:52.445554521 +0200
--- src/gui.h	2017-09-16 18:32:51.873417741 +0200
***************
*** 180,188 ****
      /* Values measured in characters: */
      int		top;		/* Top of scroll bar (chars from row 0) */
      int		height;		/* Current height of scroll bar in rows */
- #ifdef FEAT_WINDOWS
      int		width;		/* Current width of scroll bar in cols */
- #endif
      int		status_height;	/* Height of status line */
  #ifdef FEAT_GUI_X11
      Widget	id;		/* Id of real scroll bar */
--- 180,186 ----
*** ../vim-8.0.1117/src/if_py_both.h	2017-08-04 21:37:48.736574947 +0200
--- src/if_py_both.h	2017-09-16 18:33:16.041271178 +0200
***************
*** 3872,3885 ****
      }
      else if (strcmp(name, "height") == 0)
  	return PyLong_FromLong((long)(self->win->w_height));
- #ifdef FEAT_WINDOWS
      else if (strcmp(name, "row") == 0)
  	return PyLong_FromLong((long)(self->win->w_winrow));
      else if (strcmp(name, "width") == 0)
  	return PyLong_FromLong((long)(W_WIDTH(self->win)));
      else if (strcmp(name, "col") == 0)
  	return PyLong_FromLong((long)(W_WINCOL(self->win)));
- #endif
      else if (strcmp(name, "vars") == 0)
  	return NEW_DICTIONARY(self->win->w_vars);
      else if (strcmp(name, "options") == 0)
--- 3872,3883 ----
***************
*** 3965,3971 ****
  
  	return 0;
      }
- #ifdef FEAT_WINDOWS
      else if (strcmp(name, "width") == 0)
      {
  	long	width;
--- 3963,3968 ----
***************
*** 3988,3994 ****
  
  	return 0;
      }
- #endif
      else
      {
  	PyErr_SetString(PyExc_AttributeError, name);
--- 3985,3990 ----
*** ../vim-8.0.1117/src/option.h	2017-08-30 22:00:16.374112596 +0200
--- src/option.h	2017-09-16 18:34:13.156924917 +0200
***************
*** 460,468 ****
  #define DY_TRUNCATE		0x002
  #define DY_UHEX			0x004
  EXTERN int	p_ed;		/* 'edcompatible' */
- #ifdef FEAT_WINDOWS
  EXTERN char_u	*p_ead;		/* 'eadirection' */
- #endif
  EXTERN int	p_ea;		/* 'equalalways' */
  EXTERN char_u	*p_ep;		/* 'equalprg' */
  EXTERN int	p_eb;		/* 'errorbells' */
--- 460,466 ----
***************
*** 551,559 ****
  EXTERN char_u	*p_gtt;		/* 'guitabtooltip' */
  #endif
  EXTERN char_u	*p_hf;		/* 'helpfile' */
- #ifdef FEAT_WINDOWS
  EXTERN long	p_hh;		/* 'helpheight' */
- #endif
  #ifdef FEAT_MULTI_LANG
  EXTERN char_u	*p_hlg;		/* 'helplang' */
  #endif
--- 549,555 ----
***************
*** 611,620 ****
  #ifdef FEAT_LISP
  EXTERN char_u	*p_lispwords;	/* 'lispwords' */
  #endif
- #ifdef FEAT_WINDOWS
  EXTERN long	p_ls;		/* 'laststatus' */
  EXTERN long	p_stal;		/* 'showtabline' */
- #endif
  EXTERN char_u	*p_lcs;		/* 'listchars' */
  
  EXTERN int	p_lz;		/* 'lazyredraw' */
--- 607,614 ----
***************
*** 705,711 ****
  EXTERN char_u	*p_rop;		/* 'renderoptions' */
  #endif
  EXTERN long	p_report;	/* 'report' */
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  EXTERN long	p_pvh;		/* 'previewheight' */
  #endif
  #ifdef WIN3264
--- 699,705 ----
  EXTERN char_u	*p_rop;		/* 'renderoptions' */
  #endif
  EXTERN long	p_report;	/* 'report' */
! #if defined(FEAT_QUICKFIX)
  EXTERN long	p_pvh;		/* 'previewheight' */
  #endif
  #ifdef WIN3264
***************
*** 795,813 ****
  EXTERN long	p_siso;		/* 'sidescrolloff' */
  EXTERN int	p_scs;		/* 'smartcase' */
  EXTERN int	p_sta;		/* 'smarttab' */
- #ifdef FEAT_WINDOWS
  EXTERN int	p_sb;		/* 'splitbelow' */
  EXTERN long	p_tpm;		/* 'tabpagemax' */
  # if defined(FEAT_STL_OPT)
  EXTERN char_u	*p_tal;		/* 'tabline' */
  # endif
- #endif
  #ifdef FEAT_SPELL
  EXTERN char_u	*p_sps;		/* 'spellsuggest' */
  #endif
- #ifdef FEAT_WINDOWS
  EXTERN int	p_spr;		/* 'splitright' */
- #endif
  EXTERN int	p_sol;		/* 'startofline' */
  EXTERN char_u	*p_su;		/* 'suffixes' */
  EXTERN char_u	*p_sws;		/* 'swapsync' */
--- 789,803 ----
***************
*** 911,919 ****
  EXTERN long	p_ur;		/* 'undoreload' */
  EXTERN long	p_uc;		/* 'updatecount' */
  EXTERN long	p_ut;		/* 'updatetime' */
- #if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
  EXTERN char_u	*p_fcs;		/* 'fillchar' */
- #endif
  #ifdef FEAT_VIMINFO
  EXTERN char_u	*p_viminfo;	/* 'viminfo' */
  EXTERN char_u	*p_viminfofile;	/* 'viminfofile' */
--- 901,907 ----
***************
*** 963,974 ****
  #ifdef FEAT_WILDMENU
  EXTERN int	p_wmnu;		/* 'wildmenu' */
  #endif
- #ifdef FEAT_WINDOWS
  EXTERN long	p_wh;		/* 'winheight' */
  EXTERN long	p_wmh;		/* 'winminheight' */
  EXTERN long	p_wmw;		/* 'winminwidth' */
  EXTERN long	p_wiw;		/* 'winwidth' */
- #endif
  #if defined(WIN3264) && defined(FEAT_TERMINAL)
  EXTERN char_u	*p_winptydll;	/* 'winptydll' */
  #endif
--- 951,960 ----
***************
*** 1164,1170 ****
  #ifdef FEAT_LINEBREAK
      , WV_NUW
  #endif
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      , WV_PVW
  #endif
  #ifdef FEAT_RIGHTLEFT
--- 1150,1156 ----
  #ifdef FEAT_LINEBREAK
      , WV_NUW
  #endif
! #if defined(FEAT_QUICKFIX)
      , WV_PVW
  #endif
  #ifdef FEAT_RIGHTLEFT
***************
*** 1186,1195 ****
  #ifdef FEAT_STL_OPT
      , WV_STL
  #endif
- #ifdef FEAT_WINDOWS
      , WV_WFH
      , WV_WFW
- #endif
      , WV_WRAP
  #ifdef FEAT_SIGNS
      , WV_SCL
--- 1172,1179 ----
*** ../vim-8.0.1117/src/term.h	2017-09-02 18:33:52.457554443 +0200
--- src/term.h	2017-09-16 18:34:27.204839777 +0200
***************
*** 92,100 ****
      KS_CSI,	/* start insert mode (bar cursor) */
      KS_CEI,	/* end insert mode (block cursor) */
      KS_CSR,	/* start replace mode (underline cursor) */
- #ifdef FEAT_WINDOWS
      KS_CSV,	/* scroll region vertical */
- #endif
      KS_OP,	/* original color pair */
      KS_U7,	/* request cursor position */
      KS_8F,	/* set foreground color (RGB) */
--- 92,98 ----
*** ../vim-8.0.1117/src/buffer.c	2017-09-08 13:59:16.761754116 +0200
--- src/buffer.c	2017-09-16 19:06:58.877105876 +0200
***************
*** 59,65 ****
  static void insert_sign(buf_T *buf, signlist_T *prev, signlist_T *next, int id, linenr_T lnum, int typenr);
  #endif
  
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  static char *msg_loclist = N_("[Location List]");
  static char *msg_qflist = N_("[Quickfix List]");
  #endif
--- 59,65 ----
  static void insert_sign(buf_T *buf, signlist_T *prev, signlist_T *next, int id, linenr_T lnum, int typenr);
  #endif
  
! #if defined(FEAT_QUICKFIX)
  static char *msg_loclist = N_("[Location List]");
  static char *msg_qflist = N_("[Quickfix List]");
  #endif
***************
*** 458,468 ****
      int		is_curbuf;
      int		nwindows;
      bufref_T	bufref;
- # ifdef FEAT_WINDOWS
      int		is_curwin = (curwin != NULL && curwin->w_buffer == buf);
      win_T	*the_curwin = curwin;
      tabpage_T	*the_curtab = curtab;
- # endif
  #endif
      int		unload_buf = (action != 0);
      int		del_buf = (action == DOBUF_DEL || action == DOBUF_WIPE);
--- 458,466 ----
***************
*** 522,532 ****
      }
  #endif
  
!     if (win != NULL
! #ifdef FEAT_WINDOWS
! 	&& win_valid_any_tab(win) /* in case autocommands closed the window */
! #endif
! 	    )
      {
  	/* Set b_last_cursor when closing the last window for the buffer.
  	 * Remember the last cursor position and window options of the buffer.
--- 520,527 ----
      }
  #endif
  
!     /* check no autocommands closed the window */
!     if (win != NULL && win_valid_any_tab(win))
      {
  	/* Set b_last_cursor when closing the last window for the buffer.
  	 * Remember the last cursor position and window options of the buffer.
***************
*** 581,587 ****
  # endif
      }
  
- # ifdef FEAT_WINDOWS
      /* If the buffer was in curwin and the window has changed, go back to that
       * window, if it still exists.  This avoids that ":edit x" triggering a
       * "tabnext" BufUnload autocmd leaves a window behind without a buffer. */
--- 576,581 ----
***************
*** 591,597 ****
  	goto_tabpage_win(the_curtab, the_curwin);
  	unblock_autocmds();
      }
- # endif
  
      nwindows = buf->b_nwindows;
  #endif
--- 585,590 ----
***************
*** 650,662 ****
      if (buf == curbuf && !is_curbuf)
  	return;
  
!     if (
! #ifdef FEAT_WINDOWS
! 	win_valid_any_tab(win) &&
! #else
! 	win != NULL &&
! #endif
! 			  win->w_buffer == buf)
  	win->w_buffer = NULL;  /* make sure we don't use the buffer now */
  
      /* Autocommands may have opened or closed windows for this buffer.
--- 643,649 ----
      if (buf == curbuf && !is_curbuf)
  	return;
  
!     if (win_valid_any_tab(win) && win->w_buffer == buf)
  	win->w_buffer = NULL;  /* make sure we don't use the buffer now */
  
      /* Autocommands may have opened or closed windows for this buffer.
***************
*** 746,756 ****
  #ifdef FEAT_AUTOCMD
      int		is_curbuf = (buf == curbuf);
      bufref_T	bufref;
- # ifdef FEAT_WINDOWS
      int		is_curwin = (curwin != NULL && curwin->w_buffer == buf);
      win_T	*the_curwin = curwin;
      tabpage_T	*the_curtab = curtab;
- # endif
  
      /* Make sure the buffer isn't closed by autocommands. */
      ++buf->b_locked;
--- 733,741 ----
***************
*** 781,787 ****
      }
      --buf->b_locked;
  
- # ifdef FEAT_WINDOWS
      /* If the buffer was in curwin and the window has changed, go back to that
       * window, if it still exists.  This avoids that ":edit x" triggering a
       * "tabnext" BufUnload autocmd leaves a window behind without a buffer. */
--- 766,771 ----
***************
*** 791,797 ****
  	goto_tabpage_win(the_curtab, the_curwin);
  	unblock_autocmds();
      }
- # endif
  
  # ifdef FEAT_EVAL
      if (aborting())	    /* autocmds may abort script processing */
--- 775,780 ----
***************
*** 818,824 ****
  
  #ifdef FEAT_FOLDING
      /* No folds in an empty buffer. */
- # ifdef FEAT_WINDOWS
      {
  	win_T		*win;
  	tabpage_T	*tp;
--- 801,806 ----
***************
*** 827,836 ****
  	    if (win->w_buffer == buf)
  		clearFolding(win);
      }
- # else
-     if (curwin != NULL && curwin->w_buffer == buf)
- 	clearFolding(curwin);
- # endif
  #endif
  
  #ifdef FEAT_TCL
--- 809,814 ----
***************
*** 1001,1007 ****
      int		dir,
      int		count)
  {
! # if defined(FEAT_WINDOWS) && defined(HAS_SWAP_EXISTS_ACTION)
      bufref_T	old_curbuf;
  
      set_bufref(&old_curbuf, curbuf);
--- 979,985 ----
      int		dir,
      int		count)
  {
! # if defined(HAS_SWAP_EXISTS_ACTION)
      bufref_T	old_curbuf;
  
      set_bufref(&old_curbuf, curbuf);
***************
*** 1010,1016 ****
  # endif
      (void)do_buffer(*eap->cmd == 's' ? DOBUF_SPLIT : DOBUF_GOTO,
  					     start, dir, count, eap->forceit);
! # if defined(FEAT_WINDOWS) && defined(HAS_SWAP_EXISTS_ACTION)
      if (swap_exists_action == SEA_QUIT && *eap->cmd == 's')
      {
  #  if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
--- 988,994 ----
  # endif
      (void)do_buffer(*eap->cmd == 's' ? DOBUF_SPLIT : DOBUF_GOTO,
  					     start, dir, count, eap->forceit);
! # if defined(HAS_SWAP_EXISTS_ACTION)
      if (swap_exists_action == SEA_QUIT && *eap->cmd == 's')
      {
  #  if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
***************
*** 1269,1279 ****
      }
  
      set_bufref(&bufref, buf);
- #ifdef FEAT_WINDOWS
      if (close_others)
  	/* Close any other windows on this buffer, then make it empty. */
  	close_windows(buf, TRUE);
- #endif
  
      setpcmark();
      retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,
--- 1247,1255 ----
***************
*** 1410,1420 ****
      if (unload)
      {
  	int	forward;
- # if defined(FEAT_AUTOCMD) || defined(FEAT_WINDOWS)
  	bufref_T bufref;
  
  	set_bufref(&bufref, buf);
- # endif
  
  	/* When unloading or deleting a buffer that's already unloaded and
  	 * unlisted: fail silently. */
--- 1386,1394 ----
***************
*** 1461,1493 ****
  	if (bp == NULL && buf == curbuf)
  	    return empty_curbuf(TRUE, forceit, action);
  
- #ifdef FEAT_WINDOWS
  	/*
  	 * If the deleted buffer is the current one, close the current window
  	 * (unless it's the only window).  Repeat this so long as we end up in
  	 * a window with this buffer.
  	 */
  	while (buf == curbuf
! # ifdef FEAT_AUTOCMD
  		   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)
! # endif
  		   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))
  	{
  	    if (win_close(curwin, FALSE) == FAIL)
  		break;
  	}
- #endif
  
  	/*
  	 * If the buffer to be deleted is not the current one, delete it here.
  	 */
  	if (buf != curbuf)
  	{
- #ifdef FEAT_WINDOWS
  	    close_windows(buf, FALSE);
! 	    if (buf != curbuf && bufref_valid(&bufref))
! #endif
! 		if (buf->b_nwindows <= 0)
  		    close_buffer(NULL, buf, action, FALSE);
  	    return OK;
  	}
--- 1435,1462 ----
  	if (bp == NULL && buf == curbuf)
  	    return empty_curbuf(TRUE, forceit, action);
  
  	/*
  	 * If the deleted buffer is the current one, close the current window
  	 * (unless it's the only window).  Repeat this so long as we end up in
  	 * a window with this buffer.
  	 */
  	while (buf == curbuf
! #ifdef FEAT_AUTOCMD
  		   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)
! #endif
  		   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))
  	{
  	    if (win_close(curwin, FALSE) == FAIL)
  		break;
  	}
  
  	/*
  	 * If the buffer to be deleted is not the current one, delete it here.
  	 */
  	if (buf != curbuf)
  	{
  	    close_windows(buf, FALSE);
! 	    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0)
  		    close_buffer(NULL, buf, action, FALSE);
  	    return OK;
  	}
***************
*** 1606,1612 ****
       */
      if (action == DOBUF_SPLIT)	    /* split window first */
      {
- # ifdef FEAT_WINDOWS
  	/* If 'switchbuf' contains "useopen": jump to first window containing
  	 * "buf" if one exists */
  	if ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))
--- 1575,1580 ----
***************
*** 1616,1622 ****
  	if ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))
  	    return OK;
  	if (win_split(0, 0) == FAIL)
- # endif
  	    return FAIL;
      }
  #endif
--- 1584,1589 ----
***************
*** 1719,1748 ****
  	if (prevbuf == curwin->w_buffer)
  	    reset_synblock(curwin);
  #endif
- #ifdef FEAT_WINDOWS
  	if (unload)
  	    close_windows(prevbuf, FALSE);
- #endif
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  	if (bufref_valid(&bufref) && !aborting())
  #else
  	if (bufref_valid(&bufref))
  #endif
  	{
- #ifdef FEAT_WINDOWS
  	    win_T  *previouswin = curwin;
- #endif
  	    if (prevbuf == curbuf)
  		u_sync(FALSE);
  	    close_buffer(prevbuf == curwin->w_buffer ? curwin : NULL, prevbuf,
  		    unload ? action : (action == DOBUF_GOTO
  			&& !buf_hide(prevbuf)
  			&& !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0, FALSE);
- #ifdef FEAT_WINDOWS
  	    if (curwin != previouswin && win_valid(previouswin))
  	      /* autocommands changed curwin, Grr! */
  	      curwin = previouswin;
- #endif
  	}
      }
  #ifdef FEAT_AUTOCMD
--- 1686,1709 ----
***************
*** 1751,1762 ****
       * If curwin->w_buffer is null, enter_buffer() will make it valid again */
      if ((buf_valid(buf) && buf != curbuf
  # ifdef FEAT_EVAL
! 	    && !aborting()
! # endif
! # ifdef FEAT_WINDOWS
! 	 ) || curwin->w_buffer == NULL
  # endif
!        )
  #endif
      {
  	enter_buffer(buf);
--- 1712,1720 ----
       * If curwin->w_buffer is null, enter_buffer() will make it valid again */
      if ((buf_valid(buf) && buf != curbuf
  # ifdef FEAT_EVAL
! 		&& !aborting()
  # endif
! 	) || curwin->w_buffer == NULL)
  #endif
      {
  	enter_buffer(buf);
***************
*** 2327,2335 ****
      int		forceit)
  {
      buf_T	*buf;
- #ifdef FEAT_WINDOWS
      win_T	*wp = NULL;
- #endif
      pos_T	*fpos;
      colnr_T	col;
  
--- 2285,2291 ----
***************
*** 2367,2373 ****
      else
  	col = 0;
  
- #ifdef FEAT_WINDOWS
      if (options & GETF_SWITCH)
      {
  	/* If 'switchbuf' contains "useopen": jump to first window containing
--- 2323,2328 ----
***************
*** 2393,2399 ****
  	    RESET_BINDING(curwin);
  	}
      }
- #endif
  
      ++RedrawingDisabled;
      if (GETFILE_SUCCESS(getfile(buf->b_fnum, NULL, NULL,
--- 2348,2353 ----
***************
*** 2598,2604 ****
  			{
  			    /* Ignore the match if the buffer is not open in
  			     * the current tab. */
- #ifdef FEAT_WINDOWS
  			    win_T	*wp;
  
  			    FOR_ALL_WINDOWS(wp)
--- 2552,2557 ----
***************
*** 2606,2615 ****
  				    break;
  			    if (wp == NULL)
  				continue;
- #else
- 			    if (curwin->w_buffer != buf)
- 				continue;
- #endif
  			}
  			if (match >= 0)		/* already found a match */
  			{
--- 2559,2564 ----
***************
*** 3089,3095 ****
  #ifdef FEAT_TERMINAL
  	if (term_job_running(buf->b_term))
  	{
! 	    ro_char = 'R';
  	    changed_char = ' ';  /* bufIsChanged() returns TRUE to avoid
  				  * closing, but it's not actually changed. */
  	}
--- 3038,3047 ----
  #ifdef FEAT_TERMINAL
  	if (term_job_running(buf->b_term))
  	{
! 	    if (term_none_open(buf->b_term))
! 		ro_char = '?';
! 	    else
! 		ro_char = 'R';
  	    changed_char = ' ';  /* bufIsChanged() returns TRUE to avoid
  				  * closing, but it's not actually changed. */
  	}
***************
*** 3292,3300 ****
  #ifdef FEAT_TITLE
      maketitle();		/* set window title */
  #endif
- #ifdef FEAT_WINDOWS
      status_redraw_all();	/* status lines need to be redrawn */
- #endif
      fmarks_check_names(buf);	/* check named file marks */
      ml_timestamp(buf);		/* reset timestamp */
  }
--- 3244,3250 ----
***************
*** 4422,4428 ****
  	    break;
  #endif
  
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  	case STL_PREVIEWFLAG:
  	case STL_PREVIEWFLAG_ALT:
  	    itemisflag = TRUE;
--- 4372,4378 ----
  	    break;
  #endif
  
! #if defined(FEAT_QUICKFIX)
  	case STL_PREVIEWFLAG:
  	case STL_PREVIEWFLAG_ALT:
  	    itemisflag = TRUE;
***************
*** 4908,4914 ****
      return bp->b_fname;
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * do_arg_all(): Open up to 'count' windows, one for each argument.
   */
--- 4858,4863 ----
***************
*** 5057,5079 ****
  			}
  #endif
  		    }
- #ifdef FEAT_WINDOWS
  		    /* don't close last window */
  		    if (ONE_WINDOW
  			    && (first_tabpage->tp_next == NULL || !had_tab))
- #endif
  			use_firstwin = TRUE;
- #ifdef FEAT_WINDOWS
  		    else
  		    {
  			win_close(wp, !buf_hide(buf) && !bufIsChanged(buf));
! # ifdef FEAT_AUTOCMD
  			/* check if autocommands removed the next window */
  			if (!win_valid(wpnext))
  			    wpnext = firstwin;	/* start all over... */
- # endif
- 		    }
  #endif
  		}
  	    }
  	}
--- 5006,5024 ----
  			}
  #endif
  		    }
  		    /* don't close last window */
  		    if (ONE_WINDOW
  			    && (first_tabpage->tp_next == NULL || !had_tab))
  			use_firstwin = TRUE;
  		    else
  		    {
  			win_close(wp, !buf_hide(buf) && !bufIsChanged(buf));
! #ifdef FEAT_AUTOCMD
  			/* check if autocommands removed the next window */
  			if (!win_valid(wpnext))
  			    wpnext = firstwin;	/* start all over... */
  #endif
+ 		    }
  		}
  	    }
  	}
***************
*** 5105,5117 ****
      last_curwin = curwin;
      last_curtab = curtab;
      win_enter(lastwin, FALSE);
- #ifdef FEAT_WINDOWS
      /* ":drop all" should re-use an empty window to avoid "--remote-tab"
       * leaving an empty tab page when executed locally. */
      if (keep_tabs && BUFEMPTY() && curbuf->b_nwindows == 1
  			    && curbuf->b_ffname == NULL && !curbuf->b_changed)
  	use_firstwin = TRUE;
- #endif
  
      for (i = 0; i < count && i < opened_len && !got_int; ++i)
      {
--- 5050,5060 ----
***************
*** 5222,5231 ****
      int		r;
      int		count;		/* Maximum number of windows to open. */
      int		all;		/* When TRUE also load inactive buffers. */
- #ifdef FEAT_WINDOWS
      int		had_tab = cmdmod.tab;
      tabpage_T	*tpnext;
- #endif
  
      if (eap->addr_count == 0)	/* make as many windows as possible */
  	count = 9999;
--- 5165,5172 ----
***************
*** 5246,5270 ****
       * Close superfluous windows (two windows for the same buffer).
       * Also close windows that are not full-width.
       */
- #ifdef FEAT_WINDOWS
      if (had_tab > 0)
  	goto_tabpage_tp(first_tabpage, TRUE, TRUE);
      for (;;)
      {
- #endif
  	tpnext = curtab->tp_next;
  	for (wp = firstwin; wp != NULL; wp = wpnext)
  	{
  	    wpnext = wp->w_next;
  	    if ((wp->w_buffer->b_nwindows > 1
- #ifdef FEAT_WINDOWS
  		    || ((cmdmod.split & WSP_VERT)
  			? wp->w_height + wp->w_status_height < Rows - p_ch
  							    - tabline_height()
  			: wp->w_width != Columns)
! 		    || (had_tab > 0 && wp != firstwin)
! #endif
! 		    ) && !ONE_WINDOW
  #ifdef FEAT_AUTOCMD
  		    && !(wp->w_closing || wp->w_buffer->b_locked > 0)
  #endif
--- 5187,5206 ----
       * Close superfluous windows (two windows for the same buffer).
       * Also close windows that are not full-width.
       */
      if (had_tab > 0)
  	goto_tabpage_tp(first_tabpage, TRUE, TRUE);
      for (;;)
      {
  	tpnext = curtab->tp_next;
  	for (wp = firstwin; wp != NULL; wp = wpnext)
  	{
  	    wpnext = wp->w_next;
  	    if ((wp->w_buffer->b_nwindows > 1
  		    || ((cmdmod.split & WSP_VERT)
  			? wp->w_height + wp->w_status_height < Rows - p_ch
  							    - tabline_height()
  			: wp->w_width != Columns)
! 		    || (had_tab > 0 && wp != firstwin)) && !ONE_WINDOW
  #ifdef FEAT_AUTOCMD
  		    && !(wp->w_closing || wp->w_buffer->b_locked > 0)
  #endif
***************
*** 5282,5294 ****
  		++open_wins;
  	}
  
- #ifdef FEAT_WINDOWS
  	/* Without the ":tab" modifier only do the current tab page. */
  	if (had_tab == 0 || tpnext == NULL)
  	    break;
  	goto_tabpage_tp(tpnext, TRUE, TRUE);
      }
- #endif
  
      /*
       * Go through the buffer list.  When a buffer doesn't have a window yet,
--- 5218,5228 ----
***************
*** 5309,5315 ****
  	if ((!all && buf->b_ml.ml_mfp == NULL) || !buf->b_p_bl)
  	    continue;
  
- #ifdef FEAT_WINDOWS
  	if (had_tab != 0)
  	{
  	    /* With the ":tab" modifier don't move the window. */
--- 5243,5248 ----
***************
*** 5319,5325 ****
  		wp = NULL;
  	}
  	else
- #endif
  	{
  	    /* Check if this buffer already has a window */
  	    FOR_ALL_WINDOWS(wp)
--- 5252,5257 ----
***************
*** 5401,5411 ****
  	if (aborting())
  	    break;
  #endif
- #ifdef FEAT_WINDOWS
  	/* When ":tab" was used open a new tab for a new window repeatedly. */
  	if (had_tab > 0 && tabpage_index(NULL) <= p_tpm)
  	    cmdmod.tab = 9999;
- #endif
      }
  #ifdef FEAT_AUTOCMD
      --autocmd_no_enter;
--- 5333,5341 ----
***************
*** 5446,5452 ****
  }
  # endif /* FEAT_LISTCMDS */
  
- #endif /* FEAT_WINDOWS */
  
  static int  chk_modeline(linenr_T, int);
  
--- 5376,5381 ----
***************
*** 5673,5682 ****
  write_viminfo_bufferlist(FILE *fp)
  {
      buf_T	*buf;
- #ifdef FEAT_WINDOWS
      win_T	*win;
      tabpage_T	*tp;
- #endif
      char_u	*line;
      int		max_buffers;
  
--- 5602,5609 ----
***************
*** 5692,5703 ****
      if (line == NULL)
  	return;
  
- #ifdef FEAT_WINDOWS
      FOR_ALL_TAB_WINDOWS(tp, win)
  	set_last_cursor(win);
- #else
-     set_last_cursor(curwin);
- #endif
  
      fputs(_("\n# Buffer list:\n"), fp);
      FOR_ALL_BUFFERS(buf)
--- 5619,5626 ----
***************
*** 5810,5816 ****
      char_u *
  buf_spname(buf_T *buf)
  {
! #if defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)
      if (bt_quickfix(buf))
      {
  	win_T	    *win;
--- 5733,5739 ----
      char_u *
  buf_spname(buf_T *buf)
  {
! #if defined(FEAT_QUICKFIX)
      if (bt_quickfix(buf))
      {
  	win_T	    *win;
***************
*** 5888,5896 ****
  }
  #endif
  
! #if (defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)) \
! 	|| defined(SWITCH_TO_WIN) \
! 	|| defined(PROTO)
  /*
   * Find a window for buffer "buf".
   * If found OK is returned and "wp" and "tp" are set to the window and tabpage.
--- 5811,5817 ----
  }
  #endif
  
! #if defined(FEAT_QUICKFIX) || defined(SWITCH_TO_WIN) || defined(PROTO)
  /*
   * Find a window for buffer "buf".
   * If found OK is returned and "wp" and "tp" are set to the window and tabpage.
*** ../vim-8.0.1117/src/charset.c	2017-09-02 20:30:31.159315070 +0200
--- src/charset.c	2017-09-16 19:09:19.864257734 +0200
***************
*** 1092,1101 ****
  	    && VIM_ISBREAK(c)
  	    && !VIM_ISBREAK((int)s[1])
  	    && wp->w_p_wrap
! # ifdef FEAT_WINDOWS
! 	    && wp->w_width != 0
! # endif
!        )
      {
  	/*
  	 * Count all characters from first non-blank after a blank up to next
--- 1092,1098 ----
  	    && VIM_ISBREAK(c)
  	    && !VIM_ISBREAK((int)s[1])
  	    && wp->w_p_wrap
! 	    && wp->w_width != 0)
      {
  	/*
  	 * Count all characters from first non-blank after a blank up to next
***************
*** 1249,1258 ****
      int		width1;		/* width of first line (after line number) */
      int		width2;		/* width of further lines */
  
- # ifdef FEAT_WINDOWS
      if (wp->w_width == 0)	/* there is no border */
  	return FALSE;
- # endif
      width1 = W_WIDTH(wp) - win_col_off(wp);
      if ((int)vcol < width1 - 1)
  	return FALSE;
--- 1246,1253 ----
***************
*** 2029,2036 ****
      return c - '0';
  }
  
! #if defined(FEAT_TERMRESPONSE) \
! 	|| (defined(FEAT_GUI_GTK) && defined(FEAT_WINDOWS)) || defined(PROTO)
  /*
   * Convert two hex characters to a byte.
   * Return -1 if one of the characters is not hex.
--- 2024,2030 ----
      return c - '0';
  }
  
! #if defined(FEAT_TERMRESPONSE) || defined(FEAT_GUI_GTK) || defined(PROTO)
  /*
   * Convert two hex characters to a byte.
   * Return -1 if one of the characters is not hex.
*** ../vim-8.0.1117/src/digraph.c	2017-07-22 20:41:59.573529015 +0200
--- src/digraph.c	2017-09-16 19:09:33.348176656 +0200
***************
*** 2426,2434 ****
      p_cpo = save_cpo;
  
      curbuf->b_kmap_state |= KEYMAP_LOADED;
- #ifdef FEAT_WINDOWS
      status_redraw_curbuf();
- #endif
  }
  
  /*
--- 2426,2432 ----
***************
*** 2462,2470 ****
  
      ga_clear(&curbuf->b_kmap_ga);
      curbuf->b_kmap_state &= ~KEYMAP_LOADED;
- #ifdef FEAT_WINDOWS
      status_redraw_curbuf();
- #endif
  }
  
  #endif /* FEAT_KEYMAP */
--- 2460,2466 ----
*** ../vim-8.0.1117/src/edit.c	2017-09-02 20:30:31.163315043 +0200
--- src/edit.c	2017-09-16 19:10:44.363749751 +0200
***************
*** 1360,1366 ****
  	    /* FALLTHROUGH */
  	case CAR:
  	case NL:
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  	    /* In a quickfix window a <CR> jumps to the error under the
  	     * cursor. */
  	    if (bt_quickfix(curbuf) && c == CAR)
--- 1360,1366 ----
  	    /* FALLTHROUGH */
  	case CAR:
  	case NL:
! #if defined(FEAT_QUICKFIX)
  	    /* In a quickfix window a <CR> jumps to the error under the
  	     * cursor. */
  	    if (bt_quickfix(curbuf) && c == CAR)
***************
*** 4045,4066 ****
      static buf_T *
  ins_compl_next_buf(buf_T *buf, int flag)
  {
- #ifdef FEAT_WINDOWS
      static win_T *wp;
- #endif
  
      if (flag == 'w')		/* just windows */
      {
- #ifdef FEAT_WINDOWS
  	if (buf == curbuf)	/* first call for this flag/expansion */
  	    wp = curwin;
  	while ((wp = (wp->w_next != NULL ? wp->w_next : firstwin)) != curwin
  		&& wp->w_buffer->b_scanned)
  	    ;
  	buf = wp->w_buffer;
- #else
- 	buf = curbuf;
- #endif
      }
      else
  	/* 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'
--- 4045,4060 ----
***************
*** 8540,8546 ****
      if (gui.in_use)
  	gui_update_cursor(TRUE, FALSE);
  #endif
! #if defined(FEAT_WINDOWS) && defined(FEAT_KEYMAP)
      /* Show/unshow value of 'keymap' in status lines. */
      status_redraw_curbuf();
  #endif
--- 8534,8540 ----
      if (gui.in_use)
  	gui_update_cursor(TRUE, FALSE);
  #endif
! #if defined(FEAT_KEYMAP)
      /* Show/unshow value of 'keymap' in status lines. */
      status_redraw_curbuf();
  #endif
***************
*** 9382,9388 ****
      tpos = curwin->w_cursor;
      if (do_mouse(NULL, c, BACKWARD, 1L, 0))
      {
- #ifdef FEAT_WINDOWS
  	win_T	*new_curwin = curwin;
  
  	if (curwin != old_curwin && win_valid(old_curwin))
--- 9376,9381 ----
***************
*** 9392,9431 ****
  	    curwin = old_curwin;
  	    curbuf = curwin->w_buffer;
  	}
- #endif
  	start_arrow(curwin == old_curwin ? &tpos : NULL);
- #ifdef FEAT_WINDOWS
  	if (curwin != new_curwin && win_valid(new_curwin))
  	{
  	    curwin = new_curwin;
  	    curbuf = curwin->w_buffer;
  	}
- #endif
  # ifdef FEAT_CINDENT
  	can_cindent = TRUE;
  # endif
      }
  
- #ifdef FEAT_WINDOWS
      /* redraw status lines (in case another window became active) */
      redraw_statuslines();
- #endif
  }
  
      static void
  ins_mousescroll(int dir)
  {
      pos_T	tpos;
- # if defined(FEAT_WINDOWS)
      win_T	*old_curwin = curwin, *wp;
- # endif
  # ifdef FEAT_INS_EXPAND
      int		did_scroll = FALSE;
  # endif
  
      tpos = curwin->w_cursor;
  
- # ifdef FEAT_WINDOWS
      if (mouse_row >= 0 && mouse_col >= 0)
      {
  	int row, col;
--- 9385,9416 ----
***************
*** 9441,9456 ****
  	curbuf = curwin->w_buffer;
      }
      if (curwin == old_curwin)
- # endif
  	undisplay_dollar();
  
  # ifdef FEAT_INS_EXPAND
      /* Don't scroll the window in which completion is being done. */
!     if (!pum_visible()
! #  if defined(FEAT_WINDOWS)
! 	    || curwin != old_curwin
! #  endif
! 	    )
  # endif
      {
  	if (dir == MSCR_DOWN || dir == MSCR_UP)
--- 9426,9436 ----
  	curbuf = curwin->w_buffer;
      }
      if (curwin == old_curwin)
  	undisplay_dollar();
  
  # ifdef FEAT_INS_EXPAND
      /* Don't scroll the window in which completion is being done. */
!     if (!pum_visible() || curwin != old_curwin)
  # endif
      {
  	if (dir == MSCR_DOWN || dir == MSCR_UP)
***************
*** 9479,9490 ****
  # endif
      }
  
- # ifdef FEAT_WINDOWS
      curwin->w_redr_status = TRUE;
  
      curwin = old_curwin;
      curbuf = curwin->w_buffer;
- # endif
  
  # ifdef FEAT_INS_EXPAND
      /* The popup menu may overlay the window, need to redraw it.
--- 9459,9468 ----
***************
*** 9883,9889 ****
  
      undisplay_dollar();
  
- #ifdef FEAT_WINDOWS
      if (mod_mask & MOD_MASK_CTRL)
      {
  	/* <C-PageUp>: tab page back */
--- 9861,9866 ----
***************
*** 9894,9900 ****
  	}
  	return;
      }
- #endif
  
      tpos = curwin->w_cursor;
      if (onepage(BACKWARD, 1L) == OK)
--- 9871,9876 ----
***************
*** 9946,9952 ****
  
      undisplay_dollar();
  
- #ifdef FEAT_WINDOWS
      if (mod_mask & MOD_MASK_CTRL)
      {
  	/* <C-PageDown>: tab page forward */
--- 9922,9927 ----
***************
*** 9957,9963 ****
  	}
  	return;
      }
- #endif
  
      tpos = curwin->w_cursor;
      if (onepage(FORWARD, 1L) == OK)
--- 9932,9937 ----
*** ../vim-8.0.1117/src/eval.c	2017-08-30 14:53:02.807426564 +0200
--- src/eval.c	2017-09-16 19:37:45.674087472 +0200
***************
*** 211,219 ****
  static void list_glob_vars(int *first);
  static void list_buf_vars(int *first);
  static void list_win_vars(int *first);
- #ifdef FEAT_WINDOWS
  static void list_tab_vars(int *first);
- #endif
  static void list_vim_vars(int *first);
  static void list_script_vars(int *first);
  static char_u *list_arg_vars(exarg_T *eap, char_u *arg, int *first);
--- 211,217 ----
***************
*** 1205,1213 ****
  	    list_glob_vars(&first);
  	    list_buf_vars(&first);
  	    list_win_vars(&first);
- #ifdef FEAT_WINDOWS
  	    list_tab_vars(&first);
- #endif
  	    list_script_vars(&first);
  	    list_func_vars(&first);
  	    list_vim_vars(&first);
--- 1203,1209 ----
***************
*** 1469,1475 ****
  						 (char_u *)"w:", TRUE, first);
  }
  
- #ifdef FEAT_WINDOWS
  /*
   * List tab page variables.
   */
--- 1465,1470 ----
***************
*** 1479,1485 ****
      list_hashtable_vars(&curtab->tp_vars->dv_hashtab,
  						 (char_u *)"t:", TRUE, first);
  }
- #endif
  
  /*
   * List Vim variables.
--- 1474,1479 ----
***************
*** 1565,1573 ****
  				case 'g': list_glob_vars(first); break;
  				case 'b': list_buf_vars(first); break;
  				case 'w': list_win_vars(first); break;
- #ifdef FEAT_WINDOWS
  				case 't': list_tab_vars(first); break;
- #endif
  				case 'v': list_vim_vars(first); break;
  				case 's': list_script_vars(first); break;
  				case 'l': list_func_vars(first); break;
--- 1559,1565 ----
***************
*** 3075,3083 ****
      static long_u	gdone;
      static long_u	bdone;
      static long_u	wdone;
- #ifdef FEAT_WINDOWS
      static long_u	tdone;
- #endif
      static int		vidx;
      static hashitem_T	*hi;
      hashtab_T		*ht;
--- 3067,3073 ----
***************
*** 3085,3093 ****
      if (idx == 0)
      {
  	gdone = bdone = wdone = vidx = 0;
- #ifdef FEAT_WINDOWS
  	tdone = 0;
- #endif
      }
  
      /* Global variables */
--- 3075,3081 ----
***************
*** 3130,3136 ****
  	return cat_prefix_varname('w', hi->hi_key);
      }
  
- #ifdef FEAT_WINDOWS
      /* t: variables */
      ht = &curtab->tp_vars->dv_hashtab;
      if (tdone < ht->ht_used)
--- 3118,3123 ----
***************
*** 3143,3149 ****
  	    ++hi;
  	return cat_prefix_varname('t', hi->hi_key);
      }
- #endif
  
      /* v: variables */
      if (vidx < VV_LEN)
--- 3130,3135 ----
***************
*** 5238,5246 ****
      win_T	*wp;
      int		i;
      int		did_free = FALSE;
- #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
- #endif
  
      if (!testing)
      {
--- 5224,5230 ----
***************
*** 5283,5295 ****
  								  NULL, NULL);
  #endif
  
- #ifdef FEAT_WINDOWS
      /* tabpage-local variables */
      FOR_ALL_TABPAGES(tp)
  	abort = abort || set_ref_in_item(&tp->tp_winvar.di_tv, copyID,
  								  NULL, NULL);
- #endif
- 
      /* global variables */
      abort = abort || set_ref_in_ht(&globvarht, copyID, NULL);
  
--- 5267,5276 ----
***************
*** 7389,7397 ****
  	    case 'v': return &vimvars_var;
  	    case 'b': return &curbuf->b_bufvar;
  	    case 'w': return &curwin->w_winvar;
- #ifdef FEAT_WINDOWS
  	    case 't': return &curtab->tp_winvar;
- #endif
  	    case 'l': return get_funccal_local_var();
  	    case 'a': return get_funccal_args_var();
  	}
--- 7370,7376 ----
***************
*** 7461,7470 ****
  	return &curbuf->b_vars->dv_hashtab;
      if (*name == 'w')				/* window variable */
  	return &curwin->w_vars->dv_hashtab;
- #ifdef FEAT_WINDOWS
      if (*name == 't')				/* tab page variable */
  	return &curtab->tp_vars->dv_hashtab;
- #endif
      if (*name == 'v')				/* v: variable */
  	return &vimvarht;
      if (*name == 'a')				/* a: function argument */
--- 7440,7447 ----
***************
*** 8386,8399 ****
      typval_T	*vp,
      tabpage_T	*tp UNUSED)	/* NULL for current tab page */
  {
- #ifdef FEAT_WINDOWS
      win_T	*wp;
- #endif
      int		nr;
  
      nr = (int)get_tv_number_chk(vp, NULL);
  
- #ifdef FEAT_WINDOWS
      if (nr < 0)
  	return NULL;
      if (nr == 0)
--- 8363,8373 ----
***************
*** 8412,8422 ****
      if (nr >= LOWEST_WIN_ID)
  	return NULL;
      return wp;
- #else
-     if (nr == 0 || nr == 1 || nr == curwin->w_id)
- 	return curwin;
-     return NULL;
- #endif
  }
  
  /*
--- 8386,8391 ----
***************
*** 8465,8482 ****
      dictitem_T	*v;
      tabpage_T	*tp = NULL;
      int		done = FALSE;
- #ifdef FEAT_WINDOWS
      win_T	*oldcurwin;
      tabpage_T	*oldtabpage;
      int		need_switch_win;
- #endif
  
- #ifdef FEAT_WINDOWS
      if (off == 1)
  	tp = find_tabpage((int)get_tv_number_chk(&argvars[0], NULL));
      else
  	tp = curtab;
- #endif
      win = find_win_by_nr(&argvars[off], tp);
      varname = get_tv_string_chk(&argvars[off + 1]);
      ++emsg_off;
--- 8434,8447 ----
***************
*** 8486,8499 ****
  
      if (win != NULL && varname != NULL)
      {
- #ifdef FEAT_WINDOWS
  	/* Set curwin to be our win, temporarily.  Also set the tabpage,
  	 * otherwise the window is not valid. Only do this when needed,
  	 * autocommands get blocked. */
  	need_switch_win = !(tp == curtab && win == curwin);
  	if (!need_switch_win
  		  || switch_win(&oldcurwin, &oldtabpage, win, tp, TRUE) == OK)
- #endif
  	{
  	    if (*varname == '&')
  	    {
--- 8451,8462 ----
***************
*** 8526,8536 ****
  	    }
  	}
  
- #ifdef FEAT_WINDOWS
  	if (need_switch_win)
  	    /* restore previous notion of curwin */
  	    restore_win(oldcurwin, oldtabpage, TRUE);
- #endif
      }
  
      if (!done && argvars[off + 2].v_type != VAR_UNKNOWN)
--- 8489,8497 ----
***************
*** 8547,8557 ****
  setwinvar(typval_T *argvars, typval_T *rettv UNUSED, int off)
  {
      win_T	*win;
- #ifdef FEAT_WINDOWS
      win_T	*save_curwin;
      tabpage_T	*save_curtab;
      int		need_switch_win;
- #endif
      char_u	*varname, *winvarname;
      typval_T	*varp;
      char_u	nbuf[NUMBUFLEN];
--- 8508,8516 ----
***************
*** 8560,8582 ****
      if (check_restricted() || check_secure())
  	return;
  
- #ifdef FEAT_WINDOWS
      if (off == 1)
  	tp = find_tabpage((int)get_tv_number_chk(&argvars[0], NULL));
      else
  	tp = curtab;
- #endif
      win = find_win_by_nr(&argvars[off], tp);
      varname = get_tv_string_chk(&argvars[off + 1]);
      varp = &argvars[off + 2];
  
      if (win != NULL && varname != NULL && varp != NULL)
      {
- #ifdef FEAT_WINDOWS
  	need_switch_win = !(tp == curtab && win == curwin);
  	if (!need_switch_win
  	       || switch_win(&save_curwin, &save_curtab, win, tp, TRUE) == OK)
- #endif
  	{
  	    if (*varname == '&')
  	    {
--- 8519,8537 ----
***************
*** 8602,8611 ****
  		}
  	    }
  	}
- #ifdef FEAT_WINDOWS
  	if (need_switch_win)
  	    restore_win(save_curwin, save_curtab, TRUE);
- #endif
      }
  }
  
--- 8557,8564 ----
*** ../vim-8.0.1117/src/evalfunc.c	2017-09-16 17:19:17.699480339 +0200
--- src/evalfunc.c	2017-09-16 19:39:23.577500295 +0200
***************
*** 1638,1653 ****
      static void
  buf_win_common(typval_T *argvars, typval_T *rettv, int get_nr)
  {
- #ifdef FEAT_WINDOWS
      win_T	*wp;
      int		winnr = 0;
- #endif
      buf_T	*buf;
  
      (void)get_tv_number(&argvars[0]);	    /* issue errmsg if type error */
      ++emsg_off;
      buf = get_buf_tv(&argvars[0], TRUE);
- #ifdef FEAT_WINDOWS
      FOR_ALL_WINDOWS(wp)
      {
  	++winnr;
--- 1638,1650 ----
***************
*** 1655,1664 ****
  	    break;
      }
      rettv->vval.v_number = (wp != NULL ? (get_nr ? winnr : wp->w_id) : -1);
- #else
-     rettv->vval.v_number = (curwin->w_buffer == buf
- 					  ? (get_nr ? 1 : curwin->w_id) : -1);
- #endif
      --emsg_off;
  }
  
--- 1652,1657 ----
***************
*** 4390,4398 ****
  	    int		col = mouse_col;
  	    win_T	*win;
  	    linenr_T	lnum;
- # ifdef FEAT_WINDOWS
  	    win_T	*wp;
- # endif
  	    int		winnr = 1;
  
  	    if (row >= 0 && col >= 0)
--- 4383,4389 ----
***************
*** 4403,4412 ****
  		if (win == NULL)
  		    return;
  		(void)mouse_comp_pos(win, &row, &col, &lnum);
- # ifdef FEAT_WINDOWS
  		for (wp = firstwin; wp != win; wp = wp->w_next)
  		    ++winnr;
- # endif
  		set_vim_var_nr(VV_MOUSE_WIN, winnr);
  		set_vim_var_nr(VV_MOUSE_WINID, win->w_id);
  		set_vim_var_nr(VV_MOUSE_LNUM, lnum);
--- 4394,4401 ----
***************
*** 5105,5111 ****
      rettv->vval.v_string = vim_strsave(buf);
  }
  
- #ifdef FEAT_WINDOWS
  /*
   * Returns information (variables, options, etc.) about a tab page
   * as a dictionary.
--- 5094,5099 ----
***************
*** 5137,5143 ****
  
      return dict;
  }
- #endif
  
  /*
   * "gettabinfo()" function
--- 5125,5130 ----
***************
*** 5145,5151 ****
      static void
  f_gettabinfo(typval_T *argvars, typval_T *rettv)
  {
- #ifdef FEAT_WINDOWS
      tabpage_T	*tp, *tparg = NULL;
      dict_T	*d;
      int		tpnr = 0;
--- 5132,5137 ----
***************
*** 5173,5179 ****
  	if (tparg != NULL)
  	    return;
      }
- #endif
  }
  
  /*
--- 5159,5164 ----
***************
*** 5228,5234 ****
      getwinvar(argvars, rettv, 1);
  }
  
- #ifdef FEAT_WINDOWS
  /*
   * Returns information about a window as a dictionary.
   */
--- 5213,5218 ----
***************
*** 5262,5268 ****
  
      return dict;
  }
- #endif
  
  /*
   * "getwininfo()" function
--- 5246,5251 ----
***************
*** 5270,5286 ****
      static void
  f_getwininfo(typval_T *argvars, typval_T *rettv)
  {
- #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
      win_T	*wp = NULL, *wparg = NULL;
      dict_T	*d;
      short	tabnr = 0, winnr;
- #endif
  
      if (rettv_list_alloc(rettv) != OK)
  	return;
  
- #ifdef FEAT_WINDOWS
      if (argvars[0].v_type != VAR_UNKNOWN)
      {
  	wparg = win_id2wp(argvars);
--- 5253,5266 ----
***************
*** 5308,5314 ****
  		return;
  	}
      }
- #endif
  }
  
  /*
--- 5288,5293 ----
***************
*** 5978,5986 ****
  #ifdef FEAT_VIMINFO
  	"viminfo",
  #endif
- #ifdef FEAT_WINDOWS
  	"vertsplit",
- #endif
  #ifdef FEAT_VIRTUALEDIT
  	"virtualedit",
  #endif
--- 5957,5963 ----
***************
*** 5997,6005 ****
  #ifdef FEAT_WILDMENU
  	"wildmenu",
  #endif
- #ifdef FEAT_WINDOWS
  	"windows",
- #endif
  #ifdef FEAT_WAK
  	"winaltkeys",
  #endif
--- 5974,5980 ----
***************
*** 10526,10535 ****
      static void
  f_settabvar(typval_T *argvars, typval_T *rettv)
  {
- #ifdef FEAT_WINDOWS
      tabpage_T	*save_curtab;
      tabpage_T	*tp;
- #endif
      char_u	*varname, *tabvarname;
      typval_T	*varp;
  
--- 10501,10508 ----
***************
*** 10538,10559 ****
      if (check_restricted() || check_secure())
  	return;
  
- #ifdef FEAT_WINDOWS
      tp = find_tabpage((int)get_tv_number_chk(&argvars[0], NULL));
- #endif
      varname = get_tv_string_chk(&argvars[1]);
      varp = &argvars[2];
  
!     if (varname != NULL && varp != NULL
! #ifdef FEAT_WINDOWS
! 	    && tp != NULL
! #endif
! 	    )
      {
- #ifdef FEAT_WINDOWS
  	save_curtab = curtab;
  	goto_tabpage_tp(tp, FALSE, FALSE);
- #endif
  
  	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
  	if (tabvarname != NULL)
--- 10511,10524 ----
      if (check_restricted() || check_secure())
  	return;
  
      tp = find_tabpage((int)get_tv_number_chk(&argvars[0], NULL));
      varname = get_tv_string_chk(&argvars[1]);
      varp = &argvars[2];
  
!     if (varname != NULL && varp != NULL && tp != NULL)
      {
  	save_curtab = curtab;
  	goto_tabpage_tp(tp, FALSE, FALSE);
  
  	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
  	if (tabvarname != NULL)
***************
*** 10564,10574 ****
  	    vim_free(tabvarname);
  	}
  
- #ifdef FEAT_WINDOWS
  	/* Restore current tabpage */
  	if (valid_tabpage(save_curtab))
  	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
- #endif
      }
  }
  
--- 10529,10537 ----
***************
*** 12274,12280 ****
      static void
  f_tabpagebuflist(typval_T *argvars UNUSED, typval_T *rettv UNUSED)
  {
- #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
      win_T	*wp = NULL;
  
--- 12237,12242 ----
***************
*** 12293,12299 ****
  						wp->w_buffer->b_fnum) == FAIL)
  		break;
      }
- #endif
  }
  
  
--- 12255,12260 ----
***************
*** 12304,12310 ****
  f_tabpagenr(typval_T *argvars UNUSED, typval_T *rettv)
  {
      int		nr = 1;
- #ifdef FEAT_WINDOWS
      char_u	*arg;
  
      if (argvars[0].v_type != VAR_UNKNOWN)
--- 12265,12270 ----
***************
*** 12321,12332 ****
      }
      else
  	nr = tabpage_index(curtab);
- #endif
      rettv->vval.v_number = nr;
  }
  
  
- #ifdef FEAT_WINDOWS
  static int get_winnr(tabpage_T *tp, typval_T *argvar);
  
  /*
--- 12281,12290 ----
***************
*** 12375,12381 ****
  	}
      return nr;
  }
- #endif
  
  /*
   * "tabpagewinnr()" function
--- 12333,12338 ----
***************
*** 12384,12390 ****
  f_tabpagewinnr(typval_T *argvars UNUSED, typval_T *rettv)
  {
      int		nr = 1;
- #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
  
      tp = find_tabpage((int)get_tv_number(&argvars[0]));
--- 12341,12346 ----
***************
*** 12392,12398 ****
  	nr = 0;
      else
  	nr = get_winnr(tp, &argvars[1]);
- #endif
      rettv->vval.v_number = nr;
  }
  
--- 12348,12353 ----
***************
*** 13211,13219 ****
  {
      int		nr = 1;
  
- #ifdef FEAT_WINDOWS
      nr = get_winnr(curtab, &argvars[0]);
- #endif
      rettv->vval.v_number = nr;
  }
  
--- 13166,13172 ----
***************
*** 13223,13229 ****
      static void
  f_winrestcmd(typval_T *argvars UNUSED, typval_T *rettv)
  {
- #ifdef FEAT_WINDOWS
      win_T	*wp;
      int		winnr = 1;
      garray_T	ga;
--- 13176,13181 ----
***************
*** 13241,13249 ****
      ga_append(&ga, NUL);
  
      rettv->vval.v_string = ga.ga_data;
- #else
-     rettv->vval.v_string = NULL;
- #endif
      rettv->v_type = VAR_STRING;
  }
  
--- 13193,13198 ----
***************
*** 13287,13295 ****
  
  	check_cursor();
  	win_new_height(curwin, curwin->w_height);
- # ifdef FEAT_WINDOWS
  	win_new_width(curwin, W_WIDTH(curwin));
- # endif
  	changed_window_setting();
  
  	if (curwin->w_topline <= 0)
--- 13236,13242 ----
***************
*** 13342,13352 ****
      if (wp == NULL)
  	rettv->vval.v_number = -1;
      else
- #ifdef FEAT_WINDOWS
  	rettv->vval.v_number = wp->w_width;
- #else
- 	rettv->vval.v_number = Columns;
- #endif
  }
  
  /*
--- 13289,13295 ----
*** ../vim-8.0.1117/src/ex_cmds.c	2017-08-31 20:42:14.940643583 +0200
--- src/ex_cmds.c	2017-09-16 19:41:12.452847673 +0200
***************
*** 3225,3233 ****
  	    if (retval == OK)
  	    {
  		curbuf->b_p_ro = FALSE;
- #ifdef FEAT_WINDOWS
  		redraw_tabline = TRUE;
- #endif
  	    }
  	}
  
--- 3225,3231 ----
***************
*** 4153,4159 ****
  #ifdef FEAT_FOLDING
  	/* It's possible that all lines in the buffer changed.  Need to update
  	 * automatic folding for all windows where it's used. */
- # ifdef FEAT_WINDOWS
  	{
  	    win_T	    *win;
  	    tabpage_T	    *tp;
--- 4151,4156 ----
***************
*** 4162,4170 ****
  		if (win->w_buffer == curbuf)
  		    foldUpdateAll(win);
  	}
- # else
- 	foldUpdateAll(curwin);
- # endif
  #endif
  
  	/* Change directories when the 'acd' option is set. */
--- 4159,4164 ----
***************
*** 4284,4293 ****
  	}
      }
  
- #ifdef FEAT_WINDOWS
      /* Check if cursors in other windows on the same buffer are still valid */
      check_lnums(FALSE);
- #endif
  
      /*
       * Did not read the file, need to show some info about the file.
--- 4278,4285 ----
***************
*** 4583,4592 ****
       * 'scroll' */
      if (eap->forceit)
  	bigness = curwin->w_height;
- #ifdef FEAT_WINDOWS
      else if (!ONE_WINDOW)
  	bigness = curwin->w_height - 3;
- #endif
      else
  	bigness = curwin->w_p_scr * 2;
      if (bigness < 1)
--- 4575,4582 ----
***************
*** 6152,6158 ****
  }
  #endif
  
! #if (defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)) || defined(PROTO)
  /*
   * Set up for a tagpreview.
   * Return TRUE when it was created.
--- 6142,6148 ----
  }
  #endif
  
! #if defined(FEAT_QUICKFIX) || defined(PROTO)
  /*
   * Set up for a tagpreview.
   * Return TRUE when it was created.
***************
*** 6215,6223 ****
      FILE	*helpfd;	/* file descriptor of help file */
      int		n;
      int		i;
- #ifdef FEAT_WINDOWS
      win_T	*wp;
- #endif
      int		num_matches;
      char_u	**matches;
      char_u	*p;
--- 6205,6211 ----
***************
*** 6319,6331 ****
       * Re-use an existing help window or open a new one.
       * Always open a new one for ":tab help".
       */
!     if (!bt_help(curwin->w_buffer)
! #ifdef FEAT_WINDOWS
! 	    || cmdmod.tab != 0
! #endif
! 	    )
      {
- #ifdef FEAT_WINDOWS
  	if (cmdmod.tab != 0)
  	    wp = NULL;
  	else
--- 6307,6314 ----
       * Re-use an existing help window or open a new one.
       * Always open a new one for ":tab help".
       */
!     if (!bt_help(curwin->w_buffer) || cmdmod.tab != 0)
      {
  	if (cmdmod.tab != 0)
  	    wp = NULL;
  	else
***************
*** 6335,6341 ****
  	if (wp != NULL && wp->w_buffer->b_nwindows > 0)
  	    win_enter(wp, TRUE);
  	else
- #endif
  	{
  	    /*
  	     * There is no help window yet.
--- 6318,6323 ----
***************
*** 6348,6354 ****
  	    }
  	    fclose(helpfd);
  
- #ifdef FEAT_WINDOWS
  	    /* Split off help window; put it at far top if no position
  	     * specified, the current window is vertically split and
  	     * narrow. */
--- 6330,6335 ----
***************
*** 6358,6373 ****
  		n |= WSP_TOP;
  	    if (win_split(0, n) == FAIL)
  		goto erret;
- #else
- 	    /* use current window */
- 	    if (!can_abandon(curbuf, FALSE))
- 		goto erret;
- #endif
  
- #ifdef FEAT_WINDOWS
  	    if (curwin->w_height < p_hh)
  		win_setheight((int)p_hh);
- #endif
  
  	    /*
  	     * Open help file (do_ecmd() will set b_help flag, readfile() will
--- 6339,6347 ----
***************
*** 6377,6388 ****
  	    alt_fnum = curbuf->b_fnum;
  	    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_LASTL,
  			  ECMD_HIDE + ECMD_SET_HELP,
! #ifdef FEAT_WINDOWS
! 			  NULL  /* buffer is still open, don't store info */
! #else
! 			  curwin
! #endif
! 		    );
  	    if (!cmdmod.keepalt)
  		curwin->w_alt_fnum = alt_fnum;
  	    empty_fnum = curbuf->b_fnum;
--- 6351,6357 ----
  	    alt_fnum = curbuf->b_fnum;
  	    (void)do_ecmd(0, NULL, NULL, NULL, ECMD_LASTL,
  			  ECMD_HIDE + ECMD_SET_HELP,
! 			  NULL);  /* buffer is still open, don't store info */
  	    if (!cmdmod.keepalt)
  		curwin->w_alt_fnum = alt_fnum;
  	    empty_fnum = curbuf->b_fnum;
***************
*** 6425,6431 ****
      void
  ex_helpclose(exarg_T *eap UNUSED)
  {
- #if defined(FEAT_WINDOWS)
      win_T *win;
  
      FOR_ALL_WINDOWS(win)
--- 6394,6399 ----
***************
*** 6436,6442 ****
  	    return;
  	}
      }
- #endif
  }
  
  #if defined(FEAT_MULTI_LANG) || defined(PROTO)
--- 6404,6409 ----
***************
*** 8350,8358 ****
      int		split = FALSE;
      win_T	*wp;
      buf_T	*buf;
- # ifdef FEAT_WINDOWS
      tabpage_T	*tp;
- # endif
  
      /*
       * Check if the first argument is already being edited in a window.  If
--- 8317,8323 ----
***************
*** 8372,8378 ****
      if (ARGCOUNT == 0)
  	return;
  
- # ifdef FEAT_WINDOWS
      if (cmdmod.tab)
      {
  	/* ":tab drop file ...": open a tab for each argument that isn't
--- 8337,8342 ----
***************
*** 8381,8387 ****
  	ex_all(eap);
      }
      else
- # endif
      {
  	/* ":drop file ...": Edit the first argument.  Jump to an existing
  	 * window if possible, edit in current window if the current buffer
--- 8345,8350 ----
***************
*** 8392,8400 ****
  	{
  	    if (wp->w_buffer == buf)
  	    {
- # ifdef FEAT_WINDOWS
  		goto_tabpage_win(tp, wp);
- # endif
  		curwin->w_arg_idx = 0;
  		return;
  	    }
--- 8355,8361 ----
***************
*** 8408,8423 ****
  	 */
  	if (!buf_hide(curbuf))
  	{
- # ifdef FEAT_WINDOWS
  	    ++emsg_off;
- # endif
  	    split = check_changed(curbuf, CCGD_AW | CCGD_EXCMD);
- # ifdef FEAT_WINDOWS
  	    --emsg_off;
- # else
- 	    if (split)
- 		return;
- # endif
  	}
  
  	/* Fake a ":sfirst" or ":first" command edit the first argument. */
--- 8369,8377 ----
*** ../vim-8.0.1117/src/ex_cmds2.c	2017-09-14 22:55:33.333391448 +0200
--- src/ex_cmds2.c	2017-09-16 19:42:50.656259329 +0200
***************
*** 2123,2132 ****
      int		bufnum = 0;
      int		bufcount = 0;
      int		*bufnrs;
- #ifdef FEAT_WINDOWS
      tabpage_T   *tp;
      win_T	*wp;
- #endif
  
      FOR_ALL_BUFFERS(buf)
  	++bufcount;
--- 2123,2130 ----
***************
*** 2140,2146 ****
  
      /* curbuf */
      bufnrs[bufnum++] = curbuf->b_fnum;
- #ifdef FEAT_WINDOWS
      /* buf in curtab */
      FOR_ALL_WINDOWS(wp)
  	if (wp->w_buffer != curbuf)
--- 2138,2143 ----
***************
*** 2151,2157 ****
  	if (tp != curtab)
  	    for (wp = tp->tp_firstwin; wp != NULL; wp = wp->w_next)
  		add_bufnum(bufnrs, &bufnum, wp->w_buffer->b_fnum);
- #endif
      /* any other buf */
      FOR_ALL_BUFFERS(buf)
  	add_bufnum(bufnrs, &bufnum, buf->b_fnum);
--- 2148,2153 ----
***************
*** 2214,2242 ****
  	}
      }
  
- #ifdef FEAT_WINDOWS
      /* Try to find a window that contains the buffer. */
      if (buf != curbuf)
  	FOR_ALL_TAB_WINDOWS(tp, wp)
  	    if (wp->w_buffer == buf)
  	    {
! # ifdef FEAT_AUTOCMD
  		bufref_T bufref;
  
  		set_bufref(&bufref, buf);
! # endif
  		goto_tabpage_win(tp, wp);
! # ifdef FEAT_AUTOCMD
  		/* Paranoia: did autocms wipe out the buffer with changes? */
  		if (!bufref_valid(&bufref))
  		{
  		    goto theend;
  		}
! # endif
  		goto buf_found;
  	    }
  buf_found:
- #endif
  
      /* Open the changed buffer in the current window. */
      if (buf != curbuf)
--- 2210,2236 ----
  	}
      }
  
      /* Try to find a window that contains the buffer. */
      if (buf != curbuf)
  	FOR_ALL_TAB_WINDOWS(tp, wp)
  	    if (wp->w_buffer == buf)
  	    {
! #ifdef FEAT_AUTOCMD
  		bufref_T bufref;
  
  		set_bufref(&bufref, buf);
! #endif
  		goto_tabpage_win(tp, wp);
! #ifdef FEAT_AUTOCMD
  		/* Paranoia: did autocms wipe out the buffer with changes? */
  		if (!bufref_valid(&bufref))
  		{
  		    goto theend;
  		}
! #endif
  		goto buf_found;
  	    }
  buf_found:
  
      /* Open the changed buffer in the current window. */
      if (buf != curbuf)
***************
*** 2528,2543 ****
      static void
  alist_check_arg_idx(void)
  {
- #ifdef FEAT_WINDOWS
      win_T	*win;
      tabpage_T	*tp;
  
      FOR_ALL_TAB_WINDOWS(tp, win)
  	if (win->w_alist == curwin->w_alist)
  	    check_arg_idx(win);
- #else
-     check_arg_idx(curwin);
- #endif
  }
  
  /*
--- 2522,2533 ----
***************
*** 2569,2577 ****
  	win->w_arg_idx_invalid = TRUE;
  	if (win->w_arg_idx != WARGCOUNT(win) - 1
  		&& arg_had_last == FALSE
- #ifdef FEAT_WINDOWS
  		&& ALIST(win) == &global_alist
- #endif
  		&& GARGCOUNT > 0
  		&& win->w_arg_idx < GARGCOUNT
  		&& (win->w_buffer->b_fnum == GARGLIST[GARGCOUNT - 1].ae_fnum
--- 2559,2565 ----
***************
*** 2586,2595 ****
  	 * Set "arg_had_last" if it's also the last one */
  	win->w_arg_idx_invalid = FALSE;
  	if (win->w_arg_idx == WARGCOUNT(win) - 1
! #ifdef FEAT_WINDOWS
! 		&& win->w_alist == &global_alist
! #endif
! 		)
  	    arg_had_last = TRUE;
      }
  }
--- 2574,2580 ----
  	 * Set "arg_had_last" if it's also the last one */
  	win->w_arg_idx_invalid = FALSE;
  	if (win->w_arg_idx == WARGCOUNT(win) - 1
! 					      && win->w_alist == &global_alist)
  	    arg_had_last = TRUE;
      }
  }
***************
*** 2604,2610 ****
  
      if (eap->cmdidx != CMD_args)
      {
! #if defined(FEAT_WINDOWS) && defined(FEAT_LISTCMDS)
  	alist_unlink(ALIST(curwin));
  	if (eap->cmdidx == CMD_argglobal)
  	    ALIST(curwin) = &global_alist;
--- 2589,2595 ----
  
      if (eap->cmdidx != CMD_args)
      {
! #if defined(FEAT_LISTCMDS)
  	alist_unlink(ALIST(curwin));
  	if (eap->cmdidx == CMD_argglobal)
  	    ALIST(curwin) = &global_alist;
***************
*** 2625,2631 ****
  	ex_next(eap);
      }
      else
! #if defined(FEAT_WINDOWS) && defined(FEAT_LISTCMDS)
  	if (eap->cmdidx == CMD_args)
  #endif
      {
--- 2610,2616 ----
  	ex_next(eap);
      }
      else
! #if defined(FEAT_LISTCMDS)
  	if (eap->cmdidx == CMD_args)
  #endif
      {
***************
*** 2648,2654 ****
  	    }
  	}
      }
! #if defined(FEAT_WINDOWS) && defined(FEAT_LISTCMDS)
      else if (eap->cmdidx == CMD_arglocal)
      {
  	garray_T	*gap = &curwin->w_alist->al_ga;
--- 2633,2639 ----
  	    }
  	}
      }
! #if defined(FEAT_LISTCMDS)
      else if (eap->cmdidx == CMD_arglocal)
      {
  	garray_T	*gap = &curwin->w_alist->al_ga;
***************
*** 2742,2748 ****
  	need_mouse_correct = TRUE;
  #endif
  
- #ifdef FEAT_WINDOWS
  	/* split window or create new tab page first */
  	if (*eap->cmd == 's' || cmdmod.tab != 0)
  	{
--- 2727,2732 ----
***************
*** 2751,2757 ****
  	    RESET_BINDING(curwin);
  	}
  	else
- #endif
  	{
  	    /*
  	     * if 'hidden' set, only check for changed file when re-editing
--- 2735,2740 ----
***************
*** 2773,2783 ****
  	}
  
  	curwin->w_arg_idx = argn;
! 	if (argn == ARGCOUNT - 1
! #ifdef FEAT_WINDOWS
! 		&& curwin->w_alist == &global_alist
! #endif
! 	   )
  	    arg_had_last = TRUE;
  
  	/* Edit the file; always use the last known line number.
--- 2756,2762 ----
  	}
  
  	curwin->w_arg_idx = argn;
! 	if (argn == ARGCOUNT - 1 && curwin->w_alist == &global_alist)
  	    arg_had_last = TRUE;
  
  	/* Edit the file; always use the last known line number.
***************
*** 2917,2926 ****
  ex_listdo(exarg_T *eap)
  {
      int		i;
- #ifdef FEAT_WINDOWS
      win_T	*wp;
      tabpage_T	*tp;
- #endif
      buf_T	*buf = curbuf;
      int		next_fnum = 0;
  #if defined(FEAT_AUTOCMD) && defined(FEAT_SYN_HL)
--- 2896,2903 ----
***************
*** 2932,2945 ****
      int		qf_idx;
  #endif
  
- #ifndef FEAT_WINDOWS
-     if (eap->cmdidx == CMD_windo)
-     {
- 	ex_ni(eap);
- 	return;
-     }
- #endif
- 
  #ifndef FEAT_QUICKFIX
      if (eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo ||
  	    eap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo)
--- 2909,2914 ----
***************
*** 2968,2980 ****
      {
  	i = 0;
  	/* start at the eap->line1 argument/window/buffer */
- #ifdef FEAT_WINDOWS
  	wp = firstwin;
  	tp = first_tabpage;
- #endif
  	switch (eap->cmdidx)
  	{
- #ifdef FEAT_WINDOWS
  	    case CMD_windo:
  		for ( ; wp != NULL && i + 1 < eap->line1; wp = wp->w_next)
  		    i++;
--- 2937,2946 ----
***************
*** 2983,2989 ****
  		for( ; tp != NULL && i + 1 < eap->line1; tp = tp->tp_next)
  		    i++;
  		break;
- #endif
  	    case CMD_argdo:
  		i = eap->line1 - 1;
  		break;
--- 2949,2954 ----
***************
*** 3049,3055 ****
  		if (curwin->w_arg_idx != i)
  		    break;
  	    }
- #ifdef FEAT_WINDOWS
  	    else if (eap->cmdidx == CMD_windo)
  	    {
  		/* go to window "wp" */
--- 3014,3019 ----
***************
*** 3068,3074 ****
  		goto_tabpage_tp(tp, TRUE, TRUE);
  		tp = tp->tp_next;
  	    }
- #endif
  	    else if (eap->cmdidx == CMD_bufdo)
  	    {
  		/* Remember the number of the next listed buffer, in case
--- 3032,3037 ----
***************
*** 3140,3150 ****
  #endif
  	    }
  
- #ifdef FEAT_WINDOWS
  	    if (eap->cmdidx == CMD_windo || eap->cmdidx == CMD_tabdo)
  		if (i+1 > eap->line2)
  		    break;
- #endif
  	    if (eap->cmdidx == CMD_argdo && i >= eap->line2)
  		break;
  	}
--- 3103,3111 ----
*** ../vim-8.0.1117/src/ex_docmd.c	2017-09-14 22:55:33.333391448 +0200
--- src/ex_docmd.c	2017-09-16 19:48:36.966214556 +0200
***************
*** 108,114 ****
  # define buflist_list		ex_ni
  # define ex_checktime		ex_ni
  #endif
! #if !defined(FEAT_LISTCMDS) || !defined(FEAT_WINDOWS)
  # define ex_buffer_all		ex_ni
  #endif
  static char_u	*getargcmd(char_u **);
--- 108,114 ----
  # define buflist_list		ex_ni
  # define ex_checktime		ex_ni
  #endif
! #if !defined(FEAT_LISTCMDS)
  # define ex_buffer_all		ex_ni
  #endif
  static char_u	*getargcmd(char_u **);
***************
*** 126,132 ****
  # define ex_helpgrep		ex_ni
  # define ex_vimgrep		ex_ni
  #endif
! #if !defined(FEAT_QUICKFIX) || !defined(FEAT_WINDOWS)
  # define ex_cclose		ex_ni
  # define ex_copen		ex_ni
  # define ex_cwindow		ex_ni
--- 126,132 ----
  # define ex_helpgrep		ex_ni
  # define ex_vimgrep		ex_ni
  #endif
! #if !defined(FEAT_QUICKFIX)
  # define ex_cclose		ex_ni
  # define ex_copen		ex_ni
  # define ex_cwindow		ex_ni
***************
*** 159,165 ****
  static void	ex_quit(exarg_T *eap);
  static void	ex_cquit(exarg_T *eap);
  static void	ex_quit_all(exarg_T *eap);
- #ifdef FEAT_WINDOWS
  static void	ex_close(exarg_T *eap);
  static void	ex_win_close(int forceit, win_T *win, tabpage_T *tp);
  static void	ex_only(exarg_T *eap);
--- 159,164 ----
***************
*** 170,189 ****
  static void	ex_tabnext(exarg_T *eap);
  static void	ex_tabmove(exarg_T *eap);
  static void	ex_tabs(exarg_T *eap);
! #else
! # define ex_close		ex_ni
! # define ex_only		ex_ni
! # define ex_all			ex_ni
! # define ex_resize		ex_ni
! # define ex_splitview		ex_ni
! # define ex_stag		ex_ni
! # define ex_tabnext		ex_ni
! # define ex_tabmove		ex_ni
! # define ex_tabs		ex_ni
! # define ex_tabclose		ex_ni
! # define ex_tabonly		ex_ni
! #endif
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  static void	ex_pclose(exarg_T *eap);
  static void	ex_ptag(exarg_T *eap);
  static void	ex_pedit(exarg_T *eap);
--- 169,175 ----
  static void	ex_tabnext(exarg_T *eap);
  static void	ex_tabmove(exarg_T *eap);
  static void	ex_tabs(exarg_T *eap);
! #if defined(FEAT_QUICKFIX)
  static void	ex_pclose(exarg_T *eap);
  static void	ex_ptag(exarg_T *eap);
  static void	ex_pedit(exarg_T *eap);
***************
*** 314,324 ****
  static void	ex_sleep(exarg_T *eap);
  static void	do_exmap(exarg_T *eap, int isabbrev);
  static void	ex_winsize(exarg_T *eap);
- #ifdef FEAT_WINDOWS
  static void	ex_wincmd(exarg_T *eap);
- #else
- # define ex_wincmd	    ex_ni
- #endif
  #if defined(FEAT_GUI) || defined(UNIX) || defined(VMS) || defined(MSWIN)
  static void	ex_winpos(exarg_T *eap);
  #else
--- 300,306 ----
***************
*** 356,362 ****
  # define ex_findpat		ex_ni
  # define ex_checkpath		ex_ni
  #endif
! #if defined(FEAT_FIND_ID) && defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  static void	ex_psearch(exarg_T *eap);
  #else
  # define ex_psearch		ex_ni
--- 338,344 ----
  # define ex_findpat		ex_ni
  # define ex_checkpath		ex_ni
  #endif
! #if defined(FEAT_FIND_ID) && defined(FEAT_QUICKFIX)
  static void	ex_psearch(exarg_T *eap);
  #else
  # define ex_psearch		ex_ni
***************
*** 1675,1681 ****
      return buf->b_fnum;
  }
  
- #ifdef FEAT_WINDOWS
  static int current_win_nr(win_T *win);
  static int current_tab_nr(tabpage_T *tab);
  
--- 1657,1662 ----
***************
*** 1713,1725 ****
  # define LAST_WIN_NR current_win_nr(NULL)
  # define CURRENT_TAB_NR current_tab_nr(curtab)
  # define LAST_TAB_NR current_tab_nr(NULL)
- #else
- # define CURRENT_WIN_NR 1
- # define LAST_WIN_NR 1
- # define CURRENT_TAB_NR 1
- # define LAST_TAB_NR 1
- #endif
- 
  
  /*
   * Execute one Ex command.
--- 1694,1699 ----
***************
*** 1843,1858 ****
  	    /* When adding an entry, also modify cmd_exists(). */
  	    case 'a':	if (!checkforcmd(&ea.cmd, "aboveleft", 3))
  			    break;
- #ifdef FEAT_WINDOWS
  			cmdmod.split |= WSP_ABOVE;
- #endif
  			continue;
  
  	    case 'b':	if (checkforcmd(&ea.cmd, "belowright", 3))
  			{
- #ifdef FEAT_WINDOWS
  			    cmdmod.split |= WSP_BELOW;
- #endif
  			    continue;
  			}
  			if (checkforcmd(&ea.cmd, "browse", 3))
--- 1817,1828 ----
***************
*** 1864,1872 ****
  			}
  			if (!checkforcmd(&ea.cmd, "botright", 2))
  			    break;
- #ifdef FEAT_WINDOWS
  			cmdmod.split |= WSP_BOT;
- #endif
  			continue;
  
  	    case 'c':	if (!checkforcmd(&ea.cmd, "confirm", 4))
--- 1834,1840 ----
***************
*** 1937,1945 ****
  
  			if (!checkforcmd(&ea.cmd, "leftabove", 5))
  			    break;
- #ifdef FEAT_WINDOWS
  			cmdmod.split |= WSP_ABOVE;
- #endif
  			continue;
  
  	    case 'n':	if (checkforcmd(&ea.cmd, "noautocmd", 3))
--- 1905,1911 ----
***************
*** 1963,1971 ****
  
  	    case 'r':	if (!checkforcmd(&ea.cmd, "rightbelow", 6))
  			    break;
- #ifdef FEAT_WINDOWS
  			cmdmod.split |= WSP_BELOW;
- #endif
  			continue;
  
  	    case 's':	if (checkforcmd(&ea.cmd, "sandbox", 3))
--- 1929,1935 ----
***************
*** 1993,1999 ****
  
  	    case 't':	if (checkforcmd(&p, "tab", 3))
  			{
- #ifdef FEAT_WINDOWS
  			    long tabnr = get_address(&ea, &ea.cmd, ADDR_TABS,
  							    ea.skip, FALSE, 1);
  			    if (tabnr == MAXLNUM)
--- 1957,1962 ----
***************
*** 2008,2021 ****
  				cmdmod.tab = tabnr + 1;
  			    }
  			    ea.cmd = p;
- #endif
  			    continue;
  			}
  			if (!checkforcmd(&ea.cmd, "topleft", 2))
  			    break;
- #ifdef FEAT_WINDOWS
  			cmdmod.split |= WSP_TOP;
- #endif
  			continue;
  
  	    case 'u':	if (!checkforcmd(&ea.cmd, "unsilent", 3))
--- 1971,1981 ----
***************
*** 2027,2035 ****
  
  	    case 'v':	if (checkforcmd(&ea.cmd, "vertical", 4))
  			{
- #ifdef FEAT_WINDOWS
  			    cmdmod.split |= WSP_VERT;
- #endif
  			    continue;
  			}
  			if (!checkforcmd(&p, "verbose", 4))
--- 1987,1993 ----
***************
*** 2112,2122 ****
  	else
  	    ea.addr_type = ADDR_LINES;
  
- #ifdef FEAT_WINDOWS
  	/* :wincmd range depends on the argument. */
  	if (ea.cmdidx == CMD_wincmd && p != NULL)
  	    get_wincmd_addr_type(skipwhite(p), &ea);
- #endif
      }
  
      /* repeat for all ',' or ';' separated addresses */
--- 2070,2078 ----
***************
*** 6795,6801 ****
  	    *buf = '\0';
  	}
  
- #ifdef FEAT_WINDOWS
  	/* :aboveleft and :leftabove */
  	if (cmdmod.split & WSP_ABOVE)
  	    result += add_cmd_modifier(buf, "aboveleft", &multi_mods);
--- 6751,6756 ----
***************
*** 6805,6811 ****
  	/* :botright */
  	if (cmdmod.split & WSP_BOT)
  	    result += add_cmd_modifier(buf, "botright", &multi_mods);
- #endif
  
  	/* the modifiers that are simple flags */
  	for (i = 0; mod_entries[i].varp != NULL; ++i)
--- 6760,6765 ----
***************
*** 6821,6843 ****
  	if (msg_silent > 0)
  	    result += add_cmd_modifier(buf,
  		    emsg_silent > 0 ? "silent!" : "silent", &multi_mods);
- #ifdef FEAT_WINDOWS
  	/* :tab */
  	if (cmdmod.tab > 0)
  	    result += add_cmd_modifier(buf, "tab", &multi_mods);
  	/* :topleft */
  	if (cmdmod.split & WSP_TOP)
  	    result += add_cmd_modifier(buf, "topleft", &multi_mods);
- #endif
  	/* TODO: How to support :unsilent?*/
  	/* :verbose */
  	if (p_verbose > 0)
  	    result += add_cmd_modifier(buf, "verbose", &multi_mods);
- #ifdef FEAT_WINDOWS
  	/* :vertical */
  	if (cmdmod.split & WSP_VERT)
  	    result += add_cmd_modifier(buf, "vertical", &multi_mods);
- #endif
  	if (quote && buf != NULL)
  	{
  	    buf += result - 2;
--- 6775,6793 ----
***************
*** 7270,7278 ****
      static void
  ex_quit(exarg_T *eap)
  {
- #if defined(FEAT_WINDOWS) || defined(FEAT_AUTOCMD)
      win_T	*wp;
- #endif
  
  #ifdef FEAT_CMDWIN
      if (cmdwin_type != 0)
--- 7220,7226 ----
***************
*** 7287,7293 ****
  	text_locked_msg();
  	return;
      }
- #ifdef FEAT_WINDOWS
      if (eap->addr_count > 0)
      {
  	int	wnr = eap->line2;
--- 7235,7240 ----
***************
*** 7297,7315 ****
  		break;
      }
      else
- #endif
- #if defined(FEAT_WINDOWS) || defined(FEAT_AUTOCMD)
  	wp = curwin;
- #endif
  
  #ifdef FEAT_AUTOCMD
      apply_autocmds(EVENT_QUITPRE, NULL, NULL, FALSE, curbuf);
      /* Refuse to quit when locked or when the buffer in the last window is
       * being closed (can only happen in autocommands). */
!     if (curbuf_locked()
! # ifdef FEAT_WINDOWS
! 	    || !win_valid(wp)
! # endif
  	    || (wp->w_buffer->b_nwindows == 1 && wp->w_buffer->b_locked > 0))
  	return;
  #endif
--- 7244,7256 ----
  		break;
      }
      else
  	wp = curwin;
  
  #ifdef FEAT_AUTOCMD
      apply_autocmds(EVENT_QUITPRE, NULL, NULL, FALSE, curbuf);
      /* Refuse to quit when locked or when the buffer in the last window is
       * being closed (can only happen in autocommands). */
!     if (curbuf_locked() || !win_valid(wp)
  	    || (wp->w_buffer->b_nwindows == 1 && wp->w_buffer->b_locked > 0))
  	return;
  #endif
***************
*** 7334,7340 ****
      }
      else
      {
- #ifdef FEAT_WINDOWS
  	/* quit last window
  	 * Note: only_one_window() returns true, even so a help window is
  	 * still open. In that case only quit, if no address has been
--- 7275,7280 ----
***************
*** 7343,7357 ****
  	 * :h|wincmd w|q      - quit
  	 */
  	if (only_one_window() && (ONE_WINDOW || eap->addr_count == 0))
- #endif
  	    getout(0);
! #ifdef FEAT_WINDOWS
! # ifdef FEAT_GUI
  	need_mouse_correct = TRUE;
! # endif
  	/* close window; may free buffer */
  	win_close(wp, !buf_hide(wp->w_buffer) || eap->forceit);
- #endif
      }
  }
  
--- 7283,7294 ----
  	 * :h|wincmd w|q      - quit
  	 */
  	if (only_one_window() && (ONE_WINDOW || eap->addr_count == 0))
  	    getout(0);
! #ifdef FEAT_GUI
  	need_mouse_correct = TRUE;
! #endif
  	/* close window; may free buffer */
  	win_close(wp, !buf_hide(wp->w_buffer) || eap->forceit);
      }
  }
  
***************
*** 7402,7408 ****
      not_exiting();
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * ":close": close current window, unless it is the last one
   */
--- 7339,7344 ----
***************
*** 7411,7421 ****
  {
      win_T	*win;
      int		winnr = 0;
! # ifdef FEAT_CMDWIN
      if (cmdwin_type != 0)
  	cmdwin_result = Ctrl_C;
      else
! # endif
  	if (!text_locked()
  #ifdef FEAT_AUTOCMD
  		&& !curbuf_locked()
--- 7347,7357 ----
  {
      win_T	*win;
      int		winnr = 0;
! #ifdef FEAT_CMDWIN
      if (cmdwin_type != 0)
  	cmdwin_result = Ctrl_C;
      else
! #endif
  	if (!text_locked()
  #ifdef FEAT_AUTOCMD
  		&& !curbuf_locked()
***************
*** 7438,7444 ****
  	}
  }
  
! # ifdef FEAT_QUICKFIX
  /*
   * ":pclose": Close any preview window.
   */
--- 7374,7380 ----
  	}
  }
  
! #ifdef FEAT_QUICKFIX
  /*
   * ":pclose": Close any preview window.
   */
***************
*** 7454,7460 ****
  	    break;
  	}
  }
! # endif
  
  /*
   * Close window "win" and take care of handling closing the last window for a
--- 7390,7396 ----
  	    break;
  	}
  }
! #endif
  
  /*
   * Close window "win" and take care of handling closing the last window for a
***************
*** 7472,7478 ****
      need_hide = (bufIsChanged(buf) && buf->b_nwindows <= 1);
      if (need_hide && !buf_hide(buf) && !forceit)
      {
! # if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
  	if ((p_confirm || cmdmod.confirm) && p_write)
  	{
  	    bufref_T bufref;
--- 7408,7414 ----
      need_hide = (bufIsChanged(buf) && buf->b_nwindows <= 1);
      if (need_hide && !buf_hide(buf) && !forceit)
      {
! #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
  	if ((p_confirm || cmdmod.confirm) && p_write)
  	{
  	    bufref_T bufref;
***************
*** 7484,7499 ****
  	    need_hide = FALSE;
  	}
  	else
! # endif
  	{
  	    no_write_message();
  	    return;
  	}
      }
  
! # ifdef FEAT_GUI
      need_mouse_correct = TRUE;
! # endif
  
      /* free buffer when not hiding it or when it's a scratch buffer */
      if (tp == NULL)
--- 7420,7435 ----
  	    need_hide = FALSE;
  	}
  	else
! #endif
  	{
  	    no_write_message();
  	    return;
  	}
      }
  
! #ifdef FEAT_GUI
      need_mouse_correct = TRUE;
! #endif
  
      /* free buffer when not hiding it or when it's a scratch buffer */
      if (tp == NULL)
***************
*** 7779,7796 ****
  	eap->line2 = 9999;
      do_arg_all((int)eap->line2, eap->forceit, eap->cmdidx == CMD_drop);
  }
- #endif /* FEAT_WINDOWS */
  
      static void
  ex_hide(exarg_T *eap UNUSED)
  {
      /* ":hide" or ":hide | cmd": hide current window */
- #ifdef FEAT_WINDOWS
      if (!eap->skip)
      {
! # ifdef FEAT_GUI
  	need_mouse_correct = TRUE;
! # endif
  	if (eap->addr_count == 0)
  	    win_close(curwin, FALSE);	/* don't free buffer */
  	else
--- 7715,7730 ----
  	eap->line2 = 9999;
      do_arg_all((int)eap->line2, eap->forceit, eap->cmdidx == CMD_drop);
  }
  
      static void
  ex_hide(exarg_T *eap UNUSED)
  {
      /* ":hide" or ":hide | cmd": hide current window */
      if (!eap->skip)
      {
! #ifdef FEAT_GUI
  	need_mouse_correct = TRUE;
! #endif
  	if (eap->addr_count == 0)
  	    win_close(curwin, FALSE);	/* don't free buffer */
  	else
***************
*** 7809,7815 ****
  	    win_close(win, FALSE);
  	}
      }
- #endif
  }
  
  /*
--- 7743,7748 ----
***************
*** 7887,7903 ****
      }
      else
      {
- #ifdef FEAT_WINDOWS
  	if (only_one_window())	    /* quit last window, exit Vim */
- #endif
  	    getout(0);
- #ifdef FEAT_WINDOWS
  # ifdef FEAT_GUI
  	need_mouse_correct = TRUE;
  # endif
  	/* Quit current window, may free the buffer. */
  	win_close(curwin, !buf_hide(curwin->w_buffer));
- #endif
      }
  }
  
--- 7820,7832 ----
***************
*** 7947,7953 ****
      do_shell(NULL, 0);
  }
  
! #if (defined(FEAT_WINDOWS) && defined(HAVE_DROP_FILE)) \
  	|| (defined(FEAT_GUI_GTK) && defined(FEAT_DND)) \
  	|| defined(FEAT_GUI_MSWIN) \
  	|| defined(FEAT_GUI_MAC) \
--- 7876,7882 ----
      do_shell(NULL, 0);
  }
  
! #if defined(HAVE_DROP_FILE) \
  	|| (defined(FEAT_GUI_GTK) && defined(FEAT_DND)) \
  	|| defined(FEAT_GUI_MSWIN) \
  	|| defined(FEAT_GUI_MAC) \
***************
*** 8000,8006 ****
      }
      if (split)
      {
- # ifdef FEAT_WINDOWS
  	if (win_split(0, 0) == FAIL)
  	    return;
  	RESET_BINDING(curwin);
--- 7929,7934 ----
***************
*** 8009,8017 ****
  	 * existing one is overwritten. */
  	alist_unlink(curwin->w_alist);
  	alist_new();
- # else
- 	return;	    /* can't split, always fail */
- # endif
      }
  
      /*
--- 7937,7942 ----
***************
*** 8058,8065 ****
      ga_init2(&al->al_ga, (int)sizeof(aentry_T), 5);
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
- 
  /*
   * Remove a reference from an argument list.
   * Ignored when the argument list is the global one.
--- 7983,7988 ----
***************
*** 8075,8081 ****
      }
  }
  
! # if defined(FEAT_LISTCMDS) || defined(HAVE_DROP_FILE) || defined(PROTO)
  /*
   * Create a new argument list and use it for the current window.
   */
--- 7998,8004 ----
      }
  }
  
! #if defined(FEAT_LISTCMDS) || defined(HAVE_DROP_FILE) || defined(PROTO)
  /*
   * Create a new argument list and use it for the current window.
   */
***************
*** 8095,8101 ****
  	alist_init(curwin->w_alist);
      }
  }
- # endif
  #endif
  
  #if !defined(UNIX) || defined(PROTO)
--- 8018,8023 ----
***************
*** 8179,8187 ****
      }
      else
  	FreeWild(count, files);
- #ifdef FEAT_WINDOWS
      if (al == &global_alist)
- #endif
  	arg_had_last = FALSE;
  }
  
--- 8101,8107 ----
***************
*** 8215,8235 ****
  alist_slash_adjust(void)
  {
      int		i;
- # ifdef FEAT_WINDOWS
      win_T	*wp;
      tabpage_T	*tp;
- # endif
  
      for (i = 0; i < GARGCOUNT; ++i)
  	if (GARGLIST[i].ae_fname != NULL)
  	    slash_adjust(GARGLIST[i].ae_fname);
- # ifdef FEAT_WINDOWS
      FOR_ALL_TAB_WINDOWS(tp, wp)
  	if (wp->w_alist != &global_alist)
  	    for (i = 0; i < WARGCOUNT(wp); ++i)
  		if (WARGLIST(wp)[i].ae_fname != NULL)
  		    slash_adjust(WARGLIST(wp)[i].ae_fname);
- # endif
  }
  #endif
  
--- 8135,8151 ----
***************
*** 8271,8277 ****
      eap->errmsg = e_invcmd;
  }
  
- #ifdef FEAT_WINDOWS
  /*
   * :sview [+command] file	split window with new file, read-only
   * :split [[+command] file]	split window with current or new file
--- 8187,8192 ----
***************
*** 8289,8306 ****
  ex_splitview(exarg_T *eap)
  {
      win_T	*old_curwin = curwin;
! # if defined(FEAT_SEARCHPATH) || defined(FEAT_BROWSE)
      char_u	*fname = NULL;
! # endif
! # ifdef FEAT_BROWSE
      int		browse_flag = cmdmod.browse;
! # endif
  
! # ifdef FEAT_GUI
      need_mouse_correct = TRUE;
! # endif
  
! # ifdef FEAT_QUICKFIX
      /* A ":split" in the quickfix window works like ":new".  Don't want two
       * quickfix windows.  But it's OK when doing ":tab split". */
      if (bt_quickfix(curbuf) && cmdmod.tab == 0)
--- 8204,8221 ----
  ex_splitview(exarg_T *eap)
  {
      win_T	*old_curwin = curwin;
! #if defined(FEAT_SEARCHPATH) || defined(FEAT_BROWSE)
      char_u	*fname = NULL;
! #endif
! #ifdef FEAT_BROWSE
      int		browse_flag = cmdmod.browse;
! #endif
  
! #ifdef FEAT_GUI
      need_mouse_correct = TRUE;
! #endif
  
! #ifdef FEAT_QUICKFIX
      /* A ":split" in the quickfix window works like ":new".  Don't want two
       * quickfix windows.  But it's OK when doing ":tab split". */
      if (bt_quickfix(curbuf) && cmdmod.tab == 0)
***************
*** 8310,8318 ****
  	if (eap->cmdidx == CMD_vsplit)
  	    eap->cmdidx = CMD_vnew;
      }
! # endif
  
! # ifdef FEAT_SEARCHPATH
      if (eap->cmdidx == CMD_sfind || eap->cmdidx == CMD_tabfind)
      {
  	fname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg),
--- 8225,8233 ----
  	if (eap->cmdidx == CMD_vsplit)
  	    eap->cmdidx = CMD_vnew;
      }
! #endif
  
! #ifdef FEAT_SEARCHPATH
      if (eap->cmdidx == CMD_sfind || eap->cmdidx == CMD_tabfind)
      {
  	fname = find_file_in_path(eap->arg, (int)STRLEN(eap->arg),
***************
*** 8321,8331 ****
  	    goto theend;
  	eap->arg = fname;
      }
! #  ifdef FEAT_BROWSE
      else
- #  endif
  # endif
! # ifdef FEAT_BROWSE
      if (cmdmod.browse
  	    && eap->cmdidx != CMD_vnew
  	    && eap->cmdidx != CMD_new)
--- 8236,8246 ----
  	    goto theend;
  	eap->arg = fname;
      }
! # ifdef FEAT_BROWSE
      else
  # endif
! #endif
! #ifdef FEAT_BROWSE
      if (cmdmod.browse
  	    && eap->cmdidx != CMD_vnew
  	    && eap->cmdidx != CMD_new)
***************
*** 8353,8359 ****
  	}
      }
      cmdmod.browse = FALSE;	/* Don't browse again in do_ecmd(). */
! # endif
  
      /*
       * Either open new tab page or split the window.
--- 8268,8274 ----
  	}
      }
      cmdmod.browse = FALSE;	/* Don't browse again in do_ecmd(). */
! #endif
  
      /*
       * Either open new tab page or split the window.
***************
*** 8534,8541 ****
      }
  }
  
- #endif /* FEAT_WINDOWS */
- 
  /*
   * ":mode": Set screen mode.
   * If no argument given, just get the screen size and redraw.
--- 8449,8454 ----
***************
*** 8549,8555 ****
  	mch_screenmode(eap->arg);
  }
  
- #ifdef FEAT_WINDOWS
  /*
   * ":resize".
   * set, increment or decrement current window height
--- 8462,8467 ----
***************
*** 8588,8594 ****
  	win_setheight_win((int)n, wp);
      }
  }
- #endif
  
  /*
   * ":find [+command] <file>" command.
--- 8500,8505 ----
***************
*** 8681,8689 ****
      win_T	*old_curwin)	    /* curwin before doing a split or NULL */
  {
      int		n;
- #ifdef FEAT_WINDOWS
      int		need_hide;
- #endif
      int		exmode_was = exmode_active;
  
      /*
--- 8592,8598 ----
***************
*** 8738,8747 ****
      if ((eap->cmdidx == CMD_new
  		|| eap->cmdidx == CMD_tabnew
  		|| eap->cmdidx == CMD_tabedit
! #ifdef FEAT_WINDOWS
! 		|| eap->cmdidx == CMD_vnew
! #endif
! 		) && *eap->arg == NUL)
      {
  	/* ":new" or ":tabnew" without argument: edit an new empty buffer */
  	setpcmark();
--- 8647,8653 ----
      if ((eap->cmdidx == CMD_new
  		|| eap->cmdidx == CMD_tabnew
  		|| eap->cmdidx == CMD_tabedit
! 		|| eap->cmdidx == CMD_vnew) && *eap->arg == NUL)
      {
  	/* ":new" or ":tabnew" without argument: edit an new empty buffer */
  	setpcmark();
***************
*** 8749,8759 ****
  		      ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),
  		      old_curwin == NULL ? curwin : NULL);
      }
!     else if ((eap->cmdidx != CMD_split
! #ifdef FEAT_WINDOWS
! 		&& eap->cmdidx != CMD_vsplit
! #endif
! 		)
  	    || *eap->arg != NUL
  #ifdef FEAT_BROWSE
  	    || cmdmod.browse
--- 8655,8661 ----
  		      ECMD_HIDE + (eap->forceit ? ECMD_FORCEIT : 0),
  		      old_curwin == NULL ? curwin : NULL);
      }
!     else if ((eap->cmdidx != CMD_split && eap->cmdidx != CMD_vsplit)
  	    || *eap->arg != NUL
  #ifdef FEAT_BROWSE
  	    || cmdmod.browse
***************
*** 8789,8821 ****
  		    , old_curwin == NULL ? curwin : NULL) == FAIL)
  	{
  	    /* Editing the file failed.  If the window was split, close it. */
- #ifdef FEAT_WINDOWS
  	    if (old_curwin != NULL)
  	    {
  		need_hide = (curbufIsChanged() && curbuf->b_nwindows <= 1);
  		if (!need_hide || buf_hide(curbuf))
  		{
! # if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  		    cleanup_T   cs;
  
  		    /* Reset the error/interrupt/exception state here so that
  		     * aborting() returns FALSE when closing a window. */
  		    enter_cleanup(&cs);
! # endif
! # ifdef FEAT_GUI
  		    need_mouse_correct = TRUE;
! # endif
  		    win_close(curwin, !need_hide && !buf_hide(curbuf));
  
! # if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  		    /* Restore the error/interrupt/exception state if not
  		     * discarded by a new aborting error, interrupt, or
  		     * uncaught exception. */
  		    leave_cleanup(&cs);
! # endif
  		}
  	    }
- #endif
  	}
  	else if (readonlymode && curbuf->b_nwindows == 1)
  	{
--- 8691,8721 ----
  		    , old_curwin == NULL ? curwin : NULL) == FAIL)
  	{
  	    /* Editing the file failed.  If the window was split, close it. */
  	    if (old_curwin != NULL)
  	    {
  		need_hide = (curbufIsChanged() && curbuf->b_nwindows <= 1);
  		if (!need_hide || buf_hide(curbuf))
  		{
! #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  		    cleanup_T   cs;
  
  		    /* Reset the error/interrupt/exception state here so that
  		     * aborting() returns FALSE when closing a window. */
  		    enter_cleanup(&cs);
! #endif
! #ifdef FEAT_GUI
  		    need_mouse_correct = TRUE;
! #endif
  		    win_close(curwin, !need_hide && !buf_hide(curbuf));
  
! #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  		    /* Restore the error/interrupt/exception state if not
  		     * discarded by a new aborting error, interrupt, or
  		     * uncaught exception. */
  		    leave_cleanup(&cs);
! #endif
  		}
  	    }
  	}
  	else if (readonlymode && curbuf->b_nwindows == 1)
  	{
***************
*** 8841,8847 ****
  #endif
      }
  
- #ifdef FEAT_WINDOWS
      /*
       * if ":split file" worked, set alternate file name in old window to new
       * file
--- 8741,8746 ----
***************
*** 8853,8859 ****
  	    && old_curwin->w_buffer != curbuf
  	    && !cmdmod.keepalt)
  	old_curwin->w_alt_fnum = curbuf->b_fnum;
- #endif
  
      ex_no_reprint = TRUE;
  }
--- 8752,8757 ----
***************
*** 8952,8960 ****
  	    curwin->w_scbind_pos = topline;
  	    redraw_later(VALID);
  	    cursor_correct();
- #ifdef FEAT_WINDOWS
  	    curwin->w_redr_status = TRUE;
- #endif
  	}
      }
      curwin = save_curwin;
--- 8850,8856 ----
***************
*** 9309,9315 ****
  	EMSG(_("E465: :winsize requires two number arguments"));
  }
  
- #ifdef FEAT_WINDOWS
      static void
  ex_wincmd(exarg_T *eap)
  {
--- 9205,9210 ----
***************
*** 9344,9350 ****
  	postponed_split_tab = 0;
      }
  }
- #endif
  
  #if defined(FEAT_GUI) || defined(UNIX) || defined(VMS) || defined(MSWIN)
  /*
--- 9239,9244 ----
***************
*** 9865,9871 ****
      static void
  ex_redrawstatus(exarg_T *eap UNUSED)
  {
- #if defined(FEAT_WINDOWS)
      int		r = RedrawingDisabled;
      int		p = p_lz;
  
--- 9759,9764 ----
***************
*** 9879,9885 ****
      RedrawingDisabled = r;
      p_lz = p;
      out_flush();
- #endif
  }
  
      static void
--- 9772,9777 ----
***************
*** 10457,10463 ****
  					      (linenr_T)1, (linenr_T)MAXLNUM);
  }
  
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  /*
   * ":psearch"
   */
--- 10349,10355 ----
  					      (linenr_T)1, (linenr_T)MAXLNUM);
  }
  
! #if defined(FEAT_QUICKFIX)
  /*
   * ":psearch"
   */
***************
*** 10528,10536 ****
  }
  #endif
  
- #ifdef FEAT_WINDOWS
  
! # ifdef FEAT_QUICKFIX
  /*
   * ":ptag", ":ptselect", ":ptjump", ":ptnext", etc.
   */
--- 10420,10427 ----
  }
  #endif
  
  
! #ifdef FEAT_QUICKFIX
  /*
   * ":ptag", ":ptselect", ":ptjump", ":ptnext", etc.
   */
***************
*** 10563,10569 ****
      }
      g_do_tagpreview = 0;
  }
! # endif
  
  /*
   * ":stag", ":stselect" and ":stjump".
--- 10454,10460 ----
      }
      g_do_tagpreview = 0;
  }
! #endif
  
  /*
   * ":stag", ":stselect" and ":stjump".
***************
*** 10578,10584 ****
      postponed_split_flags = 0;
      postponed_split_tab = 0;
  }
- #endif
  
  /*
   * ":tag", ":tselect", ":tjump", ":tnext", etc.
--- 10469,10474 ----
*** ../vim-8.0.1117/src/ex_getln.c	2017-08-30 22:00:16.370112624 +0200
--- src/ex_getln.c	2017-09-16 19:48:55.390106659 +0200
***************
*** 1125,1131 ****
  #ifdef CURSOR_SHAPE
  		ui_cursor_shape();	/* may show different cursor shape */
  #endif
! #if defined(FEAT_WINDOWS) && defined(FEAT_KEYMAP)
  		/* Show/unshow value of 'keymap' in status lines later. */
  		status_redraw_curbuf();
  #endif
--- 1125,1131 ----
  #ifdef CURSOR_SHAPE
  		ui_cursor_shape();	/* may show different cursor shape */
  #endif
! #if defined(FEAT_KEYMAP)
  		/* Show/unshow value of 'keymap' in status lines later. */
  		status_redraw_curbuf();
  #endif
***************
*** 1966,1976 ****
  		end_pos = curwin->w_cursor; /* shutup gcc 4 */
  
  	    validate_cursor();
- # ifdef FEAT_WINDOWS
  	    /* May redraw the status line to show the cursor position. */
  	    if (p_ru && curwin->w_status_height > 0)
  		curwin->w_redr_status = TRUE;
- # endif
  
  	    save_cmdline(&save_ccline);
  	    update_screen(SOME_VALID);
--- 1966,1974 ----
*** ../vim-8.0.1117/src/fileio.c	2017-08-23 22:32:30.536388857 +0200
--- src/fileio.c	2017-09-16 19:49:45.241814705 +0200
***************
*** 4174,4182 ****
  #ifdef FEAT_TITLE
  	need_maketitle = TRUE;	    /* set window title later */
  #endif
- #ifdef FEAT_WINDOWS
  	status_redraw_all();	    /* redraw status lines later */
- #endif
      }
  
      if (end > buf->b_ml.ml_line_count)
--- 4174,4180 ----
***************
*** 6197,6206 ****
  	 * also have a swap file. */
  	mf_fullname(buf->b_ml.ml_mfp);
      }
- #ifdef FEAT_WINDOWS
      status_redraw_all();
      redraw_tabline = TRUE;
- #endif
  }
  
  #if (defined(FEAT_DND) && defined(FEAT_GUI_GTK)) \
--- 6195,6202 ----
***************
*** 8963,8971 ****
      buf_T	*buf)		/* new curbuf */
  {
      win_T	*win;
- #ifdef FEAT_WINDOWS
      int		save_ea;
- #endif
  #ifdef FEAT_AUTOCHDIR
      int		save_acd;
  #endif
--- 8959,8965 ----
***************
*** 8974,8986 ****
      if (buf == curbuf)		/* be quick when buf is curbuf */
  	win = curwin;
      else
- #ifdef FEAT_WINDOWS
  	FOR_ALL_WINDOWS(win)
  	    if (win->w_buffer == buf)
  		break;
- #else
- 	win = NULL;
- #endif
  
      /* Allocate "aucmd_win" when needed.  If this fails (out of memory) fall
       * back to using the current window. */
--- 8968,8976 ----
***************
*** 9026,9032 ****
  	globaldir = NULL;
  
  
- #ifdef FEAT_WINDOWS
  	/* Split the current window, put the aucmd_win in the upper half.
  	 * We don't want the BufEnter or WinEnter autocommands. */
  	block_autocmds();
--- 9016,9021 ----
***************
*** 9034,9053 ****
  	save_ea = p_ea;
  	p_ea = FALSE;
  
! # ifdef FEAT_AUTOCHDIR
  	/* Prevent chdir() call in win_enter_ext(), through do_autochdir(). */
  	save_acd = p_acd;
  	p_acd = FALSE;
! # endif
  
  	(void)win_split_ins(0, WSP_TOP, aucmd_win, 0);
  	(void)win_comp_pos();   /* recompute window positions */
  	p_ea = save_ea;
! # ifdef FEAT_AUTOCHDIR
  	p_acd = save_acd;
- # endif
- 	unblock_autocmds();
  #endif
  	curwin = aucmd_win;
      }
      curbuf = buf;
--- 9023,9041 ----
  	save_ea = p_ea;
  	p_ea = FALSE;
  
! #ifdef FEAT_AUTOCHDIR
  	/* Prevent chdir() call in win_enter_ext(), through do_autochdir(). */
  	save_acd = p_acd;
  	p_acd = FALSE;
! #endif
  
  	(void)win_split_ins(0, WSP_TOP, aucmd_win, 0);
  	(void)win_comp_pos();   /* recompute window positions */
  	p_ea = save_ea;
! #ifdef FEAT_AUTOCHDIR
  	p_acd = save_acd;
  #endif
+ 	unblock_autocmds();
  	curwin = aucmd_win;
      }
      curbuf = buf;
***************
*** 9064,9077 ****
  aucmd_restbuf(
      aco_save_T	*aco)		/* structure holding saved values */
  {
- #ifdef FEAT_WINDOWS
      int dummy;
- #endif
  
      if (aco->use_aucmd_win)
      {
  	--curbuf->b_nwindows;
- #ifdef FEAT_WINDOWS
  	/* Find "aucmd_win", it can't be closed, but it may be in another tab
  	 * page. Do not trigger autocommands here. */
  	block_autocmds();
--- 9052,9062 ----
***************
*** 9112,9123 ****
  	else
  	    /* Hmm, original window disappeared.  Just use the first one. */
  	    curwin = firstwin;
! # ifdef FEAT_EVAL
  	vars_clear(&aucmd_win->w_vars->dv_hashtab);  /* free all w: variables */
  	hash_init(&aucmd_win->w_vars->dv_hashtab);   /* re-use the hashtab */
- # endif
- #else
- 	curwin = aco->save_curwin;
  #endif
  	curbuf = curwin->w_buffer;
  
--- 9097,9105 ----
  	else
  	    /* Hmm, original window disappeared.  Just use the first one. */
  	    curwin = firstwin;
! #ifdef FEAT_EVAL
  	vars_clear(&aucmd_win->w_vars->dv_hashtab);  /* free all w: variables */
  	hash_init(&aucmd_win->w_vars->dv_hashtab);   /* re-use the hashtab */
  #endif
  	curbuf = curwin->w_buffer;
  
***************
*** 9143,9151 ****
      else
      {
  	/* restore curwin */
- #ifdef FEAT_WINDOWS
  	if (win_valid(aco->save_curwin))
- #endif
  	{
  	    /* Restore the buffer which was previously edited by curwin, if
  	     * it was changed, we are still the same window and the buffer is
--- 9125,9131 ----
*** ../vim-8.0.1117/src/fold.c	2017-04-23 16:48:17.053458172 +0200
--- src/fold.c	2017-09-16 19:50:08.537678271 +0200
***************
*** 95,101 ****
  
  /* Exported folding functions. {{{1 */
  /* copyFoldingState() {{{2 */
! #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * Copy that folding state from window "wp_from" to window "wp_to".
   */
--- 95,101 ----
  
  /* Exported folding functions. {{{1 */
  /* copyFoldingState() {{{2 */
! 
  /*
   * Copy that folding state from window "wp_from" to window "wp_to".
   */
***************
*** 106,112 ****
      wp_to->w_foldinvalid = wp_from->w_foldinvalid;
      cloneFoldGrowArray(&wp_from->w_folds, &wp_to->w_folds);
  }
- #endif
  
  /* hasAnyFolding() {{{2 */
  /*
--- 106,111 ----
*** ../vim-8.0.1117/src/getchar.c	2017-09-14 20:37:49.959213776 +0200
--- src/getchar.c	2017-09-16 19:50:19.485614155 +0200
***************
*** 2290,2299 ****
  				msg_row = Rows - 1;
  				msg_clr_eos();		/* clear ruler */
  			    }
- #ifdef FEAT_WINDOWS
  			    status_redraw_all();
  			    redraw_statuslines();
- #endif
  			    showmode();
  			    setcursor();
  			    continue;
--- 2290,2297 ----
*** ../vim-8.0.1117/src/gui.c	2017-09-14 20:37:49.959213776 +0200
--- src/gui.c	2017-09-16 19:52:19.212912940 +0200
***************
*** 1642,1650 ****
  
      min_width = base_width + MIN_COLUMNS * gui.char_width;
      min_height = base_height + MIN_LINES * gui.char_height;
- #ifdef FEAT_WINDOWS
      min_height += tabline_height() * gui.char_height;
- #endif
  
  #ifdef FEAT_GUI_GTK
      if (un_maximize)
--- 1642,1648 ----
***************
*** 1828,1834 ****
  			gui.scroll_region_bot = arg1;
  		    }
  		    break;
- #ifdef FEAT_WINDOWS
  		case 'V':	/* Set vertical scroll region */
  		    if (arg1 < arg2)
  		    {
--- 1826,1831 ----
***************
*** 1841,1847 ****
  			gui.scroll_region_right = arg1;
  		    }
  		    break;
- #endif
  		case 'd':	/* Delete line */
  		    gui_delete_lines(gui.row, 1);
  		    break;
--- 1838,1843 ----
***************
*** 3154,3169 ****
       * Visual selection.
       */
      if ((State == NORMAL || State == NORMAL_BUSY || (State & INSERT))
! 	    && Y_2_ROW(y) >= topframe->fr_height
! # ifdef FEAT_WINDOWS
! 						+ firstwin->w_winrow
! # endif
  	    && button != MOUSE_DRAG
  # ifdef FEAT_MOUSESHAPE
  	    && !drag_status_line
- #  ifdef FEAT_WINDOWS
  	    && !drag_sep_line
- #  endif
  # endif
  	    )
  	checkfor = MOUSE_NONE;
--- 3150,3160 ----
       * Visual selection.
       */
      if ((State == NORMAL || State == NORMAL_BUSY || (State & INSERT))
! 	    && Y_2_ROW(y) >= topframe->fr_height + firstwin->w_winrow
  	    && button != MOUSE_DRAG
  # ifdef FEAT_MOUSESHAPE
  	    && !drag_status_line
  	    && !drag_sep_line
  # endif
  	    )
  	checkfor = MOUSE_NONE;
***************
*** 3439,3445 ****
  	    case GO_RIGHT:
  		gui.which_scrollbars[SBAR_RIGHT] = TRUE;
  		break;
- #ifdef FEAT_WINDOWS
  	    case GO_VLEFT:
  		if (win_hasvertsplit())
  		    gui.which_scrollbars[SBAR_LEFT] = TRUE;
--- 3430,3435 ----
***************
*** 3448,3454 ****
  		if (win_hasvertsplit())
  		    gui.which_scrollbars[SBAR_RIGHT] = TRUE;
  		break;
- #endif
  	    case GO_BOT:
  		gui.which_scrollbars[SBAR_BOTTOM] = TRUE;
  		break;
--- 3438,3443 ----
***************
*** 3511,3521 ****
  	     * shown/unshown.  Thus we need two places to remember whether a
  	     * scrollbar is there or not. */
  	    if (gui.which_scrollbars[i] != prev_which_scrollbars[i]
- #ifdef FEAT_WINDOWS
  		    || gui.which_scrollbars[i]
! 					!= curtab->tp_prev_which_scrollbars[i]
! #endif
! 		    )
  	    {
  		if (i == SBAR_BOTTOM)
  		    gui_mch_enable_scrollbar(&gui.bottom_sbar,
--- 3500,3507 ----
  	     * shown/unshown.  Thus we need two places to remember whether a
  	     * scrollbar is there or not. */
  	    if (gui.which_scrollbars[i] != prev_which_scrollbars[i]
  		    || gui.which_scrollbars[i]
! 					!= curtab->tp_prev_which_scrollbars[i])
  	    {
  		if (i == SBAR_BOTTOM)
  		    gui_mch_enable_scrollbar(&gui.bottom_sbar,
***************
*** 3537,3545 ****
  			fix_size = TRUE;
  		}
  	    }
- #ifdef FEAT_WINDOWS
  	    curtab->tp_prev_which_scrollbars[i] = gui.which_scrollbars[i];
- #endif
  	    prev_which_scrollbars[i] = gui.which_scrollbars[i];
  	}
  
--- 3523,3529 ----
***************
*** 3615,3626 ****
  		Columns = prev_Columns;
  #endif
  	}
- #ifdef FEAT_WINDOWS
  	/* When the console tabline appears or disappears the window positions
  	 * change. */
  	if (firstwin->w_winrow != tabline_height())
  	    shell_new_rows();	/* recompute window positions and heights */
- #endif
      }
  }
  
--- 3599,3608 ----
***************
*** 3830,3836 ****
   * Scrollbar stuff:
   */
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * Remove all scrollbars.  Used before switching to another tab page.
   */
--- 3812,3817 ----
***************
*** 3854,3860 ****
  	curtab->tp_prev_which_scrollbars[i] = -1;
      }
  }
- #endif
  
      void
  gui_create_scrollbar(scrollbar_T *sb, int type, win_T *wp)
--- 3835,3840 ----
***************
*** 3872,3880 ****
      sb->max = 1;
      sb->top = 0;
      sb->height = 0;
- #ifdef FEAT_WINDOWS
      sb->width = 0;
- #endif
      sb->status_height = 0;
      gui_mch_create_scrollbar(sb, (wp == NULL) ? SBAR_HORIZ : SBAR_VERT);
  }
--- 3852,3858 ----
***************
*** 3917,3925 ****
      void
  gui_drag_scrollbar(scrollbar_T *sb, long value, int still_dragging)
  {
- #ifdef FEAT_WINDOWS
      win_T	*wp;
- #endif
      int		sb_num;
  #ifdef USE_ON_FLY_SCROLL
      colnr_T	old_leftcol = curwin->w_leftcol;
--- 3895,3901 ----
***************
*** 4011,4025 ****
      if (sb->wp != NULL)		/* vertical scrollbar */
      {
  	sb_num = 0;
- #ifdef FEAT_WINDOWS
  	for (wp = firstwin; wp != sb->wp && wp != NULL; wp = wp->w_next)
  	    sb_num++;
  	if (wp == NULL)
  	    return;
- #else
- 	if (sb->wp != curwin)
- 	    return;
- #endif
  
  #ifdef USE_ON_FLY_SCROLL
  	current_scrollbar = sb_num;
--- 3987,3996 ----
***************
*** 4128,4134 ****
   * Scrollbar stuff:
   */
  
- #if defined(FEAT_AUTOCMD) || defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * Called when something in the window layout has changed.
   */
--- 4099,4104 ----
***************
*** 4143,4149 ****
      }
      need_mouse_correct = TRUE;
  }
- #endif
  
      void
  gui_update_scrollbars(
--- 4113,4118 ----
***************
*** 4154,4162 ****
      long	val, size, max;		/* need 32 bits here */
      int		which_sb;
      int		h, y;
- #ifdef FEAT_WINDOWS
      static win_T *prev_curwin = NULL;
- #endif
  
      /* Update the horizontal scrollbar */
      gui_update_horiz_scrollbar(force);
--- 4123,4129 ----
***************
*** 4249,4270 ****
  	    continue;
  	}
  	if (force || sb->height != wp->w_height
- #ifdef FEAT_WINDOWS
  	    || sb->top != wp->w_winrow
  	    || sb->status_height != wp->w_status_height
  	    || sb->width != wp->w_width
! 	    || prev_curwin != curwin
! #endif
! 	    )
  	{
  	    /* Height, width or position of scrollbar has changed.  For
  	     * vertical split: curwin changed. */
  	    sb->height = wp->w_height;
- #ifdef FEAT_WINDOWS
  	    sb->top = wp->w_winrow;
  	    sb->status_height = wp->w_status_height;
  	    sb->width = wp->w_width;
- #endif
  
  	    /* Calculate height and position in pixels */
  	    h = (sb->height + sb->status_height) * gui.char_height;
--- 4216,4232 ----
  	    continue;
  	}
  	if (force || sb->height != wp->w_height
  	    || sb->top != wp->w_winrow
  	    || sb->status_height != wp->w_status_height
  	    || sb->width != wp->w_width
! 	    || prev_curwin != curwin)
  	{
  	    /* Height, width or position of scrollbar has changed.  For
  	     * vertical split: curwin changed. */
  	    sb->height = wp->w_height;
  	    sb->top = wp->w_winrow;
  	    sb->status_height = wp->w_status_height;
  	    sb->width = wp->w_width;
  
  	    /* Calculate height and position in pixels */
  	    h = (sb->height + sb->status_height) * gui.char_height;
***************
*** 4290,4298 ****
  		y += gui.tabline_height;
  #endif
  
- #ifdef FEAT_WINDOWS
  	    if (wp->w_winrow == 0)
- #endif
  	    {
  		/* Height of top scrollbar includes width of top border */
  		h += gui.border_offset;
--- 4252,4258 ----
***************
*** 4345,4353 ****
  					    val, size, max);
  	}
      }
- #ifdef FEAT_WINDOWS
      prev_curwin = curwin;
- #endif
      --hold_gui_events;
  }
  
--- 4305,4311 ----
***************
*** 4362,4368 ****
      int		which,	    /* SBAR_LEFT or SBAR_RIGHT */
      int		enable)	    /* TRUE to enable scrollbar */
  {
- #ifdef FEAT_WINDOWS
      int		midcol = curwin->w_wincol + curwin->w_width / 2;
      int		has_midcol = (wp->w_wincol <= midcol
  				     && wp->w_wincol + wp->w_width >= midcol);
--- 4320,4325 ----
***************
*** 4393,4399 ****
  		enable = FALSE;
  	}
      }
- #endif
      gui_mch_enable_scrollbar(&wp->w_scrollbars[which], enable);
  }
  
--- 4350,4355 ----
***************
*** 4863,4873 ****
  	if (wp == curwin || wp == NULL)
  	    return;	/* still in the same old window, or none at all */
  
- #ifdef FEAT_WINDOWS
  	/* Ignore position in the tab pages line. */
  	if (Y_2_ROW(y) < tabline_height())
  	    return;
- #endif
  
  	/*
  	 * format a mouse click on status line input
--- 4819,4827 ----
***************
*** 4886,4896 ****
  	st[2] = KE_FILLER;
  	st[3] = (char_u)MOUSE_LEFT;
  	fill_mouse_coord(st + 4,
- #ifdef FEAT_WINDOWS
  		wp->w_wincol == 0 ? -1 : wp->w_wincol + MOUSE_COLOFF,
- #else
- 		-1,
- #endif
  		wp->w_height + W_WINROW(wp));
  
  	add_to_input_buf(st, 8);
--- 4840,4846 ----
***************
*** 4922,4932 ****
      /* Don't move the mouse when it's left or right of the Vim window */
      if (x < 0 || x > Columns * gui.char_width)
  	return;
!     if (y >= 0
! # ifdef FEAT_WINDOWS
! 	    && Y_2_ROW(y) >= tabline_height()
! # endif
!        )
  	wp = xy2win(x, y);
      if (wp != curwin && wp != NULL)	/* If in other than current window */
      {
--- 4872,4878 ----
      /* Don't move the mouse when it's left or right of the Vim window */
      if (x < 0 || x > Columns * gui.char_width)
  	return;
!     if (y >= 0 && Y_2_ROW(y) >= tabline_height())
  	wp = xy2win(x, y);
      if (wp != curwin && wp != NULL)	/* If in other than current window */
      {
***************
*** 4943,4949 ****
      static win_T *
  xy2win(int x UNUSED, int y UNUSED)
  {
- #ifdef FEAT_WINDOWS
      int		row;
      int		col;
      win_T	*wp;
--- 4889,4894 ----
***************
*** 4955,4961 ****
      wp = mouse_find_win(&row, &col);
      if (wp == NULL)
  	return NULL;
! # ifdef FEAT_MOUSESHAPE
      if (State == HITRETURN || State == ASKMORE)
      {
  	if (Y_2_ROW(y) >= msg_row)
--- 4900,4906 ----
      wp = mouse_find_win(&row, &col);
      if (wp == NULL)
  	return NULL;
! #ifdef FEAT_MOUSESHAPE
      if (State == HITRETURN || State == ASKMORE)
      {
  	if (Y_2_ROW(y) >= msg_row)
***************
*** 4973,4983 ****
  	update_mouseshape(SHAPE_IDX_STATUS);
      else
  	update_mouseshape(-2);
- # endif
-     return wp;
- #else
-     return firstwin;
  #endif
  }
  
  /*
--- 4918,4925 ----
  	update_mouseshape(SHAPE_IDX_STATUS);
      else
  	update_mouseshape(-2);
  #endif
+     return wp;
  }
  
  /*
***************
*** 5412,5418 ****
  	|| defined(FEAT_GUI_MAC) \
  	|| defined(PROTO)
  
- #ifdef FEAT_WINDOWS
  static void gui_wingoto_xy(int x, int y);
  
  /*
--- 5354,5359 ----
***************
*** 5432,5438 ****
  	    win_goto(wp);
      }
  }
- #endif
  
  /*
   * Process file drop.  Mouse cursor position, key modifiers, name of files
--- 5373,5378 ----
***************
*** 5495,5503 ****
      {
  	/* Go to the window under mouse cursor, then shorten given "fnames" by
  	 * current window, because a window can have local current dir. */
- # ifdef FEAT_WINDOWS
  	gui_wingoto_xy(x, y);
- # endif
  	shorten_filenames(fnames, count);
  
  	/* If Shift held down, remember the first item. */
--- 5435,5441 ----
*** ../vim-8.0.1117/src/gui_athena.c	2017-02-25 16:01:41.062484813 +0100
--- src/gui_athena.c	2017-09-16 19:52:25.584875620 +0200
***************
*** 1961,1974 ****
  #endif
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
      void
  gui_mch_destroy_scrollbar(scrollbar_T *sb)
  {
      if (sb->id != (Widget)0)
  	XtDestroyWidget(sb->id);
  }
- #endif
  
      void
  gui_mch_set_scrollbar_colors(scrollbar_T *sb)
--- 1961,1972 ----
*** ../vim-8.0.1117/src/gui_beval.c	2017-09-09 18:45:20.418225738 +0200
--- src/gui_beval.c	2017-09-16 19:52:50.864727557 +0200
***************
*** 29,37 ****
      char_u	*bexpr;
      buf_T	*save_curbuf;
      size_t	len;
- # ifdef FEAT_WINDOWS
      win_T	*cw;
- # endif
  #endif
      static int	recursive = FALSE;
  
--- 29,35 ----
***************
*** 53,63 ****
  						    : wp->w_buffer->b_p_bexpr;
  	if (*bexpr != NUL)
  	{
- # ifdef FEAT_WINDOWS
  	    /* Convert window pointer to number. */
  	    for (cw = firstwin; cw != wp; cw = cw->w_next)
  		++winnr;
- # endif
  
  	    set_vim_var_nr(VV_BEVAL_BUFNR, (long)wp->w_buffer->b_fnum);
  	    set_vim_var_nr(VV_BEVAL_WINNR, winnr);
--- 51,59 ----
***************
*** 341,351 ****
      *textp = NULL;
      row = Y_2_ROW(beval->y);
      col = X_2_COL(beval->x);
- #ifdef FEAT_WINDOWS
      wp = mouse_find_win(&row, &col);
- #else
-     wp = firstwin;
- #endif
      if (wp != NULL && row < wp->w_height && col < W_WIDTH(wp))
      {
  	/* Found a window and the cursor is in the text.  Now find the line
--- 337,343 ----
*** ../vim-8.0.1117/src/gui_gtk.c	2017-06-13 14:33:58.033066683 +0200
--- src/gui_gtk.c	2017-09-16 19:53:03.344654463 +0200
***************
*** 1160,1166 ****
      }
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
      void
  gui_mch_destroy_scrollbar(scrollbar_T *sb)
  {
--- 1160,1165 ----
***************
*** 1171,1177 ****
      }
      gui_mch_update();
  }
- #endif
  
  #if defined(FEAT_BROWSE) || defined(PROTO)
  /*
--- 1170,1175 ----
*** ../vim-8.0.1117/src/gui_motif.c	2017-02-25 16:01:41.062484813 +0100
--- src/gui_motif.c	2017-09-16 19:53:15.316584342 +0200
***************
*** 1879,1892 ****
      }
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
      void
  gui_mch_destroy_scrollbar(scrollbar_T *sb)
  {
      if (sb->id != (Widget)0)
  	XtDestroyWidget(sb->id);
  }
- #endif
  
      void
  gui_mch_set_scrollbar_colors(scrollbar_T *sb)
--- 1879,1890 ----
*** ../vim-8.0.1117/src/gui_w32.c	2017-09-02 18:33:52.449554495 +0200
--- src/gui_w32.c	2017-09-16 19:53:56.380343828 +0200
***************
*** 2947,2959 ****
      return MyWindowProc(hwnd, WM_ACTIVATEAPP, fActivate, (DWORD)dwThreadId);
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
      void
  gui_mch_destroy_scrollbar(scrollbar_T *sb)
  {
      DestroyWindow(sb->id);
  }
- #endif
  
  /*
   * Get current mouse coordinates in text window.
--- 2947,2957 ----
***************
*** 3785,3796 ****
      HWND hwnd UNUSED,
      HDROP hDrop)
  {
! #ifdef FEAT_WINDOWS
! # define BUFPATHLEN _MAX_PATH
! # define DRAGQVAL 0xFFFFFFFF
! # ifdef FEAT_MBYTE
      WCHAR   wszFile[BUFPATHLEN];
! # endif
      char    szFile[BUFPATHLEN];
      UINT    cFiles = DragQueryFile(hDrop, DRAGQVAL, NULL, 0);
      UINT    i;
--- 3783,3793 ----
      HWND hwnd UNUSED,
      HDROP hDrop)
  {
! #define BUFPATHLEN _MAX_PATH
! #define DRAGQVAL 0xFFFFFFFF
! #ifdef FEAT_MBYTE
      WCHAR   wszFile[BUFPATHLEN];
! #endif
      char    szFile[BUFPATHLEN];
      UINT    cFiles = DragQueryFile(hDrop, DRAGQVAL, NULL, 0);
      UINT    i;
***************
*** 3811,3821 ****
      if (fnames != NULL)
  	for (i = 0; i < cFiles; ++i)
  	{
! # ifdef FEAT_MBYTE
  	    if (DragQueryFileW(hDrop, i, wszFile, BUFPATHLEN) > 0)
  		fnames[i] = utf16_to_enc(wszFile, NULL);
  	    else
! # endif
  	    {
  		DragQueryFile(hDrop, i, szFile, BUFPATHLEN);
  		fnames[i] = vim_strsave((char_u *)szFile);
--- 3808,3818 ----
      if (fnames != NULL)
  	for (i = 0; i < cFiles; ++i)
  	{
! #ifdef FEAT_MBYTE
  	    if (DragQueryFileW(hDrop, i, wszFile, BUFPATHLEN) > 0)
  		fnames[i] = utf16_to_enc(wszFile, NULL);
  	    else
! #endif
  	    {
  		DragQueryFile(hDrop, i, szFile, BUFPATHLEN);
  		fnames[i] = vim_strsave((char_u *)szFile);
***************
*** 3837,3843 ****
  
  	s_need_activate = TRUE;
      }
- #endif
  }
  
      static int
--- 3834,3839 ----
***************
*** 5463,5471 ****
  #endif
      s_hdc = GetDC(s_textArea);
  
- #ifdef FEAT_WINDOWS
      DragAcceptFiles(s_hwnd, TRUE);
- #endif
  
      /* Do we need to bother with this? */
      /* m_fMouseAvail = GetSystemMetrics(SM_MOUSEPRESENT); */
--- 5459,5465 ----
***************
*** 5781,5787 ****
  		State &= ~LANGMAP;
  		if (State & INSERT)
  		{
! #if defined(FEAT_WINDOWS) && defined(FEAT_KEYMAP)
  		    /* Unshown 'keymap' in status lines */
  		    if (curbuf->b_p_iminsert == B_IMODE_LMAP)
  		    {
--- 5775,5781 ----
  		State &= ~LANGMAP;
  		if (State & INSERT)
  		{
! #if defined(FEAT_KEYMAP)
  		    /* Unshown 'keymap' in status lines */
  		    if (curbuf->b_p_iminsert == B_IMODE_LMAP)
  		    {
*** ../vim-8.0.1117/src/if_cscope.c	2017-03-16 17:23:26.823815869 +0100
--- src/if_cscope.c	2017-09-16 19:56:20.263501058 +0200
***************
*** 217,223 ****
  	return;
      }
  
- #ifdef FEAT_WINDOWS
      if (make_split)
      {
  	if (!cmdp->cansplit)
--- 217,222 ----
***************
*** 229,242 ****
  	postponed_split_flags = cmdmod.split;
  	postponed_split_tab = cmdmod.tab;
      }
- #endif
  
      cmdp->func(eap);
  
- #ifdef FEAT_WINDOWS
      postponed_split_flags = 0;
      postponed_split_tab = 0;
- #endif
  }
  
  /*
--- 228,238 ----
***************
*** 326,332 ****
      if (!ret)
      {
  	(void)EMSG(_("E257: cstag: tag not found"));
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  	g_do_tagpreview = 0;
  #endif
      }
--- 322,328 ----
      if (!ret)
      {
  	(void)EMSG(_("E257: cstag: tag not found"));
! #if defined(FEAT_QUICKFIX)
  	g_do_tagpreview = 0;
  #endif
      }
***************
*** 1244,1250 ****
  	    if (qf_init(wp, tmp, (char_u *)"%f%*\\t%l%*\\t%m",
  					  *qfpos == '-', cmdline, NULL) > 0)
  	    {
- # ifdef FEAT_WINDOWS
  		if (postponed_split != 0)
  		{
  		    (void)win_split(postponed_split > 0 ? postponed_split : 0,
--- 1240,1245 ----
***************
*** 1252,1258 ****
  		    RESET_BINDING(curwin);
  		    postponed_split = 0;
  		}
- # endif
  
  # ifdef FEAT_AUTOCMD
  		apply_autocmds(EVENT_QUICKFIXCMDPOST, (char_u *)"cscope",
--- 1247,1252 ----
***************
*** 2001,2007 ****
      char	*cstag_msg = _("Cscope tag: %s");
      char	*csfmt_str = "%4d %6s  ";
  
!     assert (num_matches > 0);
  
      if ((tbuf = (char *)alloc((unsigned)strlen(matches[0]) + 1)) == NULL)
  	return;
--- 1995,2001 ----
      char	*cstag_msg = _("Cscope tag: %s");
      char	*csfmt_str = "%4d %6s  ";
  
!     assert(num_matches > 0);
  
      if ((tbuf = (char *)alloc((unsigned)strlen(matches[0]) + 1)) == NULL)
  	return;
*** ../vim-8.0.1117/src/if_lua.c	2017-01-29 22:48:26.397622063 +0100
--- src/if_lua.c	2017-09-16 19:56:35.671410806 +0200
***************
*** 1178,1187 ****
  	lua_pushinteger(L, w->w_cursor.lnum);
      else if (strncmp(s, "col", 3) == 0)
  	lua_pushinteger(L, w->w_cursor.col + 1);
- #ifdef FEAT_WINDOWS
      else if (strncmp(s, "width", 5) == 0)
  	lua_pushinteger(L, W_WIDTH(w));
- #endif
      else if (strncmp(s, "height", 6) == 0)
  	lua_pushinteger(L, w->w_height);
      /* methods */
--- 1178,1185 ----
***************
*** 1221,1227 ****
  	w->w_cursor.col = v - 1;
  	update_screen(VALID);
      }
- #ifdef FEAT_WINDOWS
      else if (strncmp(s, "width", 5) == 0)
      {
  	win_T *win = curwin;
--- 1219,1224 ----
***************
*** 1232,1238 ****
  	win_setwidth(v);
  	curwin = win;
      }
- #endif
      else if (strncmp(s, "height", 6) == 0)
      {
  	win_T *win = curwin;
--- 1229,1234 ----
*** ../vim-8.0.1117/src/if_mzsch.c	2016-08-29 22:42:20.000000000 +0200
--- src/if_mzsch.c	2017-09-16 19:57:07.075226855 +0200
***************
*** 145,154 ****
  static Scheme_Object *get_window_buffer(void *, int, Scheme_Object **);
  static Scheme_Object *get_window_height(void *, int, Scheme_Object **);
  static Scheme_Object *set_window_height(void *, int, Scheme_Object **);
- #ifdef FEAT_WINDOWS
  static Scheme_Object *get_window_width(void *, int, Scheme_Object **);
  static Scheme_Object *set_window_width(void *, int, Scheme_Object **);
- #endif
  static Scheme_Object *get_cursor(void *, int, Scheme_Object **);
  static Scheme_Object *set_cursor(void *, int, Scheme_Object **);
  static Scheme_Object *get_window_list(void *, int, Scheme_Object **);
--- 145,152 ----
***************
*** 1913,1923 ****
  get_window_count(void *data UNUSED, int argc UNUSED, Scheme_Object **argv UNUSED)
  {
      int	    n = 0;
- #ifdef FEAT_WINDOWS
      win_T   *w;
  
      FOR_ALL_WINDOWS(w)
- #endif
  	++n;
      return scheme_make_integer(n);
  }
--- 1911,1919 ----
***************
*** 1934,1942 ****
      buf = get_buffer_arg(prim->name, 0, argc, argv);
      list = scheme_null;
  
- #ifdef FEAT_WINDOWS
      for ( ; w != NULL; w = w->w_next)
- #endif
  	if (w->w_buffer == buf->buf)
  	{
  	    list = scheme_make_pair(window_new(w), list);
--- 1930,1936 ----
***************
*** 1988,2000 ****
  get_window_num(void *data UNUSED, int argc UNUSED, Scheme_Object **argv UNUSED)
  {
      int		nr = 1;
- #ifdef FEAT_WINDOWS
      Vim_Prim	*prim = (Vim_Prim *)data;
      win_T	*win = get_window_arg(prim->name, 0, argc, argv)->win;
      win_T	*wp;
  
      for (wp = firstwin; wp != win; wp = wp->w_next)
- #endif
  	++nr;
  
      return scheme_make_integer(nr);
--- 1982,1992 ----
***************
*** 2012,2020 ****
      if (fnum < 1)
  	scheme_signal_error(_("window index is out of range"));
  
- #ifdef FEAT_WINDOWS
      for ( ; win != NULL; win = win->w_next, --fnum)
- #endif
  	if (fnum == 1)	    /* to be 1-based */
  	    return window_new(win);
  
--- 2004,2010 ----
***************
*** 2066,2072 ****
      return scheme_void;
  }
  
- #ifdef FEAT_WINDOWS
  /* (get-win-width [window]) */
      static Scheme_Object *
  get_window_width(void *data, int argc, Scheme_Object **argv)
--- 2056,2061 ----
***************
*** 2101,2107 ****
      raise_if_error();
      return scheme_void;
  }
- #endif
  
  /* (get-cursor [window]) -> (line . col) */
      static Scheme_Object *
--- 2090,2095 ----
***************
*** 3744,3753 ****
      {get_window_buffer, "get-win-buffer", 0, 1},
      {get_window_height, "get-win-height", 0, 1},
      {set_window_height, "set-win-height", 1, 2},
- #ifdef FEAT_WINDOWS
      {get_window_width, "get-win-width", 0, 1},
      {set_window_width, "set-win-width", 1, 2},
- #endif
      {get_cursor, "get-cursor", 0, 1},
      {set_cursor, "set-cursor", 1, 2},
      {get_window_list, "get-win-list", 0, 1},
--- 3732,3739 ----
*** ../vim-8.0.1117/src/if_python.c	2017-07-07 14:50:40.915158143 +0200
--- src/if_python.c	2017-09-16 19:57:22.059139086 +0200
***************
*** 1438,1444 ****
      }
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
      void
  python_window_free(win_T *win)
  {
--- 1438,1443 ----
***************
*** 1460,1466 ****
  	TAB_PYTHON_REF(tab) = NULL;
      }
  }
- #endif
  
      static int
  PythonMod_Init(void)
--- 1459,1464 ----
*** ../vim-8.0.1117/src/if_python3.c	2017-07-07 14:50:40.915158143 +0200
--- src/if_python3.c	2017-09-16 19:57:34.155068229 +0200
***************
*** 1571,1577 ****
      }
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
      void
  python3_window_free(win_T *win)
  {
--- 1571,1576 ----
***************
*** 1593,1599 ****
  	TAB_PYTHON_REF(tab) = NULL;
      }
  }
- #endif
  
      static PyObject *
  Py3Init_vim(void)
--- 1592,1597 ----
*** ../vim-8.0.1117/src/if_ruby.c	2017-09-03 15:17:43.682972182 +0200
--- src/if_ruby.c	2017-09-16 19:58:00.830911972 +0200
***************
*** 1424,1439 ****
  
  static VALUE window_s_count(void)
  {
- #ifdef FEAT_WINDOWS
      win_T	*w;
      int n = 0;
  
      FOR_ALL_WINDOWS(w)
  	n++;
      return INT2NUM(n);
- #else
-     return INT2NUM(1);
- #endif
  }
  
  static VALUE window_s_aref(VALUE self UNUSED, VALUE num)
--- 1424,1435 ----
***************
*** 1441,1451 ****
      win_T *w;
      int n = NUM2INT(num);
  
- #ifndef FEAT_WINDOWS
-     w = curwin;
- #else
      for (w = firstwin; w != NULL; w = w->w_next, --n)
- #endif
  	if (n == 0)
  	    return window_new(w);
      return Qnil;
--- 1437,1443 ----
***************
*** 1483,1496 ****
  
  static VALUE window_set_width(VALUE self UNUSED, VALUE width)
  {
- #ifdef FEAT_WINDOWS
      win_T *win = get_win(self);
      win_T *savewin = curwin;
  
      curwin = win;
      win_setwidth(NUM2INT(width));
      curwin = savewin;
- #endif
      return width;
  }
  
--- 1475,1486 ----
*** ../vim-8.0.1117/src/if_tcl.c	2017-01-29 23:26:12.926595799 +0100
--- src/if_tcl.c	2017-09-16 19:58:18.458808712 +0200
***************
*** 2083,2089 ****
      }
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
      void
  tcl_window_free(win_T *win)
  {
--- 2083,2088 ----
***************
*** 2102,2107 ****
  	win->w_tcl_ref = NULL;
      }
  }
- #endif
  
  /* The End */
--- 2101,2105 ----
*** ../vim-8.0.1117/src/main.c	2017-09-14 20:37:49.963213752 +0200
--- src/main.c	2017-09-16 19:59:56.682233332 +0200
***************
*** 47,55 ****
  static void check_tty(mparm_T *parmp);
  static void read_stdin(void);
  static void create_windows(mparm_T *parmp);
- # ifdef FEAT_WINDOWS
  static void edit_buffers(mparm_T *parmp, char_u *cwd);
- # endif
  static void exe_pre_commands(mparm_T *parmp);
  static void exe_commands(mparm_T *parmp);
  static void source_startup_scripts(mparm_T *parmp);
--- 47,53 ----
***************
*** 141,149 ****
  #ifdef FEAT_EVAL
      params.use_debug_break_level = -1;
  #endif
- #ifdef FEAT_WINDOWS
      params.window_count = -1;
- #endif
  
  #ifdef FEAT_RUBY
      {
--- 139,145 ----
***************
*** 754,766 ****
      }
  #endif
  
- #ifdef FEAT_WINDOWS
      /*
       * If opened more than one window, start editing files in the other
       * windows.
       */
      edit_buffers(&params, start_dir);
- #endif
      vim_free(start_dir);
  
  #ifdef FEAT_DIFF
--- 750,760 ----
***************
*** 867,873 ****
      mch_set_winsize_now();	    /* Allow winsize changes from now on */
  #endif
  
! #if defined(FEAT_GUI) && defined(FEAT_WINDOWS)
      /* When tab pages were created, may need to update the tab pages line and
       * scrollbars.  This is skipped while creating them. */
      if (first_tabpage->tp_next != NULL)
--- 861,867 ----
      mch_set_winsize_now();	    /* Allow winsize changes from now on */
  #endif
  
! #if defined(FEAT_GUI)
      /* When tab pages were created, may need to update the tab pages line and
       * scrollbars.  This is skipped while creating them. */
      if (first_tabpage->tp_next != NULL)
***************
*** 1257,1265 ****
  		update_screen(0);
  	    else if (redraw_cmdline || clear_cmdline)
  		showmode();
- #ifdef FEAT_WINDOWS
  	    redraw_statuslines();
- #endif
  #ifdef FEAT_TITLE
  	    if (need_maketitle)
  		maketitle();
--- 1251,1257 ----
***************
*** 1435,1441 ****
      if (get_vim_var_nr(VV_DYING) <= 1)
      {
  	/* Trigger BufWinLeave for all windows, but only once per buffer. */
- # if defined FEAT_WINDOWS
  	for (tp = first_tabpage; tp != NULL; tp = next_tp)
  	{
  	    next_tp = tp->tp_next;
--- 1427,1432 ----
***************
*** 1456,1465 ****
  		}
  	    }
  	}
- # else
- 	apply_autocmds(EVENT_BUFWINLEAVE, curbuf, curbuf->b_fname,
- 							       FALSE, curbuf);
- # endif
  
  	/* Trigger BufUnload for buffers that are loaded */
  	FOR_ALL_BUFFERS(buf)
--- 1447,1452 ----
***************
*** 2102,2131 ****
  		    break;
  		}
  #endif
- #ifdef FEAT_WINDOWS
  		/* default is 0: open window for each file */
  		parmp->window_count = get_number_arg((char_u *)argv[0],
  								&argv_idx, 0);
  		parmp->window_layout = WIN_TABS;
- #endif
  		break;
  
  	    case 'o':		/* "-o[N]" open N horizontal split windows */
- #ifdef FEAT_WINDOWS
  		/* default is 0: open window for each file */
  		parmp->window_count = get_number_arg((char_u *)argv[0],
  								&argv_idx, 0);
  		parmp->window_layout = WIN_HOR;
- #endif
  		break;
  
  		case 'O':	/* "-O[N]" open N vertical split windows */
- #ifdef FEAT_WINDOWS
  		/* default is 0: open window for each file */
  		parmp->window_count = get_number_arg((char_u *)argv[0],
  								&argv_idx, 0);
  		parmp->window_layout = WIN_VER;
- #endif
  		break;
  
  #ifdef FEAT_QUICKFIX
--- 2089,2112 ----
***************
*** 2640,2646 ****
      static void
  create_windows(mparm_T *parmp UNUSED)
  {
- #ifdef FEAT_WINDOWS
      int		dorewind;
      int		done = 0;
  
--- 2621,2626 ----
***************
*** 2673,2679 ****
      }
      else
  	parmp->window_count = 1;
- #endif
  
      if (recoverymode)			/* do recover */
      {
--- 2653,2658 ----
***************
*** 2697,2703 ****
  	++autocmd_no_enter;
  	++autocmd_no_leave;
  #endif
- #ifdef FEAT_WINDOWS
  	dorewind = TRUE;
  	while (done++ < 1000)
  	{
--- 2676,2681 ----
***************
*** 2721,2727 ****
  		curwin = curwin->w_next;
  	    }
  	    dorewind = FALSE;
- #endif
  	    curbuf = curwin->w_buffer;
  	    if (curbuf->b_ml.ml_mfp == NULL)
  	    {
--- 2699,2704 ----
***************
*** 2762,2768 ****
  		dorewind = TRUE;		/* start again */
  #endif
  	    }
- #ifdef FEAT_WINDOWS
  	    ui_breakcheck();
  	    if (got_int)
  	    {
--- 2739,2744 ----
***************
*** 2770,2783 ****
  		break;
  	    }
  	}
- #endif
- #ifdef FEAT_WINDOWS
  	if (parmp->window_layout == WIN_TABS)
  	    goto_tabpage(1);
  	else
  	    curwin = firstwin;
  	curbuf = curwin->w_buffer;
- #endif
  #ifdef FEAT_AUTOCMD
  	--autocmd_no_enter;
  	--autocmd_no_leave;
--- 2746,2756 ----
***************
*** 2785,2791 ****
      }
  }
  
- #ifdef FEAT_WINDOWS
      /*
       * If opened more than one window, start editing files in the other
       * windows.  make_windows() has already opened the windows.
--- 2758,2763 ----
***************
*** 2893,2899 ****
  
      /* make the first window the current window */
      win = firstwin;
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      /* Avoid making a preview window the current window. */
      while (win->w_p_pvw)
      {
--- 2865,2871 ----
  
      /* make the first window the current window */
      win = firstwin;
! #if defined(FEAT_QUICKFIX)
      /* Avoid making a preview window the current window. */
      while (win->w_p_pvw)
      {
***************
*** 2907,2920 ****
  #endif
      win_enter(win, FALSE);
  
! # ifdef FEAT_AUTOCMD
      --autocmd_no_leave;
! # endif
      TIME_MSG("editing files in windows");
      if (parmp->window_count > 1 && parmp->window_layout != WIN_TABS)
  	win_equal(curwin, FALSE, 'b');	/* adjust heights */
  }
- #endif /* FEAT_WINDOWS */
  
  /*
   * Execute the commands from --cmd arguments "cmds[cnt]".
--- 2879,2891 ----
  #endif
      win_enter(win, FALSE);
  
! #ifdef FEAT_AUTOCMD
      --autocmd_no_leave;
! #endif
      TIME_MSG("editing files in windows");
      if (parmp->window_count > 1 && parmp->window_layout != WIN_TABS)
  	win_equal(curwin, FALSE, 'b');	/* adjust heights */
  }
  
  /*
   * Execute the commands from --cmd arguments "cmds[cnt]".
***************
*** 3367,3377 ****
      main_msg(_("-U <gvimrc>\t\tUse <gvimrc> instead of any .gvimrc"));
  #endif
      main_msg(_("--noplugin\t\tDon't load plugin scripts"));
- #ifdef FEAT_WINDOWS
      main_msg(_("-p[N]\t\tOpen N tab pages (default: one for each file)"));
      main_msg(_("-o[N]\t\tOpen N windows (default: one for each file)"));
      main_msg(_("-O[N]\t\tLike -o but split vertically"));
- #endif
      main_msg(_("+\t\t\tStart at end of file"));
      main_msg(_("+<lnum>\t\tStart at line <lnum>"));
      main_msg(_("--cmd <command>\tExecute <command> before loading any vimrc file"));
--- 3338,3346 ----
***************
*** 3394,3402 ****
      main_msg(_("--remote-silent <files>  Same, don't complain if there is no server"));
      main_msg(_("--remote-wait <files>  As --remote but wait for files to have been edited"));
      main_msg(_("--remote-wait-silent <files>  Same, don't complain if there is no server"));
- # ifdef FEAT_WINDOWS
      main_msg(_("--remote-tab[-wait][-silent] <files>  As --remote but use tab page per file"));
- # endif
      main_msg(_("--remote-send <keys>\tSend <keys> to a Vim server and exit"));
      main_msg(_("--remote-expr <expr>\tEvaluate <expr> in a Vim server and print result"));
      main_msg(_("--serverlist\t\tList available Vim server names and exit"));
--- 3363,3369 ----
*** ../vim-8.0.1117/src/mark.c	2017-08-13 18:11:13.355992144 +0200
--- src/mark.c	2017-09-16 20:00:26.182060520 +0200
***************
*** 1056,1064 ****
      int		fnum = curbuf->b_fnum;
      linenr_T	*lp;
      win_T	*win;
- #ifdef FEAT_WINDOWS
      tabpage_T	*tab;
- #endif
      static pos_T initpos = INIT_POS_T(1, 0, 0);
  
      if (line2 < line1 && amount_after == 0L)	    /* nothing to do */
--- 1056,1062 ----
***************
*** 1340,1346 ****
      curwin->w_jumplistlen = to;
  }
  
- # if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * Copy the jumplist from window "from" to window "to".
   */
--- 1338,1343 ----
***************
*** 1370,1376 ****
      for (i = 0; i < wp->w_jumplistlen; ++i)
  	vim_free(wp->w_jumplist[i].fname);
  }
- # endif
  #endif /* FEAT_JUMPLIST */
  
      void
--- 1367,1372 ----
***************
*** 1895,1901 ****
      buf_T	*buf;
      int		is_mark_set;
      int		i;
- #ifdef FEAT_WINDOWS
      win_T	*win;
      tabpage_T	*tp;
  
--- 1891,1896 ----
***************
*** 1904,1912 ****
       */
      FOR_ALL_TAB_WINDOWS(tp, win)
  	set_last_cursor(win);
- #else
- 	set_last_cursor(curwin);
- #endif
  
      fputs(_("\n# History of marks within files (newest to oldest):\n"), fp_out);
      FOR_ALL_BUFFERS(buf)
--- 1899,1904 ----
*** ../vim-8.0.1117/src/memline.c	2017-03-16 17:23:26.827815840 +0100
--- src/memline.c	2017-09-16 20:00:51.189914022 +0200
***************
*** 2544,2551 ****
      return ml_append_int(curbuf, lnum, line, len, newfile, FALSE);
  }
  
! #if defined(FEAT_SPELL) || (defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)) \
! 	|| defined(PROTO)
  /*
   * Like ml_append() but for an arbitrary buffer.  The buffer must already have
   * a memline.
--- 2544,2550 ----
      return ml_append_int(curbuf, lnum, line, len, newfile, FALSE);
  }
  
! #if defined(FEAT_SPELL) || defined(FEAT_QUICKFIX) || defined(PROTO)
  /*
   * Like ml_append() but for an arbitrary buffer.  The buffer must already have
   * a memline.
***************
*** 3112,3118 ****
  }
  
  /*
!  * Delete line 'lnum' in the current buffer.
   *
   * Check: The caller of this function should probably also call
   * deleted_lines() after this.
--- 3111,3118 ----
  }
  
  /*
!  * Delete line "lnum" in the current buffer.
!  * When "message" is TRUE may give a "No lines in buffer" message.
   *
   * Check: The caller of this function should probably also call
   * deleted_lines() after this.
*** ../vim-8.0.1117/src/misc1.c	2017-09-02 20:30:31.163315043 +0200
--- src/misc1.c	2017-09-16 20:01:38.889634589 +0200
***************
*** 1984,1993 ****
      if (!wp->w_p_wrap)
  	return 1;
  
- #ifdef FEAT_WINDOWS
      if (wp->w_width == 0)
  	return 1;
- #endif
  
  #ifdef FEAT_FOLDING
      /* A folded lines is handled just like an empty line. */
--- 1984,1991 ----
***************
*** 2060,2069 ****
      if (!wp->w_p_wrap)
  	return lines + 1;
  
- #ifdef FEAT_WINDOWS
      if (wp->w_width == 0)
  	return lines + 1;
- #endif
  
      line = s = ml_get_buf(wp->w_buffer, lnum, FALSE);
  
--- 2058,2065 ----
***************
*** 2787,2796 ****
  {
      curbuf->b_changed = TRUE;
      ml_setflags(curbuf);
- #ifdef FEAT_WINDOWS
      check_status(curbuf);
      redraw_tabline = TRUE;
- #endif
  #ifdef FEAT_TITLE
      need_maketitle = TRUE;	    /* set window title later */
  #endif
--- 2783,2790 ----
***************
*** 2995,3003 ****
      long	xtra)
  {
      win_T	*wp;
- #ifdef FEAT_WINDOWS
      tabpage_T	*tp;
- #endif
      int		i;
  #ifdef FEAT_JUMPLIST
      int		cols;
--- 2989,2995 ----
***************
*** 3199,3208 ****
  	ml_setflags(buf);
  	if (ff)
  	    save_file_ff(buf);
- #ifdef FEAT_WINDOWS
  	check_status(buf);
  	redraw_tabline = TRUE;
- #endif
  #ifdef FEAT_TITLE
  	need_maketitle = TRUE;	    /* set window title later */
  #endif
--- 3191,3198 ----
***************
*** 3213,3219 ****
  #endif
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * check_status: called when the status bars for the buffer 'buf'
   *		 need to be updated
--- 3203,3208 ----
***************
*** 3231,3237 ****
  		must_redraw = VALID;
  	}
  }
- #endif
  
  /*
   * If the file is readonly, give a warning message with the first change.
--- 3220,3225 ----
***************
*** 5024,5031 ****
  }
  #endif
  
- #if defined(FEAT_GUI_TABLINE) || defined(FEAT_WINDOWS) \
- 	|| defined(FEAT_EVAL) || defined(PROTO)
  /*
   * Shorten the path of a file from "~/foo/../.bar/fname" to "~/f/../.b/fname"
   * It's done in-place.
--- 5012,5017 ----
***************
*** 5068,5074 ****
  	}
      }
  }
- #endif
  
  /*
   * Return TRUE if the directory of "fname" exists, FALSE otherwise.
--- 5054,5059 ----
*** ../vim-8.0.1117/src/misc2.c	2017-08-30 17:01:31.750483655 +0200
--- src/misc2.c	2017-09-16 20:02:59.653161451 +0200
***************
*** 169,177 ****
  
  	if (finetune
  		&& curwin->w_p_wrap
- # ifdef FEAT_WINDOWS
  		&& curwin->w_width != 0
- # endif
  		&& wcol >= (colnr_T)width)
  	{
  	    csize = linetabsize(line);
--- 169,175 ----
***************
*** 1084,1097 ****
      block_autocmds();
  # endif
  
- # ifdef FEAT_WINDOWS
      /* Close all tabs and windows.  Reset 'equalalways' to avoid redraws. */
      p_ea = FALSE;
      if (first_tabpage->tp_next != NULL)
  	do_cmdline_cmd((char_u *)"tabonly!");
      if (!ONE_WINDOW)
  	do_cmdline_cmd((char_u *)"only!");
- # endif
  
  # if defined(FEAT_SPELL)
      /* Free all spell info. */
--- 1082,1093 ----
***************
*** 1197,1206 ****
      /* Close all script inputs. */
      close_all_scripts();
  
- #if defined(FEAT_WINDOWS)
      /* Destroy all windows.  Must come before freeing buffers. */
      win_free_all();
- #endif
  
      /* Free all buffers.  Reset 'autochdir' to avoid accessing things that
       * were freed already. */
--- 1193,1200 ----
***************
*** 1238,1247 ****
  
      reset_last_sourcing();
  
- #ifdef FEAT_WINDOWS
      free_tabpage(first_tabpage);
      first_tabpage = NULL;
- #endif
  
  # ifdef UNIX
      /* Machine-specific free. */
--- 1232,1239 ----
***************
*** 3176,3186 ****
  	set_string_option_direct((char_u *)"ff", -1, (char_u *)p,
  						     OPT_FREE | opt_flags, 0);
  
- #ifdef FEAT_WINDOWS
      /* This may cause the buffer to become (un)modified. */
      check_status(curbuf);
      redraw_tabline = TRUE;
- #endif
  #ifdef FEAT_TITLE
      need_maketitle = TRUE;	    /* set window title later */
  #endif
--- 3168,3176 ----
***************
*** 3353,3360 ****
  }
  
  #if defined(FEAT_SESSION) || defined(MSWIN) || defined(FEAT_GUI_MAC) \
! 	|| ((defined(FEAT_GUI_GTK)) \
! 			&& ( defined(FEAT_WINDOWS) || defined(FEAT_DND)) ) \
  	|| defined(FEAT_SUN_WORKSHOP) || defined(FEAT_NETBEANS_INTG) \
  	|| defined(PROTO)
  /*
--- 3343,3349 ----
  }
  
  #if defined(FEAT_SESSION) || defined(MSWIN) || defined(FEAT_GUI_MAC) \
! 	|| defined(FEAT_GUI_GTK) \
  	|| defined(FEAT_SUN_WORKSHOP) || defined(FEAT_NETBEANS_INTG) \
  	|| defined(PROTO)
  /*
***************
*** 3728,3737 ****
      }
      if (mouse && drag_status_line)
  	return SHAPE_IDX_SDRAG;
- # ifdef FEAT_WINDOWS
      if (mouse && drag_sep_line)
  	return SHAPE_IDX_VDRAG;
- # endif
  #endif
      if (!mouse && State == SHOWMATCH)
  	return SHAPE_IDX_SM;
--- 3717,3724 ----
*** ../vim-8.0.1117/src/move.c	2017-08-17 20:31:44.001203501 +0200
--- src/move.c	2017-09-16 20:03:31.432975272 +0200
***************
*** 982,992 ****
  	curwin->w_wcol = W_WIDTH(curwin) - 1;
  	curwin->w_wrow = curwin->w_height - 1;
      }
!     else if (curwin->w_p_wrap
! #ifdef FEAT_WINDOWS
! 	    && curwin->w_width != 0
! #endif
! 	    )
      {
  	width = textwidth + curwin_col_off2();
  
--- 982,988 ----
  	curwin->w_wcol = W_WIDTH(curwin) - 1;
  	curwin->w_wrow = curwin->w_height - 1;
      }
!     else if (curwin->w_p_wrap && curwin->w_width != 0)
      {
  	width = textwidth + curwin_col_off2();
  
***************
*** 1089,1098 ****
  	    && curwin->w_height != 0
  	    && curwin->w_cursor.lnum == curwin->w_topline
  	    && width > 0
! #ifdef FEAT_WINDOWS
! 	    && curwin->w_width != 0
! #endif
! 	    )
      {
  	/* Cursor past end of screen.  Happens with a single line that does
  	 * not fit on screen.  Find a skipcol to show the text around the
--- 1085,1091 ----
  	    && curwin->w_height != 0
  	    && curwin->w_cursor.lnum == curwin->w_topline
  	    && width > 0
! 	    && curwin->w_width != 0)
      {
  	/* Cursor past end of screen.  Happens with a single line that does
  	 * not fit on screen.  Find a skipcol to show the text around the
***************
*** 1251,1261 ****
       * and move the cursor onto the displayed part of the window.
       */
      wrow = curwin->w_wrow;
!     if (curwin->w_p_wrap
! #ifdef FEAT_WINDOWS
! 		&& curwin->w_width != 0
! #endif
! 	    )
      {
  	validate_virtcol();
  	validate_cheight();
--- 1244,1250 ----
       * and move the cursor onto the displayed part of the window.
       */
      wrow = curwin->w_wrow;
!     if (curwin->w_p_wrap && curwin->w_width != 0)
      {
  	validate_virtcol();
  	validate_cheight();
***************
*** 1460,1470 ****
  #else
      end_row += plines(curwin->w_topline - 1);
  #endif
!     if (curwin->w_p_wrap
! #ifdef FEAT_WINDOWS
! 		&& curwin->w_width != 0
! #endif
! 	    )
      {
  	validate_cheight();
  	validate_virtcol();
--- 1449,1455 ----
  #else
      end_row += plines(curwin->w_topline - 1);
  #endif
!     if (curwin->w_p_wrap && curwin->w_width != 0)
      {
  	validate_cheight();
  	validate_virtcol();
***************
*** 1524,1534 ****
  #else
      start_row = curwin->w_wrow - plines(curwin->w_topline);
  #endif
!     if (curwin->w_p_wrap
! #ifdef FEAT_WINDOWS
! 		&& curwin->w_width != 0
! #endif
! 	    )
      {
  	validate_virtcol();
  	start_row -= curwin->w_virtcol / W_WIDTH(curwin);
--- 1509,1515 ----
  #else
      start_row = curwin->w_wrow - plines(curwin->w_topline);
  #endif
!     if (curwin->w_p_wrap && curwin->w_width != 0)
      {
  	validate_virtcol();
  	start_row -= curwin->w_virtcol / W_WIDTH(curwin);
***************
*** 2855,2863 ****
  	    /* Only scroll when 'scrollbind' hasn't done this. */
  	    if (!curwin->w_p_scb)
  		update_topline();
- # ifdef FEAT_WINDOWS
  	    curwin->w_redr_status = TRUE;
- # endif
  	}
      }
  
--- 2836,2842 ----
*** ../vim-8.0.1117/src/netbeans.c	2017-07-11 22:34:47.527932090 +0200
--- src/netbeans.c	2017-09-16 20:03:42.748908976 +0200
***************
*** 1754,1763 ****
  	    buf->modified = buf->bufp->b_changed;
  	    if (prev_b_changed != buf->bufp->b_changed)
  	    {
- #ifdef FEAT_WINDOWS
  		check_status(buf->bufp);
  		redraw_tabline = TRUE;
- #endif
  #ifdef FEAT_TITLE
  		maketitle();
  #endif
--- 1754,1761 ----
***************
*** 2283,2292 ****
      if (curbuf != buf) {
  	if (buf_jump_open_win(buf) != NULL)
  	    return;
- # ifdef FEAT_WINDOWS
  	if ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf) != NULL)
  	    return;
- # endif
  	set_curbuf(buf, DOBUF_GOTO);
      }
  }
--- 2281,2288 ----
*** ../vim-8.0.1117/src/normal.c	2017-09-16 15:38:00.319398219 +0200
--- src/normal.c	2017-09-16 20:05:21.836328464 +0200
***************
*** 2327,2336 ****
      pos_T	start_visual;
      int		moved;		/* Has cursor moved? */
      int		in_status_line;	/* mouse in status line */
- #ifdef FEAT_WINDOWS
      static int	in_tab_line = FALSE; /* mouse clicked in tab line */
      int		in_sep_line;	/* mouse in vertical separator line */
- #endif
      int		c1, c2;
  #if defined(FEAT_FOLDING)
      pos_T	save_cursor;
--- 2327,2334 ----
***************
*** 2424,2436 ****
  	if (!is_drag)			/* release, reset got_click */
  	{
  	    got_click = FALSE;
- #ifdef FEAT_WINDOWS
  	    if (in_tab_line)
  	    {
  		in_tab_line = FALSE;
  		return FALSE;
  	    }
- #endif
  	}
      }
  
--- 2422,2432 ----
***************
*** 2570,2576 ****
  
      start_visual.lnum = 0;
  
- #ifdef FEAT_WINDOWS
      /* Check for clicking in the tab page line. */
      if (mouse_row == 0 && firstwin->w_winrow > 0)
      {
--- 2566,2571 ----
***************
*** 2641,2648 ****
  	return FALSE;
      }
  
- #endif
- 
      /*
       * When 'mousemodel' is "popup" or "popup_setpos", translate mouse events:
       * right button up   -> pop-up menu
--- 2636,2641 ----
***************
*** 2803,2811 ****
  			oap == NULL ? NULL : &(oap->inclusive), which_button);
      moved = (jump_flags & CURSOR_MOVED);
      in_status_line = (jump_flags & IN_STATUS_LINE);
- #ifdef FEAT_WINDOWS
      in_sep_line = (jump_flags & IN_SEP_LINE);
- #endif
  
  #ifdef FEAT_NETBEANS_INTG
      if (isNetbeansBuffer(curbuf)
--- 2796,2802 ----
***************
*** 2984,2990 ****
  	do_put(regname, dir, count, fixindent | PUT_CURSEND);
      }
  
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      /*
       * Ctrl-Mouse click or double click in a quickfix window jumps to the
       * error under the mouse pointer.
--- 2975,2981 ----
  	do_put(regname, dir, count, fixindent | PUT_CURSEND);
      }
  
! #if defined(FEAT_QUICKFIX)
      /*
       * Ctrl-Mouse click or double click in a quickfix window jumps to the
       * error under the mouse pointer.
***************
*** 3039,3056 ****
  	}
  #endif
      }
- #ifdef FEAT_WINDOWS
      else if (in_sep_line)
      {
! # ifdef FEAT_MOUSESHAPE
  	if ((is_drag || is_click) && !drag_sep_line)
  	{
  	    drag_sep_line = TRUE;
  	    update_mouseshape(-1);
  	}
- # endif
-     }
  #endif
      else if ((mod_mask & MOD_MASK_MULTI_CLICK) && (State & (NORMAL | INSERT))
  	     && mouse_has(MOUSE_VISUAL))
      {
--- 3030,3045 ----
  	}
  #endif
      }
      else if (in_sep_line)
      {
! #ifdef FEAT_MOUSESHAPE
  	if ((is_drag || is_click) && !drag_sep_line)
  	{
  	    drag_sep_line = TRUE;
  	    update_mouseshape(-1);
  	}
  #endif
+     }
      else if ((mod_mask & MOD_MASK_MULTI_CLICK) && (State & (NORMAL | INSERT))
  	     && mouse_has(MOUSE_VISUAL))
      {
***************
*** 4105,4113 ****
  
  		redraw_later(VALID);
  		cursor_correct();
- #ifdef FEAT_WINDOWS
  		curwin->w_redr_status = TRUE;
- #endif
  	    }
  
  	    /*
--- 4094,4100 ----
***************
*** 4197,4203 ****
  {
      if (!checkclearop(cap->oap))
      {
- #ifdef FEAT_WINDOWS
  	if (mod_mask & MOD_MASK_CTRL)
  	{
  	    /* <C-PageUp>: tab page back; <C-PageDown>: tab page forward */
--- 4184,4189 ----
***************
*** 4207,4214 ****
  		goto_tabpage((int)cap->count0);
  	}
  	else
! #endif
! 	(void)onepage(cap->arg, cap->count1);
      }
  }
  
--- 4193,4199 ----
  		goto_tabpage((int)cap->count0);
  	}
  	else
! 	    (void)onepage(cap->arg, cap->count1);
      }
  }
  
***************
*** 4468,4476 ****
      if (width2 == 0)
  	width2 = 1; /* avoid divide by zero */
  
- #ifdef FEAT_WINDOWS
      if (curwin->w_width != 0)
- #endif
      {
        /*
         * Instead of sticking at the last character of the buffer line we
--- 4453,4459 ----
***************
*** 4607,4613 ****
      static void
  nv_mousescroll(cmdarg_T *cap)
  {
- # ifdef FEAT_WINDOWS
      win_T *old_curwin = curwin, *wp;
  
      if (mouse_row >= 0 && mouse_col >= 0)
--- 4590,4595 ----
***************
*** 4624,4630 ****
  	curwin = wp;
  	curbuf = curwin->w_buffer;
      }
- # endif
  
      if (cap->arg == MSCR_UP || cap->arg == MSCR_DOWN)
      {
--- 4606,4611 ----
***************
*** 4663,4674 ****
      }
  # endif
  
- # ifdef FEAT_WINDOWS
      curwin->w_redr_status = TRUE;
  
      curwin = old_curwin;
      curbuf = curwin->w_buffer;
- # endif
  }
  
  /*
--- 4644,4653 ----
***************
*** 5539,5545 ****
      }
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * Call nv_ident() as if "c1" was used, with "c2" as next character.
   */
--- 5518,5523 ----
***************
*** 5556,5562 ****
      ca.nchar = c2;
      nv_ident(&ca);
  }
- #endif
  
  /*
   * Handle the commands that use the word under the cursor.
--- 5534,5539 ----
***************
*** 6198,6204 ****
  	nv_page(cap);
      }
      else
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      /* In a quickfix window a <CR> jumps to the error under the cursor. */
      if (bt_quickfix(curbuf) && cap->cmdchar == CAR)
      {
--- 6175,6181 ----
  	nv_page(cap);
      }
      else
! #if defined(FEAT_QUICKFIX)
      /* In a quickfix window a <CR> jumps to the error under the cursor. */
      if (bt_quickfix(curbuf) && cap->cmdchar == CAR)
      {
***************
*** 7846,7860 ****
      static void
  nv_window(cmdarg_T *cap)
  {
- #ifdef FEAT_WINDOWS
      if (cap->nchar == ':')
  	/* "CTRL-W :" is the same as typing ":"; useful in a terminal window */
  	nv_colon(cap);
      else if (!checkclearop(cap->oap))
  	do_window(cap->nchar, cap->count0, NUL); /* everything is in window.c */
- #else
-     (void)checkclearop(cap->oap);
- #endif
  }
  
  /*
--- 7823,7833 ----
***************
*** 8098,8108 ****
      case K_KHOME:
  	oap->motion_type = MCHAR;
  	oap->inclusive = FALSE;
! 	if (curwin->w_p_wrap
! #ifdef FEAT_WINDOWS
! 		&& curwin->w_width != 0
! #endif
! 		)
  	{
  	    int		width1 = W_WIDTH(curwin) - curwin_col_off();
  	    int		width2 = width1 + curwin_col_off2();
--- 8071,8077 ----
      case K_KHOME:
  	oap->motion_type = MCHAR;
  	oap->inclusive = FALSE;
! 	if (curwin->w_p_wrap && curwin->w_width != 0)
  	{
  	    int		width1 = W_WIDTH(curwin) - curwin_col_off();
  	    int		width2 = width1 + curwin_col_off2();
***************
*** 8165,8175 ****
  
  	    oap->motion_type = MCHAR;
  	    oap->inclusive = TRUE;
! 	    if (curwin->w_p_wrap
! #ifdef FEAT_WINDOWS
! 		    && curwin->w_width != 0
! #endif
! 	       )
  	    {
  		curwin->w_curswant = MAXCOL;    /* so we stay at the end */
  		if (cap->count1 == 1)
--- 8134,8140 ----
  
  	    oap->motion_type = MCHAR;
  	    oap->inclusive = TRUE;
! 	    if (curwin->w_p_wrap && curwin->w_width != 0)
  	    {
  		curwin->w_curswant = MAXCOL;    /* so we stay at the end */
  		if (cap->count1 == 1)
***************
*** 8440,8446 ****
  	break;
  #endif
  
- #ifdef FEAT_WINDOWS
      case 't':
  	if (!checkclearop(oap))
  	    goto_tabpage((int)cap->count0);
--- 8405,8410 ----
***************
*** 8449,8455 ****
  	if (!checkclearop(oap))
  	    goto_tabpage(-(int)cap->count1);
  	break;
- #endif
  
      case '+':
      case '-': /* "g+" and "g-": undo or redo along the timeline */
--- 8413,8418 ----
*** ../vim-8.0.1117/src/option.c	2017-09-16 15:50:25.587054089 +0200
--- src/option.c	2017-09-16 20:09:54.834728973 +0200
***************
*** 222,228 ****
  #ifdef FEAT_LINEBREAK
  # define PV_NUW		OPT_WIN(WV_NUW)
  #endif
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  # define PV_PVW		OPT_WIN(WV_PVW)
  #endif
  #ifdef FEAT_RIGHTLEFT
--- 222,228 ----
  #ifdef FEAT_LINEBREAK
  # define PV_NUW		OPT_WIN(WV_NUW)
  #endif
! #if defined(FEAT_QUICKFIX)
  # define PV_PVW		OPT_WIN(WV_PVW)
  #endif
  #ifdef FEAT_RIGHTLEFT
***************
*** 245,254 ****
  # define PV_STL		OPT_BOTH(OPT_WIN(WV_STL))
  #endif
  #define PV_UL		OPT_BOTH(OPT_BUF(BV_UL))
- #ifdef FEAT_WINDOWS
  # define PV_WFH		OPT_WIN(WV_WFH)
  # define PV_WFW		OPT_WIN(WV_WFW)
- #endif
  #define PV_WRAP		OPT_WIN(WV_WRAP)
  #ifdef FEAT_CURSORBIND
  # define PV_CRBIND	OPT_WIN(WV_CRBIND)
--- 245,252 ----
***************
*** 475,490 ****
  # define ISP_LATIN1 (char_u *)"@,161-255"
  #endif
  
- /* Make the string as short as possible when compiling with few features. */
- #if defined(FEAT_DIFF) || defined(FEAT_FOLDING) || defined(FEAT_SPELL) \
- 	|| defined(FEAT_WINDOWS) || defined(FEAT_CLIPBOARD) \
- 	|| defined(FEAT_INS_EXPAND) || defined(FEAT_SYN_HL) \
- 	|| defined(FEAT_CONCEAL) || defined(FEAT_QUICKFIX) \
- 	|| defined(FEAT_TERMINAL)
  # define HIGHLIGHT_INIT "8:SpecialKey,~:EndOfBuffer,@:NonText,d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,N:CursorLineNr,r:Question,s:StatusLine,S:StatusLineNC,c:VertSplit,t:Title,v:Visual,V:VisualNOS,w:WarningMsg,W:WildMenu,f:Folded,F:FoldColumn,A:DiffAdd,C:DiffChange,D:DiffDelete,T:DiffText,>:SignColumn,-:Conceal,B:SpellBad,P:SpellCap,R:SpellRare,L:SpellLocal,+:Pmenu,=:PmenuSel,x:PmenuSbar,X:PmenuThumb,*:TabLine,#:TabLineSel,_:TabLineFill,!:CursorColumn,.:CursorLine,o:ColorColumn,q:QuickFixLine,z:StatusLineTerm,Z:StatusLineTermNC"
- #else
- # define HIGHLIGHT_INIT "8:SpecialKey,@:NonText,d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,N:CursorLineNr,r:Question,s:StatusLine,S:StatusLineNC,t:Title,v:Visual,w:WarningMsg,W:WildMenu,>:SignColumn,*:TabLine,#:TabLineSel,_:TabLineFill"
- #endif
  
  /* Default python version for pyx* commands */
  #if defined(FEAT_PYTHON) && defined(FEAT_PYTHON3)
--- 473,479 ----
***************
*** 1069,1081 ****
  			    (char_u *)&p_dy, PV_NONE,
  			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"eadirection", "ead",  P_STRING|P_VI_DEF,
- #ifdef FEAT_WINDOWS
  			    (char_u *)&p_ead, PV_NONE,
  			    {(char_u *)"both", (char_u *)0L}
- #else
- 			    (char_u *)NULL, PV_NONE,
- 			    {(char_u *)NULL, (char_u *)0L}
- #endif
  			    SCRIPTID_INIT},
      {"edcompatible","ed",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_ed, PV_NONE,
--- 1058,1065 ----
***************
*** 1190,1202 ****
  #endif
  			    SCRIPTID_INIT},
      {"fillchars",   "fcs",  P_STRING|P_VI_DEF|P_RALL|P_ONECOMMA|P_NODUP,
- #if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
  			    (char_u *)&p_fcs, PV_NONE,
  			    {(char_u *)"vert:|,fold:-", (char_u *)0L}
- #else
- 			    (char_u *)NULL, PV_NONE,
- 			    {(char_u *)"", (char_u *)0L}
- #endif
  			    SCRIPTID_INIT},
      {"fixendofline",  "fixeol", P_BOOL|P_VI_DEF|P_RSTAT,
  			    (char_u *)&p_fixeol, PV_FIXEOL,
--- 1174,1181 ----
***************
*** 1495,1505 ****
  			    {(char_u *)DFLT_HELPFILE, (char_u *)0L}
  			    SCRIPTID_INIT},
      {"helpheight",  "hh",   P_NUM|P_VI_DEF,
- #ifdef FEAT_WINDOWS
  			    (char_u *)&p_hh, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)20L, (char_u *)0L} SCRIPTID_INIT},
      {"helplang",    "hlg",  P_STRING|P_VI_DEF|P_ONECOMMA,
  #ifdef FEAT_MULTI_LANG
--- 1474,1480 ----
***************
*** 1806,1816 ****
  #endif
  			    {(char_u *)TRUE, (char_u *)0L} SCRIPTID_INIT},
      {"laststatus",  "ls",   P_NUM|P_VI_DEF|P_RALL,
- #ifdef FEAT_WINDOWS
  			    (char_u *)&p_ls, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
      {"lazyredraw",  "lz",   P_BOOL|P_VI_DEF,
  			    (char_u *)&p_lz, PV_NONE,
--- 1781,1787 ----
***************
*** 2139,2152 ****
  			    (char_u *)&p_pi, PV_PI,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"previewheight", "pvh", P_NUM|P_VI_DEF,
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  			    (char_u *)&p_pvh, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {(char_u *)12L, (char_u *)0L} SCRIPTID_INIT},
      {"previewwindow", "pvw", P_BOOL|P_VI_DEF|P_RSTAT|P_NOGLOB,
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  			    (char_u *)VAR_WIN, PV_PVW,
  #else
  			    (char_u *)NULL, PV_NONE,
--- 2110,2123 ----
  			    (char_u *)&p_pi, PV_PI,
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"previewheight", "pvh", P_NUM|P_VI_DEF,
! #if defined(FEAT_QUICKFIX)
  			    (char_u *)&p_pvh, PV_NONE,
  #else
  			    (char_u *)NULL, PV_NONE,
  #endif
  			    {(char_u *)12L, (char_u *)0L} SCRIPTID_INIT},
      {"previewwindow", "pvw", P_BOOL|P_VI_DEF|P_RSTAT|P_NOGLOB,
! #if defined(FEAT_QUICKFIX)
  			    (char_u *)VAR_WIN, PV_PVW,
  #else
  			    (char_u *)NULL, PV_NONE,
***************
*** 2539,2549 ****
  			    (char_u *)&p_smd, PV_NONE,
  			    {(char_u *)FALSE, (char_u *)TRUE} SCRIPTID_INIT},
      {"showtabline", "stal", P_NUM|P_VI_DEF|P_RALL,
- #ifdef FEAT_WINDOWS
  			    (char_u *)&p_stal, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
      {"sidescroll",  "ss",   P_NUM|P_VI_DEF,
  			    (char_u *)&p_ss, PV_NONE,
--- 2510,2516 ----
***************
*** 2628,2645 ****
  #endif
  			    SCRIPTID_INIT},
      {"splitbelow",  "sb",   P_BOOL|P_VI_DEF,
- #ifdef FEAT_WINDOWS
  			    (char_u *)&p_sb, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"splitright",  "spr",  P_BOOL|P_VI_DEF,
- #ifdef FEAT_WINDOWS
  			    (char_u *)&p_spr, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"startofline", "sol",  P_BOOL|P_VI_DEF|P_VIM,
  			    (char_u *)&p_sol, PV_NONE,
--- 2595,2604 ----
***************
*** 2699,2709 ****
  #endif
  			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
      {"tabpagemax",  "tpm",  P_NUM|P_VI_DEF,
- #ifdef FEAT_WINDOWS
  			    (char_u *)&p_tpm, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)10L, (char_u *)0L} SCRIPTID_INIT},
      {"tabstop",	    "ts",   P_NUM|P_VI_DEF|P_RBUF,
  			    (char_u *)&p_ts, PV_TS,
--- 2658,2664 ----
***************
*** 3067,3105 ****
  			    (char_u *)&p_window, PV_NONE,
  			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
      {"winheight",   "wh",   P_NUM|P_VI_DEF,
- #ifdef FEAT_WINDOWS
  			    (char_u *)&p_wh, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
      {"winfixheight", "wfh", P_BOOL|P_VI_DEF|P_RSTAT,
- #ifdef FEAT_WINDOWS
  			    (char_u *)VAR_WIN, PV_WFH,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"winfixwidth", "wfw", P_BOOL|P_VI_DEF|P_RSTAT,
- #ifdef FEAT_WINDOWS
  			    (char_u *)VAR_WIN, PV_WFW,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
      {"winminheight", "wmh", P_NUM|P_VI_DEF,
- #ifdef FEAT_WINDOWS
  			    (char_u *)&p_wmh, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
      {"winminwidth", "wmw", P_NUM|P_VI_DEF,
- #ifdef FEAT_WINDOWS
  			    (char_u *)&p_wmw, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)1L, (char_u *)0L} SCRIPTID_INIT},
      {"winptydll", NULL,	    P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
  #if defined(WIN3264) && defined(FEAT_TERMINAL)
--- 3022,3040 ----
***************
*** 3116,3126 ****
  #endif
  			    SCRIPTID_INIT},
      {"winwidth",   "wiw",   P_NUM|P_VI_DEF,
- #ifdef FEAT_WINDOWS
  			    (char_u *)&p_wiw, PV_NONE,
- #else
- 			    (char_u *)NULL, PV_NONE,
- #endif
  			    {(char_u *)20L, (char_u *)0L} SCRIPTID_INIT},
      {"wrap",	    NULL,   P_BOOL|P_VI_DEF|P_RWIN,
  			    (char_u *)VAR_WIN, PV_WRAP,
--- 3051,3057 ----
***************
*** 3171,3179 ****
      p_term("t_CS", T_CCS)
      p_term("t_Cs", T_UCS)
      p_term("t_cs", T_CS)
- #ifdef FEAT_WINDOWS
      p_term("t_CV", T_CSV)
- #endif
      p_term("t_da", T_DA)
      p_term("t_db", T_DB)
      p_term("t_DL", T_CDL)
--- 3102,3108 ----
***************
*** 3265,3273 ****
  static char *(p_scbopt_values[]) = {"ver", "hor", "jump", NULL};
  #endif
  static char *(p_debug_values[]) = {"msg", "throw", "beep", NULL};
- #ifdef FEAT_WINDOWS
  static char *(p_ead_values[]) = {"both", "ver", "hor", NULL};
- #endif
  #ifdef FEAT_AUTOCMD
  static char *(p_buftype_values[]) = {"nofile", "nowrite", "quickfix", "help", "terminal", "acwrite", NULL};
  #else
--- 3194,3200 ----
***************
*** 3855,3864 ****
      int		opt_flags)	/* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */
  {
      int		i;
- #ifdef FEAT_WINDOWS
      win_T	*wp;
      tabpage_T	*tp;
- #endif
  
      for (i = 0; !istermoption(&options[i]); i++)
  	if (!(options[i].flags & P_NODEFAULT)
--- 3782,3789 ----
***************
*** 3877,3889 ****
  			)
  	    set_option_default(i, opt_flags, p_cp);
  
- #ifdef FEAT_WINDOWS
      /* The 'scroll' option must be computed for all windows. */
      FOR_ALL_TAB_WINDOWS(tp, wp)
  	win_comp_scroll(wp);
- #else
- 	win_comp_scroll(curwin);
- #endif
  #ifdef FEAT_CINDENT
      parse_cino(curbuf);
  #endif
--- 3802,3810 ----
***************
*** 5633,5642 ****
      check_opt_wim();
  
      (void)set_chars_option(&p_lcs);
- #if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
      /* Parse default for 'fillchars'. */
      (void)set_chars_option(&p_fcs);
- #endif
  
  #ifdef FEAT_CLIPBOARD
      /* Parse default for 'clipboard' */
--- 5554,5561 ----
***************
*** 5875,5883 ****
  static void redraw_titles(void)
  {
      need_maketitle = TRUE;
- # ifdef FEAT_WINDOWS
      redraw_tabline = TRUE;
- # endif
  }
  #endif
  
--- 5794,5800 ----
***************
*** 6280,6289 ****
  	    errmsg = e_invarg;
  	else if (set_chars_option(&p_lcs) != NULL)
  	    errmsg = (char_u *)_("E834: Conflicts with value of 'listchars'");
- # if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
  	else if (set_chars_option(&p_fcs) != NULL)
  	    errmsg = (char_u *)_("E835: Conflicts with value of 'fillchars'");
- # endif
      }
  #endif
  
--- 6197,6204 ----
***************
*** 6503,6511 ****
  		set_iminsert_global();
  		set_imsearch_global();
  	    }
- # ifdef FEAT_WINDOWS
  	    status_redraw_curbuf();
- # endif
  	}
      }
  #endif
--- 6418,6424 ----
***************
*** 6708,6720 ****
  	errmsg = set_chars_option(varp);
      }
  
- #if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
      /* 'fillchars' */
      else if (varp == &p_fcs)
      {
  	errmsg = set_chars_option(varp);
      }
- #endif
  
  #ifdef FEAT_CMDWIN
      /* 'cedit' */
--- 6621,6631 ----
***************
*** 7088,7101 ****
  
      }
  
- #ifdef FEAT_WINDOWS
      /* 'eadirection' */
      else if (varp == &p_ead)
      {
  	if (check_opt_strings(p_ead, p_ead_values, FALSE) != OK)
  	    errmsg = e_invarg;
      }
- #endif
  
  #ifdef FEAT_CLIPBOARD
      /* 'clipboard' */
--- 6999,7010 ----
***************
*** 7144,7156 ****
  	    errmsg = e_invarg;
  	else
  	{
- #ifdef FEAT_WINDOWS
  	    if (curwin->w_status_height)
  	    {
  		curwin->w_redr_status = TRUE;
  		redraw_later(VALID);
  	    }
- #endif
  	    curbuf->b_help = (curbuf->b_p_bt[0] == 'h');
  #ifdef FEAT_TITLE
  	    redraw_titles();
--- 7053,7063 ----
***************
*** 7773,7779 ****
  	int	*cp;
  	char	*name;
      };
- #if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
      static struct charstab filltab[] =
      {
  	{&fill_stl,	"stl"},
--- 7680,7685 ----
***************
*** 7782,7788 ****
  	{&fill_fold,	"fold"},
  	{&fill_diff,	"diff"},
      };
- #endif
      static struct charstab lcstab[] =
      {
  	{&lcs_eol,	"eol"},
--- 7688,7693 ----
***************
*** 7800,7819 ****
      };
      struct charstab *tab;
  
- #if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
      if (varp == &p_lcs)
- #endif
      {
  	tab = lcstab;
  	entries = sizeof(lcstab) / sizeof(struct charstab);
      }
- #if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
      else
      {
  	tab = filltab;
  	entries = sizeof(filltab) / sizeof(struct charstab);
      }
- #endif
  
      /* first round: check for valid value, second round: assign values */
      for (round = 0; round <= 1; ++round)
--- 7705,7720 ----
***************
*** 7827,7836 ****
  		    *(tab[i].cp) = (varp == &p_lcs ? NUL : ' ');
  	    if (varp == &p_lcs)
  		lcs_tab1 = NUL;
- #if defined(FEAT_WINDOWS) || defined(FEAT_FOLDING)
  	    else
  		fill_diff = '-';
- #endif
  	}
  	p = *varp;
  	while (*p)
--- 7728,7735 ----
***************
*** 8077,8085 ****
  	    if (wp->w_buffer == curbuf && wp->w_p_spell)
  	    {
  		errmsg = did_set_spelllang(wp);
- # ifdef FEAT_WINDOWS
  		break;
- # endif
  	    }
      }
      return errmsg;
--- 7976,7982 ----
***************
*** 8388,8394 ****
      }
  #endif
  
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      /* There can be only one window with 'previewwindow' set. */
      else if ((int *)varp == &curwin->w_p_pvw)
      {
--- 8285,8291 ----
      }
  #endif
  
! #if defined(FEAT_QUICKFIX)
      /* There can be only one window with 'previewwindow' set. */
      else if ((int *)varp == &curwin->w_p_pvw)
      {
***************
*** 8486,8498 ****
  	    curwin->w_leftcol = 0;
      }
  
- #ifdef FEAT_WINDOWS
      else if ((int *)varp == &p_ea)
      {
  	if (p_ea && !old_value)
  	    win_equal(curwin, FALSE, 0);
      }
- #endif
  
      else if ((int *)varp == &p_wiv)
      {
--- 8383,8393 ----
***************
*** 8803,8809 ****
      /*
       * Number options that need some action when changed
       */
- #ifdef FEAT_WINDOWS
      if (pp == &p_wh || pp == &p_hh)
      {
  	if (p_wh < 1)
--- 8698,8703 ----
***************
*** 8847,8854 ****
  	}
  	win_setminheight();
      }
- 
- # ifdef FEAT_WINDOWS
      else if (pp == &p_wiw)
      {
  	if (p_wiw < 1)
--- 8741,8746 ----
***************
*** 8882,8892 ****
  	}
  	win_setminheight();
      }
- # endif
- 
- #endif
  
- #ifdef FEAT_WINDOWS
      /* (re)set last window status line */
      else if (pp == &p_ls)
      {
--- 8774,8780 ----
***************
*** 8898,8904 ****
      {
  	shell_new_rows();	/* recompute window positions and heights */
      }
- #endif
  
  #ifdef FEAT_GUI
      else if (pp == &p_linespace)
--- 8786,8791 ----
***************
*** 8987,8993 ****
  	p_iminsert = curbuf->b_p_iminsert;
  	if (termcap_active)	/* don't do this in the alternate screen */
  	    showmode();
! #if defined(FEAT_WINDOWS) && defined(FEAT_KEYMAP)
  	/* Show/unshow value of 'keymap' in status lines. */
  	status_redraw_curbuf();
  #endif
--- 8874,8880 ----
  	p_iminsert = curbuf->b_p_iminsert;
  	if (termcap_active)	/* don't do this in the alternate screen */
  	    showmode();
! #if defined(FEAT_KEYMAP)
  	/* Show/unshow value of 'keymap' in status lines. */
  	status_redraw_curbuf();
  #endif
***************
*** 9137,9143 ****
  	    curbuf->b_p_tw = 0;
  	}
  #ifdef FEAT_SYN_HL
- # ifdef FEAT_WINDOWS
  	{
  	    win_T	*wp;
  	    tabpage_T	*tp;
--- 9024,9029 ----
***************
*** 9145,9153 ****
  	    FOR_ALL_TAB_WINDOWS(tp, wp)
  		check_colorcolumn(wp);
  	}
- # else
- 	check_colorcolumn(curwin);
- # endif
  #endif
      }
  
--- 9031,9036 ----
***************
*** 9329,9338 ****
      int		doclear = (flags & P_RCLR) == P_RCLR;
      int		all = ((flags & P_RALL) == P_RALL || doclear);
  
- #ifdef FEAT_WINDOWS
      if ((flags & P_RSTAT) || all)	/* mark all status lines dirty */
  	status_redraw_all();
- #endif
  
      if ((flags & P_RBUF) || (flags & P_RWIN) || all)
  	changed_window_setting();
--- 9212,9219 ----
***************
*** 10420,10437 ****
      void
  comp_col(void)
  {
! #if defined(FEAT_CMDL_INFO) && defined(FEAT_WINDOWS)
      int last_has_status = (p_ls == 2 || (p_ls == 1 && !ONE_WINDOW));
  
      sc_col = 0;
      ru_col = 0;
      if (p_ru)
      {
! #ifdef FEAT_STL_OPT
  	ru_col = (ru_wid ? ru_wid : COL_RULER) + 1;
! #else
  	ru_col = COL_RULER + 1;
! #endif
  	/* no last status line, adjust sc_col */
  	if (!last_has_status)
  	    sc_col = ru_col;
--- 10301,10318 ----
      void
  comp_col(void)
  {
! #if defined(FEAT_CMDL_INFO)
      int last_has_status = (p_ls == 2 || (p_ls == 1 && !ONE_WINDOW));
  
      sc_col = 0;
      ru_col = 0;
      if (p_ru)
      {
! # ifdef FEAT_STL_OPT
  	ru_col = (ru_wid ? ru_wid : COL_RULER) + 1;
! # else
  	ru_col = COL_RULER + 1;
! # endif
  	/* no last status line, adjust sc_col */
  	if (!last_has_status)
  	    sc_col = ru_col;
***************
*** 10723,10733 ****
  #ifdef FEAT_LINEBREAK
  	case PV_NUW:	return (char_u *)&(curwin->w_p_nuw);
  #endif
- #ifdef FEAT_WINDOWS
  	case PV_WFH:	return (char_u *)&(curwin->w_p_wfh);
  	case PV_WFW:	return (char_u *)&(curwin->w_p_wfw);
! #endif
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  	case PV_PVW:	return (char_u *)&(curwin->w_p_pvw);
  #endif
  #ifdef FEAT_RIGHTLEFT
--- 10604,10612 ----
  #ifdef FEAT_LINEBREAK
  	case PV_NUW:	return (char_u *)&(curwin->w_p_nuw);
  #endif
  	case PV_WFH:	return (char_u *)&(curwin->w_p_wfh);
  	case PV_WFW:	return (char_u *)&(curwin->w_p_wfw);
! #if defined(FEAT_QUICKFIX)
  	case PV_PVW:	return (char_u *)&(curwin->w_p_pvw);
  #endif
  #ifdef FEAT_RIGHTLEFT
***************
*** 10879,10885 ****
      return curbuf->b_p_ep;
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * Copy options from one window to another.
   * Used when splitting a window.
--- 10758,10763 ----
***************
*** 10899,10905 ****
      briopt_check(wp_to);
  #endif
  }
- #endif
  
  /*
   * Copy the options from one winopt_T to another.
--- 10777,10782 ----
***************
*** 12176,12185 ****
  	p_sm = 0;		    /* no showmatch */
  	p_sta = 0;		    /* no smarttab */
  #ifdef FEAT_CMDL_INFO
- # ifdef FEAT_WINDOWS
  	if (p_ru)
  	    status_redraw_all();    /* redraw to remove the ruler */
- # endif
  	p_ru = 0;		    /* no ruler */
  #endif
  #ifdef FEAT_RIGHTLEFT
--- 12053,12060 ----
***************
*** 12212,12221 ****
  	p_sm = save_sm;
  	p_sta = save_sta;
  #ifdef FEAT_CMDL_INFO
- # ifdef FEAT_WINDOWS
  	if (p_ru != save_ru)
  	    status_redraw_all();    /* redraw to draw the ruler */
- # endif
  	p_ru = save_ru;
  #endif
  #ifdef FEAT_RIGHTLEFT
--- 12087,12094 ----
*** ../vim-8.0.1117/src/popupmnu.c	2017-03-12 19:22:31.764584873 +0100
--- src/popupmnu.c	2017-09-16 20:10:43.662441779 +0200
***************
*** 60,66 ****
      int		above_row;
      int		below_row;
      int		redo_count = 0;
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      win_T	*pvwin;
  #endif
  
--- 60,66 ----
      int		above_row;
      int		below_row;
      int		redo_count = 0;
! #if defined(FEAT_QUICKFIX)
      win_T	*pvwin;
  #endif
  
***************
*** 80,86 ****
  
      row = curwin->w_wrow + W_WINROW(curwin);
  
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      FOR_ALL_WINDOWS(pvwin)
  	if (pvwin->w_p_pvw)
  	    break;
--- 80,86 ----
  
      row = curwin->w_wrow + W_WINROW(curwin);
  
! #if defined(FEAT_QUICKFIX)
      FOR_ALL_WINDOWS(pvwin)
  	if (pvwin->w_p_pvw)
  	    break;
***************
*** 156,162 ****
      if (pum_height < 1 || (pum_height == 1 && size > 1))
  	return;
  
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      /* If there is a preview window at the above avoid drawing over it. */
      if (pvwin != NULL && pum_row < above_row && pum_height > above_row)
      {
--- 156,162 ----
      if (pum_height < 1 || (pum_height == 1 && size > 1))
  	return;
  
! #if defined(FEAT_QUICKFIX)
      /* If there is a preview window at the above avoid drawing over it. */
      if (pvwin != NULL && pum_row < above_row && pum_height > above_row)
      {
***************
*** 551,557 ****
  	    }
  	}
  
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  	/*
  	 * Show extra info in the preview window if there is something and
  	 * 'completeopt' contains "preview".
--- 551,557 ----
  	    }
  	}
  
! #if defined(FEAT_QUICKFIX)
  	/*
  	 * Show extra info in the preview window if there is something and
  	 * 'completeopt' contains "preview".
***************
*** 715,723 ****
  {
      pum_array = NULL;
      redraw_all_later(SOME_VALID);
- #ifdef FEAT_WINDOWS
      redraw_tabline = TRUE;
- #endif
      status_redraw_all();
  }
  
--- 715,721 ----
*** ../vim-8.0.1117/src/quickfix.c	2017-09-15 22:43:01.793323528 +0200
--- src/quickfix.c	2017-09-16 20:11:50.814035429 +0200
***************
*** 145,151 ****
  static char_u	*qf_guess_filepath(qf_info_T *qi, int qf_idx, char_u *);
  static void	qf_fmt_text(char_u *text, char_u *buf, int bufsize);
  static void	qf_clean_dir_stack(struct dir_stack_T **);
- #ifdef FEAT_WINDOWS
  static int	qf_win_pos_update(qf_info_T *qi, int old_qf_index);
  static int	is_qf_win(win_T *win, qf_info_T *qi);
  static win_T	*qf_find_win(qf_info_T *qi);
--- 145,150 ----
***************
*** 153,159 ****
  static void	qf_update_buffer(qf_info_T *qi, qfline_T *old_last);
  static void	qf_set_title_var(qf_info_T *qi);
  static void	qf_fill_buffer(qf_info_T *qi, buf_T *buf, qfline_T *old_last);
- #endif
  static char_u	*get_mef_name(void);
  static void	restore_start_dir(char_u *dirname_start);
  static buf_T	*load_dummy_buffer(char_u *fname, char_u *dirname_start, char_u *resulting_dir);
--- 152,157 ----
***************
*** 1165,1173 ****
      qf_list_T	    *qfl;
      qfstate_T	    state;
      qffields_T	    fields;
- #ifdef FEAT_WINDOWS
      qfline_T	    *old_last = NULL;
- #endif
      int		    adding = FALSE;
      static efm_T    *fmt_first = NULL;
      char_u	    *efm;
--- 1163,1169 ----
***************
*** 1209,1218 ****
      {
  	/* Adding to existing list, use last entry. */
  	adding = TRUE;
- #ifdef FEAT_WINDOWS
  	if (qi->qf_lists[qf_idx].qf_count > 0)
  	    old_last = qi->qf_lists[qf_idx].qf_last;
- #endif
      }
  
      qfl = &qi->qf_lists[qf_idx];
--- 1205,1212 ----
***************
*** 1339,1348 ****
      vim_free(fields.pattern);
      vim_free(state.growbuf);
  
- #ifdef FEAT_WINDOWS
      if (qf_idx == qi->qf_curlist)
  	qf_update_buffer(qi, old_last);
- #endif
  #ifdef FEAT_MBYTE
      if (state.vc.vc_type != CONV_NONE)
  	convert_setup(&state.vc, NULL, NULL);
--- 1333,1340 ----
***************
*** 2101,2107 ****
      return qf_ptr;
  }
  
- #ifdef FEAT_WINDOWS
  /*
   * Find a help window or open one.
   */
--- 2093,2098 ----
***************
*** 2153,2159 ****
  
      return OK;
  }
- #endif
  
  /*
   * jump to a quickfix line
--- 2144,2149 ----
***************
*** 2181,2194 ****
      colnr_T		screen_col;
      colnr_T		char_col;
      char_u		*line;
- #ifdef FEAT_WINDOWS
      char_u		*old_swb = p_swb;
      unsigned		old_swb_flags = swb_flags;
      int			opened_window = FALSE;
      win_T		*win;
      win_T		*altwin;
      int			flags;
- #endif
      win_T		*oldwin = curwin;
      int			print_message = TRUE;
      int			len;
--- 2171,2182 ----
***************
*** 2225,2231 ****
      else if (errornr != 0)	/* go to specified number */
  	qf_ptr = get_nth_entry(qi, errornr, qf_ptr, &qf_index);
  
- #ifdef FEAT_WINDOWS
      qi->qf_lists[qi->qf_curlist].qf_index = qf_index;
      if (qf_win_pos_update(qi, old_qf_index))
  	/* No need to print the error message if it's visible in the error
--- 2213,2218 ----
***************
*** 2405,2411 ****
  	    }
  	}
      }
- #endif
  
      /*
       * If there is a file name,
--- 2392,2397 ----
***************
*** 2558,2576 ****
      }
      else
      {
- #ifdef FEAT_WINDOWS
  	if (opened_window)
  	    win_close(curwin, TRUE);    /* Close opened window */
- #endif
  	if (qf_ptr != NULL && qf_ptr->qf_fnum != 0)
  	{
  	    /*
  	     * Couldn't open file, so put index back where it was.  This could
  	     * happen if the file was readonly and we changed something.
  	     */
- #ifdef FEAT_WINDOWS
  failed:
- #endif
  	    qf_ptr = old_qf_ptr;
  	    qf_index = old_qf_index;
  	}
--- 2544,2558 ----
***************
*** 2581,2587 ****
  	qi->qf_lists[qi->qf_curlist].qf_ptr = qf_ptr;
  	qi->qf_lists[qi->qf_curlist].qf_index = qf_index;
      }
- #ifdef FEAT_WINDOWS
      if (p_swb != old_swb && opened_window)
      {
  	/* Restore old 'switchbuf' value, but not when an autocommand or
--- 2563,2568 ----
***************
*** 2594,2600 ****
  	else
  	    free_string_option(old_swb);
      }
- #endif
  }
  
  /*
--- 2575,2580 ----
***************
*** 2820,2828 ****
  	}
      }
      qf_msg(qi, qi->qf_curlist, "");
- #ifdef FEAT_WINDOWS
      qf_update_buffer(qi, NULL);
- #endif
  }
  
      void
--- 2800,2806 ----
***************
*** 3001,3007 ****
      return buf;
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * ":cwindow": open the quickfix window if we have errors to display,
   *	       close it if not.
--- 2979,2984 ----
***************
*** 3544,3551 ****
      KeyTyped = old_KeyTyped;
  }
  
- #endif /* FEAT_WINDOWS */
- 
  /*
   * Return TRUE when using ":vimgrep" for ":grep".
   */
--- 3521,3526 ----
***************
*** 4421,4429 ****
      qi->qf_lists[qi->qf_curlist].qf_ptr = qi->qf_lists[qi->qf_curlist].qf_start;
      qi->qf_lists[qi->qf_curlist].qf_index = 1;
  
- #ifdef FEAT_WINDOWS
      qf_update_buffer(qi, NULL);
- #endif
  
  #ifdef FEAT_AUTOCMD
      if (au_name != NULL)
--- 4396,4402 ----
***************
*** 4976,4984 ****
      long	lnum;
      int		col, nr;
      int		vcol;
- #ifdef FEAT_WINDOWS
      qfline_T	*old_last = NULL;
- #endif
      int		valid, status;
      int		retval = OK;
      int		did_bufnr_emsg = FALSE;
--- 4949,4955 ----
***************
*** 4989,4999 ****
  	qf_new_list(qi, title);
  	qf_idx = qi->qf_curlist;
      }
- #ifdef FEAT_WINDOWS
      else if (action == 'a' && qi->qf_lists[qf_idx].qf_count > 0)
  	/* Adding to existing list, use last entry. */
  	old_last = qi->qf_lists[qf_idx].qf_last;
- #endif
      else if (action == 'r')
      {
  	qf_free_items(qi, qf_idx);
--- 4960,4968 ----
***************
*** 5081,5090 ****
  	    qi->qf_lists[qf_idx].qf_index = 1;
      }
  
- #ifdef FEAT_WINDOWS
      /* Don't update the cursor in quickfix window when appending entries */
      qf_update_buffer(qi, old_last);
- #endif
  
      return retval;
  }
--- 5050,5057 ----
***************
*** 5754,5762 ****
  	/* Darn, some plugin changed the value. */
  	free_string_option(save_cpo);
  
- #ifdef FEAT_WINDOWS
      qf_update_buffer(qi, NULL);
- #endif
  
  #ifdef FEAT_AUTOCMD
      if (au_name != NULL)
--- 5721,5727 ----
*** ../vim-8.0.1117/src/screen.c	2017-09-13 22:11:31.761200612 +0200
--- src/screen.c	2017-09-16 20:19:24.815293157 +0200
***************
*** 130,138 ****
  #endif
  static int win_line(win_T *, linenr_T, int, int, int nochange, proftime_T *syntax_tm);
  static int char_needs_redraw(int off_from, int off_to, int cols);
- #ifdef FEAT_WINDOWS
  static void draw_vsep_win(win_T *wp, int row);
- #endif
  #ifdef FEAT_STL_OPT
  static void redraw_custom_statusline(win_T *wp);
  #endif
--- 130,136 ----
***************
*** 153,175 ****
  static void screenclear2(void);
  static void lineclear(unsigned off, int width, int attr);
  static void lineinvalid(unsigned off, int width);
- #ifdef FEAT_WINDOWS
  static void linecopy(int to, int from, win_T *wp);
  static void redraw_block(int row, int end, win_T *wp);
- #endif
  static int win_do_lines(win_T *wp, int row, int line_count, int mayclear, int del, int clear_attr);
  static void win_rest_invalid(win_T *wp);
  static void msg_pos_mode(void);
  static void recording_mode(int attr);
- #if defined(FEAT_WINDOWS)
  static void draw_tabline(void);
- #endif
- #if defined(FEAT_WINDOWS) || defined(FEAT_WILDMENU) || defined(FEAT_STL_OPT)
  static int fillchar_status(int *attr, win_T *wp);
- #endif
- #ifdef FEAT_WINDOWS
  static int fillchar_vsep(int *attr);
- #endif
  #ifdef FEAT_STL_OPT
  static void win_redr_custom(win_T *wp, int draw_ruler);
  #endif
--- 151,165 ----
***************
*** 177,186 ****
  static void win_redr_ruler(win_T *wp, int always);
  #endif
  
- #if defined(FEAT_CLIPBOARD) || defined(FEAT_WINDOWS)
  /* Ugly global: overrule attribute used by screen_char() */
  static int screen_char_attr = 0;
- #endif
  
  #if defined(FEAT_SYN_HL) && defined(FEAT_RELTIME)
  /* Can limit syntax highlight time to 'redrawtime'. */
--- 167,174 ----
***************
*** 289,297 ****
  	if (wp->w_buffer == buf)
  	{
  	    redraw_win_later(wp, type);
- #ifdef FEAT_WINDOWS
  	    wp->w_redr_status = TRUE;
- #endif
  	}
      }
  }
--- 277,283 ----
***************
*** 630,648 ****
  		    else
  		    {
  			wp->w_redr_type = NOT_VALID;
- #ifdef FEAT_WINDOWS
  			if (W_WINROW(wp) + wp->w_height + W_STATUS_HEIGHT(wp)
  				<= msg_scrolled)
  			    wp->w_redr_status = TRUE;
- #endif
  		    }
  		}
  	    }
  	    if (!no_update)
  		redraw_cmdline = TRUE;
- #ifdef FEAT_WINDOWS
  	    redraw_tabline = TRUE;
- #endif
  	}
  	msg_scrolled = 0;
  	need_wait_return = FALSE;
--- 616,630 ----
***************
*** 697,707 ****
  		))
  	curwin->w_redr_type = type;
  
- #ifdef FEAT_WINDOWS
      /* Redraw the tab pages line if needed. */
      if (redraw_tabline || type >= NOT_VALID)
  	draw_tabline();
- #endif
  
  #ifdef FEAT_SYN_HL
      /*
--- 679,687 ----
***************
*** 712,730 ****
      {
  	if (wp->w_buffer->b_mod_set)
  	{
- # ifdef FEAT_WINDOWS
  	    win_T	*wwp;
  
  	    /* Check if we already did this buffer. */
  	    for (wwp = firstwin; wwp != wp; wwp = wwp->w_next)
  		if (wwp->w_buffer == wp->w_buffer)
  		    break;
! # endif
! 	    if (
! # ifdef FEAT_WINDOWS
! 		    wwp == wp &&
! # endif
! 		    syntax_present(wp))
  		syn_stack_apply_changes(wp->w_buffer);
  	}
      }
--- 692,704 ----
      {
  	if (wp->w_buffer->b_mod_set)
  	{
  	    win_T	*wwp;
  
  	    /* Check if we already did this buffer. */
  	    for (wwp = firstwin; wwp != wp; wwp = wwp->w_next)
  		if (wwp->w_buffer == wp->w_buffer)
  		    break;
! 	    if (wwp == wp && syntax_present(wp))
  		syn_stack_apply_changes(wp->w_buffer);
  	}
      }
***************
*** 776,789 ****
  	    win_update(wp);
  	}
  
- #ifdef FEAT_WINDOWS
  	/* redraw status line after the window to minimize cursor movement */
  	if (wp->w_redr_status)
  	{
  	    cursor_off();
  	    win_redr_status(wp);
  	}
- #endif
      }
  #if defined(FEAT_SEARCH_EXTRA)
      end_search_hl();
--- 750,761 ----
***************
*** 794,807 ****
  	pum_redraw();
  #endif
  
- #ifdef FEAT_WINDOWS
      /* Reset b_mod_set flags.  Going through all windows is probably faster
       * than going through all buffers (there could be many buffers). */
      FOR_ALL_WINDOWS(wp)
  	wp->w_buffer->b_mod_set = FALSE;
- #else
- 	curbuf->b_mod_set = FALSE;
- #endif
  
      updating_screen = FALSE;
  #ifdef FEAT_GUI
--- 766,775 ----
***************
*** 1038,1044 ****
      /* update all windows that need updating */
      update_prepare();
  
- # ifdef FEAT_WINDOWS
      FOR_ALL_WINDOWS(wp)
      {
  	if (wp->w_redr_type != 0)
--- 1006,1011 ----
***************
*** 1046,1055 ****
  	if (wp->w_redr_status)
  	    win_redr_status(wp);
      }
- # else
-     if (curwin->w_redr_type != 0)
- 	win_update(curwin);
- # endif
  
      update_finish();
  }
--- 1013,1018 ----
***************
*** 1080,1086 ****
  
      win_update(wp);
  
- #ifdef FEAT_WINDOWS
      /* When the screen was cleared redraw the tab pages line. */
      if (redraw_tabline)
  	draw_tabline();
--- 1043,1048 ----
***************
*** 1094,1100 ****
  # endif
  	    )
  	win_redr_status(wp);
- #endif
  
      update_finish();
  }
--- 1056,1061 ----
***************
*** 1183,1191 ****
  
      if (type == NOT_VALID)
      {
- #ifdef FEAT_WINDOWS
  	wp->w_redr_status = TRUE;
- #endif
  	wp->w_lines_valid = 0;
      }
  
--- 1144,1150 ----
***************
*** 1196,1202 ****
  	return;
      }
  
- #ifdef FEAT_WINDOWS
      /* Window is zero-width: Only need to draw the separator. */
      if (wp->w_width == 0)
      {
--- 1155,1160 ----
***************
*** 1205,1211 ****
  	wp->w_redr_type = 0;
  	return;
      }
- #endif
  
  #ifdef FEAT_TERMINAL
      /* If this window contains a terminal, redraw works completely differently.
--- 1163,1168 ----
***************
*** 1603,1613 ****
  		 * then. */
  		if (screen_cleared != TRUE)
  		    screenclear();
- #ifdef FEAT_WINDOWS
  		/* The screen was cleared, redraw the tab pages line. */
  		if (redraw_tabline)
  		    draw_tabline();
- #endif
  	    }
  	}
  
--- 1560,1568 ----
***************
*** 2275,2283 ****
      }
      else
      {
- #ifdef FEAT_WINDOWS
  	draw_vsep_win(wp, row);
- #endif
  	if (eof)		/* we hit the end of the file */
  	{
  	    wp->w_botline = buf->b_ml.ml_line_count + 1;
--- 2230,2236 ----
***************
*** 3116,3122 ****
      int		need_showbreak = FALSE; /* overlong line, skipping first x
  					   chars */
  #endif
! #if defined(FEAT_SIGNS) || (defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)) \
  	|| defined(FEAT_SYN_HL) || defined(FEAT_DIFF)
  # define LINE_ATTR
      int		line_attr = 0;		/* attribute for the whole line */
--- 3069,3075 ----
      int		need_showbreak = FALSE; /* overlong line, skipping first x
  					   chars */
  #endif
! #if defined(FEAT_SIGNS) || defined(FEAT_QUICKFIX) \
  	|| defined(FEAT_SYN_HL) || defined(FEAT_DIFF)
  # define LINE_ATTR
      int		line_attr = 0;		/* attribute for the whole line */
***************
*** 3450,3456 ****
      if (v != 0)
  	line_attr = sign_get_attr((int)v, TRUE);
  # endif
! # if defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)
      /* Highlight the current line in the quickfix window. */
      if (bt_quickfix(wp->w_buffer) && qf_current_entry(wp) == lnum)
  	line_attr = HL_ATTR(HLF_QFL);
--- 3403,3409 ----
      if (v != 0)
  	line_attr = sign_get_attr((int)v, TRUE);
  # endif
! # if defined(FEAT_QUICKFIX)
      /* Highlight the current line in the quickfix window. */
      if (bt_quickfix(wp->w_buffer) && qf_current_entry(wp) == lnum)
  	line_attr = HL_ATTR(HLF_QFL);
***************
*** 5840,5848 ****
  		    )
  	    {
  		win_draw_end(wp, '@', ' ', row, wp->w_height, HLF_AT);
- #ifdef FEAT_WINDOWS
  		draw_vsep_win(wp, row);
- #endif
  		row = endrow;
  	    }
  
--- 5793,5799 ----
***************
*** 5857,5866 ****
  #ifdef FEAT_DIFF
  		     && filler_todo <= 0
  #endif
! #ifdef FEAT_WINDOWS
! 		     && W_WIDTH(wp) == Columns
! #endif
! 		     )
  	    {
  		/* Remember that the line wraps, used for modeless copy. */
  		LineWraps[screen_row - 1] = TRUE;
--- 5808,5814 ----
  #ifdef FEAT_DIFF
  		     && filler_todo <= 0
  #endif
! 		     && W_WIDTH(wp) == Columns)
  	    {
  		/* Remember that the line wraps, used for modeless copy. */
  		LineWraps[screen_row - 1] = TRUE;
***************
*** 6060,6068 ****
      unsigned	    max_off_to;
  #endif
      int		    col = 0;
- #if defined(FEAT_GUI) || defined(UNIX) || defined(FEAT_WINDOWS)
      int		    hl;
- #endif
      int		    force = FALSE;	/* force update rest of the line */
      int		    redraw_this		/* bool: does character need redraw? */
  #ifdef FEAT_GUI
--- 6008,6014 ----
***************
*** 6399,6414 ****
  #endif
  	    screen_fill(row, row + 1, col + coloff, clear_width + coloff,
  								 ' ', ' ', 0);
- #ifdef FEAT_WINDOWS
  	    off_to += clear_width - col;
  	    col = clear_width;
- #endif
  	}
      }
  
      if (clear_width > 0)
      {
- #ifdef FEAT_WINDOWS
  	/* For a window that's left of another, draw the separator char. */
  	if (col + coloff < Columns)
  	{
--- 6345,6357 ----
***************
*** 6416,6430 ****
  
  	    c = fillchar_vsep(&hl);
  	    if (ScreenLines[off_to] != (schar_T)c
! # ifdef FEAT_MBYTE
  		    || (enc_utf8 && (int)ScreenLinesUC[off_to]
  						       != (c >= 0x80 ? c : 0))
! # endif
  		    || ScreenAttrs[off_to] != hl)
  	    {
  		ScreenLines[off_to] = c;
  		ScreenAttrs[off_to] = hl;
! # ifdef FEAT_MBYTE
  		if (enc_utf8)
  		{
  		    if (c >= 0x80)
--- 6359,6373 ----
  
  	    c = fillchar_vsep(&hl);
  	    if (ScreenLines[off_to] != (schar_T)c
! #ifdef FEAT_MBYTE
  		    || (enc_utf8 && (int)ScreenLinesUC[off_to]
  						       != (c >= 0x80 ? c : 0))
! #endif
  		    || ScreenAttrs[off_to] != hl)
  	    {
  		ScreenLines[off_to] = c;
  		ScreenAttrs[off_to] = hl;
! #ifdef FEAT_MBYTE
  		if (enc_utf8)
  		{
  		    if (c >= 0x80)
***************
*** 6435,6446 ****
  		    else
  			ScreenLinesUC[off_to] = 0;
  		}
! # endif
  		screen_char(off_to, row, col + coloff);
  	    }
  	}
  	else
- #endif
  	    LineWraps[row] = FALSE;
      }
  }
--- 6378,6388 ----
  		    else
  			ScreenLinesUC[off_to] = 0;
  		}
! #endif
  		screen_char(off_to, row, col + coloff);
  	    }
  	}
  	else
  	    LineWraps[row] = FALSE;
      }
  }
***************
*** 6465,6471 ****
  }
  #endif
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * mark all status lines for redraw; used after first :cd
   */
--- 6407,6412 ----
***************
*** 6512,6520 ****
      if (redraw_tabline)
  	draw_tabline();
  }
- #endif
  
! #if (defined(FEAT_WILDMENU) && defined(FEAT_WINDOWS)) || defined(PROTO)
  /*
   * Redraw all status lines at the bottom of frame "frp".
   */
--- 6453,6460 ----
      if (redraw_tabline)
  	draw_tabline();
  }
  
! #if defined(FEAT_WILDMENU) || defined(PROTO)
  /*
   * Redraw all status lines at the bottom of frame "frp".
   */
***************
*** 6538,6544 ****
  }
  #endif
  
- #ifdef FEAT_WINDOWS
  /*
   * Draw the verticap separator right of window "wp" starting with line "row".
   */
--- 6478,6483 ----
***************
*** 6557,6563 ****
  		c, ' ', hl);
      }
  }
- #endif
  
  #ifdef FEAT_WILDMENU
  static int status_match_len(expand_T *xp, char_u *s);
--- 6496,6501 ----
***************
*** 6831,6846 ****
  	screen_fill(row, row + 1, clen, (int)Columns, fillchar, fillchar, attr);
      }
  
- #ifdef FEAT_WINDOWS
      win_redraw_last_status(topframe);
- #else
-     lastwin->w_redr_status = TRUE;
- #endif
      vim_free(buf);
  }
  #endif
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * Redraw the status line of window wp.
   *
--- 6769,6779 ----
***************
*** 7060,7068 ****
      return FALSE;
  }
  
- #endif /* FEAT_WINDOWS */
  
- #if defined(FEAT_WINDOWS) || defined(FEAT_STL_OPT) || defined(PROTO)
  /*
   * Get the value to show for the language mappings, active 'keymap'.
   */
--- 6993,6999 ----
***************
*** 7110,7116 ****
      }
      return buf[0] != NUL;
  }
- #endif
  
  #if defined(FEAT_STL_OPT) || defined(PROTO)
  /*
--- 7041,7046 ----
***************
*** 7181,7199 ****
  		if (*stl++ != '(')
  		    stl = p_ruf;
  	    }
- #ifdef FEAT_WINDOWS
  	    col = ru_col - (Columns - W_WIDTH(wp));
  	    if (col < (W_WIDTH(wp) + 1) / 2)
  		col = (W_WIDTH(wp) + 1) / 2;
- #else
- 	    col = ru_col;
- 	    if (col > (Columns + 1) / 2)
- 		col = (Columns + 1) / 2;
- #endif
  	    maxwidth = W_WIDTH(wp) - col;
- #ifdef FEAT_WINDOWS
  	    if (!wp->w_status_height)
- #endif
  	    {
  		row = Rows - 1;
  		--maxwidth;	/* writing in last column may cause scrolling */
--- 7111,7121 ----
***************
*** 7217,7225 ****
  # endif
  	}
  
- #ifdef FEAT_WINDOWS
  	col += W_WINCOL(wp);
- #endif
      }
  
      if (maxwidth <= 0)
--- 7139,7145 ----
***************
*** 7277,7294 ****
  	    curattr = attr;
  	else if (hltab[n].userhl < 0)
  	    curattr = syn_id2attr(-hltab[n].userhl);
! #ifdef FEAT_WINDOWS
! # ifdef FEAT_TERMINAL
  	else if (wp != NULL && wp != curwin && bt_terminal(wp->w_buffer)
  						   && wp->w_status_height != 0)
  	    curattr = highlight_stltermnc[hltab[n].userhl - 1];
  	else if (wp != NULL && bt_terminal(wp->w_buffer)
  						   && wp->w_status_height != 0)
  	    curattr = highlight_stlterm[hltab[n].userhl - 1];
! # endif
  	else if (wp != NULL && wp != curwin && wp->w_status_height != 0)
  	    curattr = highlight_stlnc[hltab[n].userhl - 1];
- #endif
  	else
  	    curattr = highlight_user[hltab[n].userhl - 1];
      }
--- 7197,7212 ----
  	    curattr = attr;
  	else if (hltab[n].userhl < 0)
  	    curattr = syn_id2attr(-hltab[n].userhl);
! #ifdef FEAT_TERMINAL
  	else if (wp != NULL && wp != curwin && bt_terminal(wp->w_buffer)
  						   && wp->w_status_height != 0)
  	    curattr = highlight_stltermnc[hltab[n].userhl - 1];
  	else if (wp != NULL && bt_terminal(wp->w_buffer)
  						   && wp->w_status_height != 0)
  	    curattr = highlight_stlterm[hltab[n].userhl - 1];
! #endif
  	else if (wp != NULL && wp != curwin && wp->w_status_height != 0)
  	    curattr = highlight_stlnc[hltab[n].userhl - 1];
  	else
  	    curattr = highlight_user[hltab[n].userhl - 1];
      }
***************
*** 8326,8336 ****
      /*
       * Stop highlighting first, so it's easier to move the cursor.
       */
- #if defined(FEAT_CLIPBOARD) || defined(FEAT_WINDOWS)
      if (screen_char_attr != 0)
  	attr = screen_char_attr;
      else
- #endif
  	attr = ScreenAttrs[off];
      if (screen_attr != attr)
  	screen_stop_highlight();
--- 8244,8252 ----
***************
*** 8403,8409 ****
  }
  #endif
  
- #if defined(FEAT_CLIPBOARD) || defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * Draw a rectangle of the screen, inverted when "invert" is TRUE.
   * This uses the contents of ScreenLines[] and doesn't change it.
--- 8319,8324 ----
***************
*** 8455,8463 ****
      }
      screen_char_attr = 0;
  }
- #endif
  
- #ifdef FEAT_WINDOWS
  /*
   * Redraw the characters for a vertically split window.
   */
--- 8370,8376 ----
***************
*** 8483,8489 ****
      }
      screen_draw_rectangle(row, col, end - row, width, FALSE);
  }
- #endif
  
  /*
   * Fill the screen from 'start_row' to 'end_row', from 'start_col' to 'end_col'
--- 8396,8401 ----
***************
*** 8742,8751 ****
      sattr_T	    *new_ScreenAttrs;
      unsigned	    *new_LineOffset;
      char_u	    *new_LineWraps;
- #ifdef FEAT_WINDOWS
      short	    *new_TabPageIdxs;
      tabpage_T	    *tp;
- #endif
      static int	    entered = FALSE;		/* avoid recursiveness */
      static int	    done_outofmem_msg = FALSE;	/* did outofmem message */
  #ifdef FEAT_AUTOCMD
--- 8654,8661 ----
***************
*** 8830,8847 ****
      new_LineOffset = (unsigned *)lalloc((long_u)(
  					 Rows * sizeof(unsigned)), FALSE);
      new_LineWraps = (char_u *)lalloc((long_u)(Rows * sizeof(char_u)), FALSE);
- #ifdef FEAT_WINDOWS
      new_TabPageIdxs = (short *)lalloc((long_u)(Columns * sizeof(short)), FALSE);
- #endif
  
      FOR_ALL_TAB_WINDOWS(tp, wp)
      {
  	if (win_alloc_lines(wp) == FAIL)
  	{
  	    outofmem = TRUE;
- #ifdef FEAT_WINDOWS
  	    goto give_up;
- #endif
  	}
      }
  #ifdef FEAT_AUTOCMD
--- 8740,8753 ----
***************
*** 8849,8857 ****
  					&& win_alloc_lines(aucmd_win) == FAIL)
  	outofmem = TRUE;
  #endif
- #ifdef FEAT_WINDOWS
  give_up:
- #endif
  
  #ifdef FEAT_MBYTE
      for (i = 0; i < p_mco; ++i)
--- 8755,8761 ----
***************
*** 8866,8874 ****
  	    || new_ScreenAttrs == NULL
  	    || new_LineOffset == NULL
  	    || new_LineWraps == NULL
- #ifdef FEAT_WINDOWS
  	    || new_TabPageIdxs == NULL
- #endif
  	    || outofmem)
      {
  	if (ScreenLines != NULL || !done_outofmem_msg)
--- 8770,8776 ----
***************
*** 8899,8908 ****
  	new_LineOffset = NULL;
  	vim_free(new_LineWraps);
  	new_LineWraps = NULL;
- #ifdef FEAT_WINDOWS
  	vim_free(new_TabPageIdxs);
  	new_TabPageIdxs = NULL;
- #endif
      }
      else
      {
--- 8801,8808 ----
***************
*** 8996,9004 ****
      ScreenAttrs = new_ScreenAttrs;
      LineOffset = new_LineOffset;
      LineWraps = new_LineWraps;
- #ifdef FEAT_WINDOWS
      TabPageIdxs = new_TabPageIdxs;
- #endif
  
      /* It's important that screen_Rows and screen_Columns reflect the actual
       * size of ScreenLines[].  Set them before calling anything. */
--- 8896,8902 ----
***************
*** 9065,9073 ****
      vim_free(ScreenAttrs);
      vim_free(LineOffset);
      vim_free(LineWraps);
- #ifdef FEAT_WINDOWS
      vim_free(TabPageIdxs);
- #endif
  }
  
      void
--- 8963,8969 ----
***************
*** 9126,9134 ****
  
      win_rest_invalid(firstwin);
      redraw_cmdline = TRUE;
- #ifdef FEAT_WINDOWS
      redraw_tabline = TRUE;
- #endif
      if (must_redraw == CLEAR)	/* no need to clear again */
  	must_redraw = NOT_VALID;
      compute_cmdrow();
--- 9022,9028 ----
***************
*** 9165,9171 ****
      (void)vim_memset(ScreenAttrs + off, -1, (size_t)width * sizeof(sattr_T));
  }
  
- #ifdef FEAT_WINDOWS
  /*
   * Copy part of a Screenline for vertically split window "wp".
   */
--- 9059,9064 ----
***************
*** 9177,9183 ****
  
      mch_memmove(ScreenLines + off_to, ScreenLines + off_from,
  	    wp->w_width * sizeof(schar_T));
! # ifdef FEAT_MBYTE
      if (enc_utf8)
      {
  	int	i;
--- 9070,9076 ----
  
      mch_memmove(ScreenLines + off_to, ScreenLines + off_from,
  	    wp->w_width * sizeof(schar_T));
! #ifdef FEAT_MBYTE
      if (enc_utf8)
      {
  	int	i;
***************
*** 9191,9201 ****
      if (enc_dbcs == DBCS_JPNU)
  	mch_memmove(ScreenLines2 + off_to, ScreenLines2 + off_from,
  		wp->w_width * sizeof(schar_T));
! # endif
      mch_memmove(ScreenAttrs + off_to, ScreenAttrs + off_from,
  	    wp->w_width * sizeof(sattr_T));
  }
- #endif
  
  /*
   * Return TRUE if clearing with term string "p" would work.
--- 9084,9093 ----
      if (enc_dbcs == DBCS_JPNU)
  	mch_memmove(ScreenLines2 + off_to, ScreenLines2 + off_from,
  		wp->w_width * sizeof(schar_T));
! #endif
      mch_memmove(ScreenAttrs + off_to, ScreenAttrs + off_from,
  	    wp->w_width * sizeof(sattr_T));
  }
  
  /*
   * Return TRUE if clearing with term string "p" would work.
***************
*** 9549,9555 ****
       * messing up those windows, better just redraw.
       */
      did_delete = FALSE;
- #ifdef FEAT_WINDOWS
      if (wp->w_next != NULL || wp->w_status_height)
      {
  	if (screen_del_lines(0, W_WINROW(wp) + wp->w_height - line_count,
--- 9441,9446 ----
***************
*** 9558,9572 ****
  	else if (wp->w_next)
  	    return FAIL;
      }
- #endif
      /*
       * if no lines deleted, blank the lines that will end up below the window
       */
      if (!did_delete)
      {
- #ifdef FEAT_WINDOWS
  	wp->w_redr_status = TRUE;
- #endif
  	redraw_cmdline = TRUE;
  	nextrow = W_WINROW(wp) + wp->w_height + W_STATUS_HEIGHT(wp);
  	lastrow = nextrow + line_count;
--- 9449,9460 ----
***************
*** 9583,9591 ****
  	    /* deletion will have messed up other windows */
  	if (did_delete)
  	{
- #ifdef FEAT_WINDOWS
  	    wp->w_redr_status = TRUE;
- #endif
  	    win_rest_invalid(W_NEXT(wp));
  	}
  	return FAIL;
--- 9471,9477 ----
***************
*** 9626,9632 ****
  				   (int)Rows, FALSE, clear_attr, NULL) == FAIL)
  	return FAIL;
  
- #ifdef FEAT_WINDOWS
      /*
       * If there are windows or status lines below, try to put them at the
       * correct place. If we can't do that, they have to be redrawn.
--- 9512,9517 ----
***************
*** 9645,9651 ****
       * command line later.
       */
      else
- #endif
  	redraw_cmdline = TRUE;
      return OK;
  }
--- 9530,9535 ----
***************
*** 9675,9685 ****
  	return FAIL;
  
      /* only a few lines left: redraw is faster */
!     if (mayclear && Rows - line_count < 5
! #ifdef FEAT_WINDOWS
! 	    && wp->w_width == Columns
! #endif
! 	    )
      {
  	if (!no_win_do_lines_ins)
  	    screenclear();	    /* will set wp->w_lines_valid to 0 */
--- 9559,9565 ----
  	return FAIL;
  
      /* only a few lines left: redraw is faster */
!     if (mayclear && Rows - line_count < 5 && wp->w_width == Columns)
      {
  	if (!no_win_do_lines_ins)
  	    screenclear();	    /* will set wp->w_lines_valid to 0 */
***************
*** 9714,9728 ****
       * a character in the lower right corner of the scroll region may cause a
       * scroll-up .
       */
!     if (scroll_region
! #ifdef FEAT_WINDOWS
! 	    || W_WIDTH(wp) != Columns
! #endif
! 	    )
      {
- #ifdef FEAT_WINDOWS
  	if (scroll_region && (wp->w_width == Columns || *T_CSV != NUL))
- #endif
  	    scroll_region_set(wp, row);
  	if (del)
  	    retval = screen_del_lines(W_WINROW(wp) + row, 0, line_count,
--- 9594,9602 ----
       * a character in the lower right corner of the scroll region may cause a
       * scroll-up .
       */
!     if (scroll_region || W_WIDTH(wp) != Columns)
      {
  	if (scroll_region && (wp->w_width == Columns || *T_CSV != NUL))
  	    scroll_region_set(wp, row);
  	if (del)
  	    retval = screen_del_lines(W_WINROW(wp) + row, 0, line_count,
***************
*** 9730,9746 ****
  	else
  	    retval = screen_ins_lines(W_WINROW(wp) + row, 0, line_count,
  					   wp->w_height - row, clear_attr, wp);
- #ifdef FEAT_WINDOWS
  	if (scroll_region && (wp->w_width == Columns || *T_CSV != NUL))
- #endif
  	    scroll_region_reset();
  	return retval;
      }
  
- #ifdef FEAT_WINDOWS
      if (wp->w_next != NULL && p_tf) /* don't delete/insert on fast terminal */
  	return FAIL;
- #endif
  
      return MAYBE;
  }
--- 9604,9616 ----
***************
*** 9751,9767 ****
      static void
  win_rest_invalid(win_T *wp)
  {
- #ifdef FEAT_WINDOWS
      while (wp != NULL)
- #else
-     if (wp != NULL)
- #endif
      {
  	redraw_win_later(wp, NOT_VALID);
- #ifdef FEAT_WINDOWS
  	wp->w_redr_status = TRUE;
  	wp = wp->w_next;
- #endif
      }
      redraw_cmdline = TRUE;
  }
--- 9621,9631 ----
***************
*** 9856,9867 ****
       * exists.
       */
      result_empty = (row + line_count >= end);
- #ifdef FEAT_WINDOWS
      if (wp != NULL && wp->w_width != Columns && *T_CSV == NUL)
  	type = USE_REDRAW;
!     else
! #endif
!     if (can_clear(T_CD) && result_empty)
  	type = USE_T_CD;
      else if (*T_CAL != NUL && (line_count > 1 || *T_AL == NUL))
  	type = USE_T_CAL;
--- 9720,9728 ----
       * exists.
       */
      result_empty = (row + line_count >= end);
      if (wp != NULL && wp->w_width != Columns && *T_CSV == NUL)
  	type = USE_REDRAW;
!     else if (can_clear(T_CD) && result_empty)
  	type = USE_T_CD;
      else if (*T_CAL != NUL && (line_count > 1 || *T_AL == NUL))
  	type = USE_T_CAL;
***************
*** 9897,9907 ****
  #ifdef FEAT_CLIPBOARD
      /* Remove a modeless selection when inserting lines halfway the screen
       * or not the full width of the screen. */
!     if (off + row > 0
! # ifdef FEAT_WINDOWS
! 	    || (wp != NULL && wp->w_width != Columns)
! # endif
!        )
  	clip_clear_selection(&clip_star);
      else
  	clip_scroll_selection(-line_count);
--- 9758,9764 ----
  #ifdef FEAT_CLIPBOARD
      /* Remove a modeless selection when inserting lines halfway the screen
       * or not the full width of the screen. */
!     if (off + row > 0 || (wp != NULL && wp->w_width != Columns))
  	clip_clear_selection(&clip_star);
      else
  	clip_scroll_selection(-line_count);
***************
*** 9926,9932 ****
      end += off;
      for (i = 0; i < line_count; ++i)
      {
- #ifdef FEAT_WINDOWS
  	if (wp != NULL && wp->w_width != Columns)
  	{
  	    /* need to copy part of a line */
--- 9783,9788 ----
***************
*** 9942,9948 ****
  	    LineWraps[j] = FALSE;
  	}
  	else
- #endif
  	{
  	    j = end - 1 - i;
  	    temp = LineOffset[j];
--- 9798,9803 ----
***************
*** 9965,9977 ****
      if (clear_attr != 0)
  	screen_start_highlight(clear_attr);
  
- #ifdef FEAT_WINDOWS
      /* redraw the characters */
      if (type == USE_REDRAW)
  	redraw_block(row, end, wp);
!     else
! #endif
! 	if (type == USE_T_CAL)
      {
  	term_append_lines(line_count);
  	screen_start();		/* don't know where cursor is now */
--- 9820,9829 ----
      if (clear_attr != 0)
  	screen_start_highlight(clear_attr);
  
      /* redraw the characters */
      if (type == USE_REDRAW)
  	redraw_block(row, end, wp);
!     else if (type == USE_T_CAL)
      {
  	term_append_lines(line_count);
  	screen_start();		/* don't know where cursor is now */
***************
*** 10081,10092 ****
       * 5. Use T_DL (delete line) if it exists.
       * 6. redraw the characters from ScreenLines[].
       */
- #ifdef FEAT_WINDOWS
      if (wp != NULL && wp->w_width != Columns && *T_CSV == NUL)
  	type = USE_REDRAW;
!     else
! #endif
!     if (can_clear(T_CD) && result_empty)
  	type = USE_T_CD;
  #if defined(__BEOS__) && defined(BEOS_DR8)
      /*
--- 9933,9941 ----
       * 5. Use T_DL (delete line) if it exists.
       * 6. redraw the characters from ScreenLines[].
       */
      if (wp != NULL && wp->w_width != Columns && *T_CSV == NUL)
  	type = USE_REDRAW;
!     else if (can_clear(T_CD) && result_empty)
  	type = USE_T_CD;
  #if defined(__BEOS__) && defined(BEOS_DR8)
      /*
***************
*** 10113,10122 ****
      else if (*T_CDL != NUL && line_count > 1 && can_delete)
  	type = USE_T_CDL;
      else if (can_clear(T_CE) && result_empty
! #ifdef FEAT_WINDOWS
! 	    && (wp == NULL || wp->w_width == Columns)
! #endif
! 	    )
  	type = USE_T_CE;
      else if (*T_DL != NUL && can_delete)
  	type = USE_T_DL;
--- 9962,9968 ----
      else if (*T_CDL != NUL && line_count > 1 && can_delete)
  	type = USE_T_CDL;
      else if (can_clear(T_CE) && result_empty
! 	    && (wp == NULL || wp->w_width == Columns))
  	type = USE_T_CE;
      else if (*T_DL != NUL && can_delete)
  	type = USE_T_DL;
***************
*** 10128,10138 ****
  #ifdef FEAT_CLIPBOARD
      /* Remove a modeless selection when deleting lines halfway the screen or
       * not the full width of the screen. */
!     if (off + row > 0
! # ifdef FEAT_WINDOWS
! 	    || (wp != NULL && wp->w_width != Columns)
! # endif
!        )
  	clip_clear_selection(&clip_star);
      else
  	clip_scroll_selection(line_count);
--- 9974,9980 ----
  #ifdef FEAT_CLIPBOARD
      /* Remove a modeless selection when deleting lines halfway the screen or
       * not the full width of the screen. */
!     if (off + row > 0 || (wp != NULL && wp->w_width != Columns))
  	clip_clear_selection(&clip_star);
      else
  	clip_scroll_selection(line_count);
***************
*** 10164,10170 ****
      end += off;
      for (i = 0; i < line_count; ++i)
      {
- #ifdef FEAT_WINDOWS
  	if (wp != NULL && wp->w_width != Columns)
  	{
  	    /* need to copy part of a line */
--- 10006,10011 ----
***************
*** 10180,10186 ****
  	    LineWraps[j] = FALSE;
  	}
  	else
- #endif
  	{
  	    /* whole width, moving the line pointers is faster */
  	    j = row + i;
--- 10021,10026 ----
***************
*** 10204,10216 ****
      if (clear_attr != 0)
  	screen_start_highlight(clear_attr);
  
- #ifdef FEAT_WINDOWS
      /* redraw the characters */
      if (type == USE_REDRAW)
  	redraw_block(row, end, wp);
!     else
! #endif
! 	if (type == USE_T_CD)	/* delete the lines */
      {
  	windgoto(cursor_row, 0);
  	out_str(T_CD);
--- 10044,10053 ----
      if (clear_attr != 0)
  	screen_start_highlight(clear_attr);
  
      /* redraw the characters */
      if (type == USE_REDRAW)
  	redraw_block(row, end, wp);
!     else if (type == USE_T_CD)	/* delete the lines */
      {
  	windgoto(cursor_row, 0);
  	out_str(T_CD);
***************
*** 10487,10497 ****
  
      /* If the last window has no status line, the ruler is after the mode
       * message and must be redrawn */
!     if (redrawing()
! # ifdef FEAT_WINDOWS
! 	    && lastwin->w_status_height == 0
! # endif
!        )
  	win_redr_ruler(lastwin, TRUE);
  #endif
      redraw_cmdline = FALSE;
--- 10324,10330 ----
  
      /* If the last window has no status line, the ruler is after the mode
       * message and must be redrawn */
!     if (redrawing() && lastwin->w_status_height == 0)
  	win_redr_ruler(lastwin, TRUE);
  #endif
      redraw_cmdline = FALSE;
***************
*** 10551,10557 ****
      }
  }
  
- #if defined(FEAT_WINDOWS)
  /*
   * Draw the tab pages line at the top of the Vim window.
   */
--- 10384,10389 ----
***************
*** 10754,10762 ****
  	home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);
      trans_characters(NameBuff, MAXPATHL);
  }
- #endif
  
- #if defined(FEAT_WINDOWS) || defined(FEAT_WILDMENU) || defined(FEAT_STL_OPT)
  /*
   * Get the character to use in a status line.  Get its attributes in "*attr".
   */
--- 10586,10592 ----
***************
*** 10802,10810 ****
  	return '^';
      return '=';
  }
- #endif
  
- #ifdef FEAT_WINDOWS
  /*
   * Get the character to use in a separator between vertically split windows.
   * Get its attributes in "*attr".
--- 10632,10638 ----
***************
*** 10818,10824 ****
      else
  	return fill_vert;
  }
- #endif
  
  /*
   * Return TRUE if redrawing should currently be done.
--- 10646,10651 ----
***************
*** 10856,10869 ****
  #ifdef FEAT_INS_EXPAND
      if (pum_visible())
      {
- # ifdef FEAT_WINDOWS
  	/* Don't redraw right now, do it later. */
  	curwin->w_redr_status = TRUE;
- # endif
  	return;
      }
  #endif
! #if defined(FEAT_STL_OPT) && defined(FEAT_WINDOWS)
      if ((*p_stl != NUL || *curwin->w_p_stl != NUL) && curwin->w_status_height)
      {
  	redraw_custom_statusline(curwin);
--- 10683,10694 ----
  #ifdef FEAT_INS_EXPAND
      if (pum_visible())
      {
  	/* Don't redraw right now, do it later. */
  	curwin->w_redr_status = TRUE;
  	return;
      }
  #endif
! #if defined(FEAT_STL_OPT)
      if ((*p_stl != NUL || *curwin->w_p_stl != NUL) && curwin->w_status_height)
      {
  	redraw_custom_statusline(curwin);
***************
*** 10883,10893 ****
         )
  	maketitle();
  #endif
- #ifdef FEAT_WINDOWS
      /* Redraw the tab pages line if needed. */
      if (redraw_tabline)
  	draw_tabline();
- #endif
  }
  
  #ifdef FEAT_CMDL_INFO
--- 10708,10716 ----
***************
*** 10904,10920 ****
      int		i;
      size_t	len;
      int		o;
- #ifdef FEAT_WINDOWS
      int		this_ru_col;
      int		off = 0;
      int		width = Columns;
- # define WITH_OFF(x) x
- # define WITH_WIDTH(x) x
- #else
- # define WITH_OFF(x) 0
- # define WITH_WIDTH(x) Columns
- # define this_ru_col ru_col
- #endif
  
      /* If 'ruler' off or redrawing disabled, don't do anything */
      if (!p_ru)
--- 10727,10735 ----
***************
*** 10930,10938 ****
  #ifdef FEAT_INS_EXPAND
      /* Don't draw the ruler while doing insert-completion, it might overwrite
       * the (long) mode message. */
- # ifdef FEAT_WINDOWS
      if (wp == lastwin && lastwin->w_status_height == 0)
- # endif
  	if (edit_submode != NULL)
  	    return;
      /* Don't draw the ruler when the popup menu is visible, it may overlap. */
--- 10745,10751 ----
***************
*** 10982,10988 ****
  	    || empty_line != wp->w_ru_empty)
      {
  	cursor_off();
- #ifdef FEAT_WINDOWS
  	if (wp->w_status_height)
  	{
  	    row = W_WINROW(wp) + wp->w_height;
--- 10795,10800 ----
***************
*** 10991,11005 ****
  	    width = W_WIDTH(wp);
  	}
  	else
- #endif
  	{
  	    row = Rows - 1;
  	    fillchar = ' ';
  	    attr = 0;
- #ifdef FEAT_WINDOWS
  	    width = Columns;
  	    off = 0;
- #endif
  	}
  
  	/* In list mode virtcol needs to be recomputed */
--- 10803,10814 ----
***************
*** 11032,11054 ****
  	i = (int)STRLEN(buffer);
  	get_rel_pos(wp, buffer + i + 1, RULER_BUF_LEN - i - 1);
  	o = i + vim_strsize(buffer + i + 1);
- #ifdef FEAT_WINDOWS
  	if (wp->w_status_height == 0)	/* can't use last char of screen */
- #endif
  	    ++o;
- #ifdef FEAT_WINDOWS
  	this_ru_col = ru_col - (Columns - width);
  	if (this_ru_col < 0)
  	    this_ru_col = 0;
- #endif
  	/* Never use more than half the window/screen width, leave the other
  	 * half for the filename. */
! 	if (this_ru_col < (WITH_WIDTH(width) + 1) / 2)
! 	    this_ru_col = (WITH_WIDTH(width) + 1) / 2;
! 	if (this_ru_col + o < WITH_WIDTH(width))
  	{
  	    /* need at least 3 chars left for get_rel_pos() + NUL */
! 	    while (this_ru_col + o < WITH_WIDTH(width) && RULER_BUF_LEN > i + 4)
  	    {
  #ifdef FEAT_MBYTE
  		if (has_mbyte)
--- 10841,10859 ----
  	i = (int)STRLEN(buffer);
  	get_rel_pos(wp, buffer + i + 1, RULER_BUF_LEN - i - 1);
  	o = i + vim_strsize(buffer + i + 1);
  	if (wp->w_status_height == 0)	/* can't use last char of screen */
  	    ++o;
  	this_ru_col = ru_col - (Columns - width);
  	if (this_ru_col < 0)
  	    this_ru_col = 0;
  	/* Never use more than half the window/screen width, leave the other
  	 * half for the filename. */
! 	if (this_ru_col < (width + 1) / 2)
! 	    this_ru_col = (width + 1) / 2;
! 	if (this_ru_col + o < width)
  	{
  	    /* need at least 3 chars left for get_rel_pos() + NUL */
! 	    while (this_ru_col + o < width && RULER_BUF_LEN > i + 4)
  	    {
  #ifdef FEAT_MBYTE
  		if (has_mbyte)
***************
*** 11068,11074 ****
  	    for (i = 0; buffer[i] != NUL; i += (*mb_ptr2len)(buffer + i))
  	    {
  		o += (*mb_ptr2cells)(buffer + i);
! 		if (this_ru_col + o > WITH_WIDTH(width))
  		{
  		    buffer[i] = NUL;
  		    break;
--- 10873,10879 ----
  	    for (i = 0; buffer[i] != NUL; i += (*mb_ptr2len)(buffer + i))
  	    {
  		o += (*mb_ptr2cells)(buffer + i);
! 		if (this_ru_col + o > width)
  		{
  		    buffer[i] = NUL;
  		    break;
***************
*** 11077,11090 ****
  	}
  	else
  #endif
! 	if (this_ru_col + (int)STRLEN(buffer) > WITH_WIDTH(width))
! 	    buffer[WITH_WIDTH(width) - this_ru_col] = NUL;
  
! 	screen_puts(buffer, row, this_ru_col + WITH_OFF(off), attr);
  	i = redraw_cmdline;
  	screen_fill(row, row + 1,
! 		this_ru_col + WITH_OFF(off) + (int)STRLEN(buffer),
! 		(int)(WITH_OFF(off) + WITH_WIDTH(width)),
  		fillchar, fillchar, attr);
  	/* don't redraw the cmdline because of showing the ruler */
  	redraw_cmdline = i;
--- 10882,10895 ----
  	}
  	else
  #endif
! 	if (this_ru_col + (int)STRLEN(buffer) > width)
! 	    buffer[width - this_ru_col] = NUL;
  
! 	screen_puts(buffer, row, this_ru_col + off, attr);
  	i = redraw_cmdline;
  	screen_fill(row, row + 1,
! 		this_ru_col + off + (int)STRLEN(buffer),
! 		(int)(off + width),
  		fillchar, fillchar, attr);
  	/* don't redraw the cmdline because of showing the ruler */
  	redraw_cmdline = i;
*** ../vim-8.0.1117/src/search.c	2017-07-23 22:01:43.063625375 +0200
--- src/search.c	2017-09-16 20:20:12.619004896 +0200
***************
*** 4906,4912 ****
      char_u	*already = NULL;
      char_u	*startp = NULL;
      char_u	*inc_opt = NULL;
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      win_T	*curwin_save = NULL;
  #endif
  
--- 4906,4912 ----
      char_u	*already = NULL;
      char_u	*startp = NULL;
      char_u	*inc_opt = NULL;
! #if defined(FEAT_QUICKFIX)
      win_T	*curwin_save = NULL;
  #endif
  
***************
*** 5385,5391 ****
  	    {
  		found = TRUE;
  		if (depth == -1 && lnum == curwin->w_cursor.lnum
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  						      && g_do_tagpreview == 0
  #endif
  						      )
--- 5385,5391 ----
  	    {
  		found = TRUE;
  		if (depth == -1 && lnum == curwin->w_cursor.lnum
! #if defined(FEAT_QUICKFIX)
  						      && g_do_tagpreview == 0
  #endif
  						      )
***************
*** 5402,5408 ****
  #ifdef FEAT_GUI
  		    need_mouse_correct = TRUE;
  #endif
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  		    /* ":psearch" uses the preview window */
  		    if (g_do_tagpreview != 0)
  		    {
--- 5402,5408 ----
  #ifdef FEAT_GUI
  		    need_mouse_correct = TRUE;
  #endif
! #if defined(FEAT_QUICKFIX)
  		    /* ":psearch" uses the preview window */
  		    if (g_do_tagpreview != 0)
  		    {
***************
*** 5412,5427 ****
  #endif
  		    if (action == ACTION_SPLIT)
  		    {
- #ifdef FEAT_WINDOWS
  			if (win_split(0, 0) == FAIL)
- #endif
  			    break;
  			RESET_BINDING(curwin);
  		    }
  		    if (depth == -1)
  		    {
  			/* match in current file */
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  			if (g_do_tagpreview != 0)
  			{
  			    if (!GETFILE_SUCCESS(getfile(
--- 5412,5425 ----
  #endif
  		    if (action == ACTION_SPLIT)
  		    {
  			if (win_split(0, 0) == FAIL)
  			    break;
  			RESET_BINDING(curwin);
  		    }
  		    if (depth == -1)
  		    {
  			/* match in current file */
! #if defined(FEAT_QUICKFIX)
  			if (g_do_tagpreview != 0)
  			{
  			    if (!GETFILE_SUCCESS(getfile(
***************
*** 5452,5458 ****
  		    curwin->w_set_curswant = TRUE;
  		}
  
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  		if (g_do_tagpreview != 0
  			   && curwin != curwin_save && win_valid(curwin_save))
  		{
--- 5450,5456 ----
  		    curwin->w_set_curswant = TRUE;
  		}
  
! #if defined(FEAT_QUICKFIX)
  		if (g_do_tagpreview != 0
  			   && curwin != curwin_save && win_valid(curwin_save))
  		{
*** ../vim-8.0.1117/src/spell.c	2017-09-02 20:30:31.171314990 +0200
--- src/spell.c	2017-09-16 20:20:23.942936620 +0200
***************
*** 2920,2928 ****
  		if (wp->w_p_spell)
  		{
  		    (void)did_set_spelllang(wp);
- # ifdef FEAT_WINDOWS
  		    break;
- # endif
  		}
  	}
      }
--- 2920,2926 ----
*** ../vim-8.0.1117/src/syntax.c	2017-09-14 00:00:40.438687520 +0200
--- src/syntax.c	2017-09-16 20:20:48.834786568 +0200
***************
*** 6887,6896 ****
      CENT("StatusLineNC term=reverse cterm=reverse",
  	 "StatusLineNC term=reverse cterm=reverse gui=reverse"),
      "default link EndOfBuffer NonText",
- #ifdef FEAT_WINDOWS
      CENT("VertSplit term=reverse cterm=reverse",
  	 "VertSplit term=reverse cterm=reverse gui=reverse"),
- #endif
  #ifdef FEAT_CLIPBOARD
      CENT("VisualNOS term=underline,bold cterm=underline,bold",
  	 "VisualNOS term=underline,bold cterm=underline,bold gui=underline,bold"),
--- 6887,6894 ----
***************
*** 6903,6914 ****
      CENT("PmenuSbar ctermbg=Grey",
  	 "PmenuSbar ctermbg=Grey guibg=Grey"),
  #endif
- #ifdef FEAT_WINDOWS
      CENT("TabLineSel term=bold cterm=bold",
  	 "TabLineSel term=bold cterm=bold gui=bold"),
      CENT("TabLineFill term=reverse cterm=reverse",
  	 "TabLineFill term=reverse cterm=reverse gui=reverse"),
- #endif
  #ifdef FEAT_GUI
      "Cursor guibg=fg guifg=bg",
      "lCursor guibg=fg guifg=bg", /* should be different, but what? */
--- 6901,6910 ----
***************
*** 6979,6988 ****
      CENT("DiffDelete term=bold ctermfg=Blue ctermbg=LightCyan",
  	 "DiffDelete term=bold ctermfg=Blue ctermbg=LightCyan gui=bold guifg=Blue guibg=LightCyan"),
  #endif
- #ifdef FEAT_WINDOWS
      CENT("TabLine term=underline cterm=underline ctermfg=black ctermbg=LightGrey",
  	 "TabLine term=underline cterm=underline ctermfg=black ctermbg=LightGrey gui=underline guibg=LightGrey"),
- #endif
  #ifdef FEAT_SYN_HL
      CENT("CursorColumn term=reverse ctermbg=LightGrey",
  	 "CursorColumn term=reverse ctermbg=LightGrey guibg=Grey90"),
--- 6975,6982 ----
***************
*** 7073,7082 ****
      CENT("DiffDelete term=bold ctermfg=Blue ctermbg=DarkCyan",
  	 "DiffDelete term=bold ctermfg=Blue ctermbg=DarkCyan gui=bold guifg=Blue guibg=DarkCyan"),
  #endif
- #ifdef FEAT_WINDOWS
      CENT("TabLine term=underline cterm=underline ctermfg=white ctermbg=DarkGrey",
  	 "TabLine term=underline cterm=underline ctermfg=white ctermbg=DarkGrey gui=underline guibg=DarkGrey"),
- #endif
  #ifdef FEAT_SYN_HL
      CENT("CursorColumn term=reverse ctermbg=DarkGrey",
  	 "CursorColumn term=reverse ctermbg=DarkGrey guibg=Grey40"),
--- 7067,7074 ----
*** ../vim-8.0.1117/src/tag.c	2017-06-17 18:44:17.002000920 +0200
--- src/tag.c	2017-09-16 20:22:14.682269235 +0200
***************
*** 80,86 ****
  
  static char_u	*tagmatchname = NULL;	/* name of last used tag */
  
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  /*
   * Tag for preview window is remembered separately, to avoid messing up the
   * normal tagstack.
--- 80,86 ----
  
  static char_u	*tagmatchname = NULL;	/* name of last used tag */
  
! #if defined(FEAT_QUICKFIX)
  /*
   * Tag for preview window is remembered separately, to avoid messing up the
   * normal tagstack.
***************
*** 188,194 ****
      {
  	use_tagstack = FALSE;
  	new_tag = TRUE;
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  	if (g_do_tagpreview != 0)
  	{
  	    vim_free(ptag_entry.tagname);
--- 188,194 ----
      {
  	use_tagstack = FALSE;
  	new_tag = TRUE;
! #if defined(FEAT_QUICKFIX)
  	if (g_do_tagpreview != 0)
  	{
  	    vim_free(ptag_entry.tagname);
***************
*** 199,205 ****
      }
      else
      {
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  	if (g_do_tagpreview != 0)
  	    use_tagstack = FALSE;
  	else
--- 199,205 ----
      }
      else
      {
! #if defined(FEAT_QUICKFIX)
  	if (g_do_tagpreview != 0)
  	    use_tagstack = FALSE;
  	else
***************
*** 217,223 ****
  #endif
  		    ))
  	{
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  	    if (g_do_tagpreview != 0)
  	    {
  		if (ptag_entry.tagname != NULL
--- 217,223 ----
  #endif
  		    ))
  	{
! #if defined(FEAT_QUICKFIX)
  	    if (g_do_tagpreview != 0)
  	    {
  		if (ptag_entry.tagname != NULL
***************
*** 273,279 ****
  	else
  	{
  	    if (
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  		    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :
  #endif
  		    tagstacklen == 0)
--- 273,279 ----
  	else
  	{
  	    if (
! #if defined(FEAT_QUICKFIX)
  		    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :
  #endif
  		    tagstacklen == 0)
***************
*** 356,362 ****
  #endif
  	       )
  	    {
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  		if (g_do_tagpreview != 0)
  		{
  		    cur_match = ptag_entry.cur_match;
--- 356,362 ----
  #endif
  	       )
  	    {
! #if defined(FEAT_QUICKFIX)
  		if (g_do_tagpreview != 0)
  		{
  		    cur_match = ptag_entry.cur_match;
***************
*** 394,400 ****
  		/* Save index for when selection is cancelled. */
  		prevtagstackidx = tagstackidx;
  
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  		if (g_do_tagpreview != 0)
  		{
  		    cur_match = ptag_entry.cur_match;
--- 394,400 ----
  		/* Save index for when selection is cancelled. */
  		prevtagstackidx = tagstackidx;
  
! #if defined(FEAT_QUICKFIX)
  		if (g_do_tagpreview != 0)
  		{
  		    cur_match = ptag_entry.cur_match;
***************
*** 432,438 ****
  	    }
  	}
  
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  	if (g_do_tagpreview != 0)
  	{
  	    if (type != DT_SELECT && type != DT_JUMP)
--- 432,438 ----
  	    }
  	}
  
! #if defined(FEAT_QUICKFIX)
  	if (g_do_tagpreview != 0)
  	{
  	    if (type != DT_SELECT && type != DT_JUMP)
***************
*** 487,493 ****
  	 */
  	if (use_tagstack)
  	    name = tagstack[tagstackidx].tagname;
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  	else if (g_do_tagpreview != 0)
  	    name = ptag_entry.tagname;
  #endif
--- 487,493 ----
  	 */
  	if (use_tagstack)
  	    name = tagstack[tagstackidx].tagname;
! #if defined(FEAT_QUICKFIX)
  	else if (g_do_tagpreview != 0)
  	    name = ptag_entry.tagname;
  #endif
***************
*** 567,573 ****
  	{
  	    if (verbose)
  		EMSG2(_("E426: tag not found: %s"), name);
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  	    g_do_tagpreview = 0;
  #endif
  	}
--- 567,573 ----
  	{
  	    if (verbose)
  		EMSG2(_("E426: tag not found: %s"), name);
! #if defined(FEAT_QUICKFIX)
  	    g_do_tagpreview = 0;
  #endif
  	}
***************
*** 614,620 ****
  		{
  		    parse_match(matches[i], &tagp);
  		    if (!new_tag && (
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  				(g_do_tagpreview != 0
  				 && i == ptag_entry.cur_match) ||
  #endif
--- 614,620 ----
  		{
  		    parse_match(matches[i], &tagp);
  		    if (!new_tag && (
! #if defined(FEAT_QUICKFIX)
  				(g_do_tagpreview != 0
  				 && i == ptag_entry.cur_match) ||
  #endif
***************
*** 968,974 ****
  		tagstack[tagstackidx].cur_fnum = cur_fnum;
  		++tagstackidx;
  	    }
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  	    else if (g_do_tagpreview != 0)
  	    {
  		ptag_entry.cur_match = cur_match;
--- 968,974 ----
  		tagstack[tagstackidx].cur_fnum = cur_fnum;
  		++tagstackidx;
  	    }
! #if defined(FEAT_QUICKFIX)
  	    else if (g_do_tagpreview != 0)
  	    {
  		ptag_entry.cur_match = cur_match;
***************
*** 1073,1084 ****
      /* Only store the new index when using the tagstack and it's valid. */
      if (use_tagstack && tagstackidx <= curwin->w_tagstacklen)
  	curwin->w_tagstackidx = tagstackidx;
- #ifdef FEAT_WINDOWS
      postponed_split = 0;	/* don't split next time */
  # ifdef FEAT_QUICKFIX
      g_do_tagpreview = 0;	/* don't do tag preview next time */
  # endif
- #endif
  
  #ifdef FEAT_CSCOPE
      return jumped_to_tag;
--- 1073,1082 ----
***************
*** 1952,1957 ****
--- 1950,1956 ----
  #endif
  					)
  	    {
+ 		vim_memset(&tagp, 0, sizeof(tagp));
  		tagp.tagname = lbuf;
  #ifdef FEAT_TAG_ANYWHITE
  		tagp.tagname_end = skiptowhite(lbuf);
***************
*** 1998,2014 ****
  		    if (*p == ':')
  		    {
  			if (tagp.fname == NULL)
! #ifdef FEAT_TAG_ANYWHITE
  			    tagp.fname = skipwhite(tagp.tagname_end);
! #else
  			    tagp.fname = tagp.tagname_end + 1;
! #endif
  			if (	   fnamencmp(lbuf, tagp.fname, p - lbuf) == 0
! #ifdef FEAT_TAG_ANYWHITE
  				&& VIM_ISWHITE(tagp.fname[p - lbuf])
! #else
  				&& tagp.fname[p - lbuf] == TAB
! #endif
  				    )
  			{
  			    /* found one */
--- 1997,2013 ----
  		    if (*p == ':')
  		    {
  			if (tagp.fname == NULL)
! # ifdef FEAT_TAG_ANYWHITE
  			    tagp.fname = skipwhite(tagp.tagname_end);
! # else
  			    tagp.fname = tagp.tagname_end + 1;
! # endif
  			if (	   fnamencmp(lbuf, tagp.fname, p - lbuf) == 0
! # ifdef FEAT_TAG_ANYWHITE
  				&& VIM_ISWHITE(tagp.fname[p - lbuf])
! # else
  				&& tagp.fname[p - lbuf] == TAB
! # endif
  				    )
  			{
  			    /* found one */
***************
*** 2619,2625 ****
      do_tag(NULL, DT_FREE, 0, 0, 0);
      tag_freematch();
  
! # if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      if (ptag_entry.tagname)
      {
  	vim_free(ptag_entry.tagname);
--- 2618,2624 ----
      do_tag(NULL, DT_FREE, 0, 0, 0);
      tag_freematch();
  
! # if defined(FEAT_QUICKFIX)
      if (ptag_entry.tagname)
      {
  	vim_free(ptag_entry.tagname);
***************
*** 3093,3099 ****
  #ifdef FEAT_SEARCH_EXTRA
      int		save_no_hlsearch;
  #endif
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      win_T	*curwin_save = NULL;
  #endif
      char_u	*full_fname = NULL;
--- 3092,3098 ----
  #ifdef FEAT_SEARCH_EXTRA
      int		save_no_hlsearch;
  #endif
! #if defined(FEAT_QUICKFIX)
      win_T	*curwin_save = NULL;
  #endif
      char_u	*full_fname = NULL;
***************
*** 3176,3182 ****
      need_mouse_correct = TRUE;
  #endif
  
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      if (g_do_tagpreview != 0)
      {
  	postponed_split = 0;	/* don't split again below */
--- 3175,3181 ----
      need_mouse_correct = TRUE;
  #endif
  
! #if defined(FEAT_QUICKFIX)
      if (g_do_tagpreview != 0)
      {
  	postponed_split = 0;	/* don't split again below */
***************
*** 3240,3248 ****
      {
  	/* A :ta from a help file will keep the b_help flag set.  For ":ptag"
  	 * we need to use the flag from the window where we came from. */
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  	if (g_do_tagpreview != 0)
! 	    keep_help_flag = curwin_save->w_buffer->b_help;
  	else
  #endif
  	    keep_help_flag = curbuf->b_help;
--- 3239,3247 ----
      {
  	/* A :ta from a help file will keep the b_help flag set.  For ":ptag"
  	 * we need to use the flag from the window where we came from. */
! #if defined(FEAT_QUICKFIX)
  	if (g_do_tagpreview != 0)
! 	    keep_help_flag = bt_help(curwin_save->w_buffer);
  	else
  #endif
  	    keep_help_flag = curbuf->b_help;
***************
*** 3254,3262 ****
      if (GETFILE_SUCCESS(getfile_result))	/* got to the right file */
      {
  	curwin->w_set_curswant = TRUE;
- #ifdef FEAT_WINDOWS
  	postponed_split = 0;
- #endif
  
  	save_secure = secure;
  	secure = 1;
--- 3253,3259 ----
***************
*** 3417,3423 ****
  #endif
  	}
  
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
  	if (g_do_tagpreview != 0
  			   && curwin != curwin_save && win_valid(curwin_save))
  	{
--- 3414,3420 ----
  #endif
  	}
  
! #if defined(FEAT_QUICKFIX)
  	if (g_do_tagpreview != 0
  			   && curwin != curwin_save && win_valid(curwin_save))
  	{
***************
*** 3433,3449 ****
      else
      {
  	--RedrawingDisabled;
- #ifdef FEAT_WINDOWS
  	if (postponed_split)		/* close the window */
  	{
  	    win_close(curwin, FALSE);
  	    postponed_split = 0;
  	}
- #endif
      }
  
  erret:
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      g_do_tagpreview = 0; /* For next time */
  #endif
      if (tagp.fname_end != NULL)
--- 3430,3444 ----
      else
      {
  	--RedrawingDisabled;
  	if (postponed_split)		/* close the window */
  	{
  	    win_close(curwin, FALSE);
  	    postponed_split = 0;
  	}
      }
  
  erret:
! #if defined(FEAT_QUICKFIX)
      g_do_tagpreview = 0; /* For next time */
  #endif
      if (tagp.fname_end != NULL)
*** ../vim-8.0.1117/src/term.c	2017-09-11 20:34:09.679146663 +0200
--- src/term.c	2017-09-16 20:23:10.821931077 +0200
***************
*** 196,210 ****
  # ifdef TERMINFO
      {(int)KS_CDL,	IF_EB("\033|%p1%dD", ESC_STR "|%p1%dD")},
      {(int)KS_CS,	IF_EB("\033|%p1%d;%p2%dR", ESC_STR "|%p1%d;%p2%dR")},
- #  ifdef FEAT_WINDOWS
      {(int)KS_CSV,	IF_EB("\033|%p1%d;%p2%dV", ESC_STR "|%p1%d;%p2%dV")},
- #  endif
  # else
      {(int)KS_CDL,	IF_EB("\033|%dD", ESC_STR "|%dD")},
      {(int)KS_CS,	IF_EB("\033|%d;%dR", ESC_STR "|%d;%dR")},
- #  ifdef FEAT_WINDOWS
      {(int)KS_CSV,	IF_EB("\033|%d;%dV", ESC_STR "|%d;%dV")},
- #  endif
  # endif
      {(int)KS_CL,	IF_EB("\033|C", ESC_STR "|C")},
  			/* attributes switched on with 'h', off with * 'H' */
--- 196,206 ----
***************
*** 1121,1132 ****
  #  else
      {(int)KS_CS,	"[%dCS%d]"},
  #  endif
! #  ifdef FEAT_WINDOWS
! #   ifdef TERMINFO
      {(int)KS_CSV,	"[%p1%dCSV%p2%d]"},
! #   else
      {(int)KS_CSV,	"[%dCSV%d]"},
- #   endif
  #  endif
  #  ifdef TERMINFO
      {(int)KS_CAB,	"[CAB%p1%d]"},
--- 1117,1126 ----
  #  else
      {(int)KS_CS,	"[%dCS%d]"},
  #  endif
! #  ifdef TERMINFO
      {(int)KS_CSV,	"[%p1%dCSV%p2%d]"},
! #  else
      {(int)KS_CSV,	"[%dCSV%d]"},
  #  endif
  #  ifdef TERMINFO
      {(int)KS_CAB,	"[CAB%p1%d]"},
***************
*** 3134,3142 ****
      if (old_Columns != Columns)
      {
  	old_Columns = Columns;
- #ifdef FEAT_WINDOWS
  	shell_new_columns();	/* update window sizes */
- #endif
      }
  }
  
--- 3128,3134 ----
***************
*** 3823,3833 ****
  {
      OUT_STR(tgoto((char *)T_CS, W_WINROW(wp) + wp->w_height - 1,
  							 W_WINROW(wp) + off));
- #ifdef FEAT_WINDOWS
      if (*T_CSV != NUL && wp->w_width != Columns)
  	OUT_STR(tgoto((char *)T_CSV, W_WINCOL(wp) + wp->w_width - 1,
  							       W_WINCOL(wp)));
- #endif
      screen_start();		    /* don't know where cursor is now */
  }
  
--- 3815,3823 ----
***************
*** 3838,3847 ****
  scroll_region_reset(void)
  {
      OUT_STR(tgoto((char *)T_CS, (int)Rows - 1, 0));
- #ifdef FEAT_WINDOWS
      if (*T_CSV != NUL)
  	OUT_STR(tgoto((char *)T_CSV, (int)Columns - 1, 0));
- #endif
      screen_start();		    /* don't know where cursor is now */
  }
  
--- 3828,3835 ----
***************
*** 4120,4126 ****
  static int orig_topfill = 0;
  # endif
  #endif
! #if (defined(FEAT_WINDOWS) && defined(CHECK_DOUBLE_CLICK)) || defined(PROTO)
  /*
   * Checking for double clicks ourselves.
   * "orig_topline" is used to avoid detecting a double-click when the window
--- 4108,4114 ----
  static int orig_topfill = 0;
  # endif
  #endif
! #if defined(CHECK_DOUBLE_CLICK) || defined(PROTO)
  /*
   * Checking for double clicks ourselves.
   * "orig_topline" is used to avoid detecting a double-click when the window
***************
*** 5507,5518 ****
  				    && orig_topfill == curwin->w_topfill
  #endif
  				)
- #ifdef FEAT_WINDOWS
  				/* Double click in tab pages line also works
  				 * when window contents changes. */
! 				|| (mouse_row == 0 && firstwin->w_winrow > 0)
! #endif
! 			       )
  			    )
  			++orig_num_clicks;
  		    else
--- 5495,5503 ----
  				    && orig_topfill == curwin->w_topfill
  #endif
  				)
  				/* Double click in tab pages line also works
  				 * when window contents changes. */
! 				|| (mouse_row == 0 && firstwin->w_winrow > 0))
  			    )
  			++orig_num_clicks;
  		    else
*** ../vim-8.0.1117/src/ui.c	2017-09-03 15:48:07.911554536 +0200
--- src/ui.c	2017-09-16 20:24:13.865551471 +0200
***************
*** 2610,2618 ****
      int		which_button)	/* MOUSE_LEFT, MOUSE_RIGHT, MOUSE_MIDDLE */
  {
      static int	on_status_line = 0;	/* #lines below bottom of window */
- #ifdef FEAT_WINDOWS
      static int	on_sep_line = 0;	/* on separator right of window */
- #endif
      static int	prev_row = -1;
      static int	prev_col = -1;
      static win_T *dragwin = NULL;	/* window being dragged */
--- 2610,2616 ----
***************
*** 2650,2659 ****
  	 * line, stop Visual mode */
  	if (on_status_line)
  	    return IN_STATUS_LINE;
- #ifdef FEAT_WINDOWS
  	if (on_sep_line)
  	    return IN_SEP_LINE;
- #endif
  	if (flags & MOUSE_MAY_STOP_VIS)
  	{
  	    end_visual_mode();
--- 2648,2655 ----
***************
*** 2691,2704 ****
  	if (row < 0 || col < 0)			/* check if it makes sense */
  	    return IN_UNKNOWN;
  
- #ifdef FEAT_WINDOWS
  	/* find the window where the row is in */
  	wp = mouse_find_win(&row, &col);
  	if (wp == NULL)
  	    return IN_UNKNOWN;
- #else
- 	wp = firstwin;
- #endif
  	dragwin = NULL;
  	/*
  	 * winpos and height may change in win_enter()!
--- 2687,2696 ----
***************
*** 2710,2716 ****
  	}
  	else
  	    on_status_line = 0;
- #ifdef FEAT_WINDOWS
  	if (col >= wp->w_width)		/* In separator line */
  	{
  	    on_sep_line = col - wp->w_width + 1;
--- 2702,2707 ----
***************
*** 2728,2743 ****
  	    else
  		on_status_line = 0;
  	}
- #endif
  
  	/* Before jumping to another buffer, or moving the cursor for a left
  	 * click, stop Visual mode. */
  	if (VIsual_active
  		&& (wp->w_buffer != curwin->w_buffer
! 		    || (!on_status_line
! #ifdef FEAT_WINDOWS
! 			&& !on_sep_line
! #endif
  #ifdef FEAT_FOLDING
  			&& (
  # ifdef FEAT_RIGHTLEFT
--- 2719,2730 ----
  	    else
  		on_status_line = 0;
  	}
  
  	/* Before jumping to another buffer, or moving the cursor for a left
  	 * click, stop Visual mode. */
  	if (VIsual_active
  		&& (wp->w_buffer != curwin->w_buffer
! 		    || (!on_status_line && !on_sep_line
  #ifdef FEAT_FOLDING
  			&& (
  # ifdef FEAT_RIGHTLEFT
***************
*** 2771,2787 ****
  # endif
  	}
  #endif
- #ifdef FEAT_WINDOWS
  	/* Only change window focus when not clicking on or dragging the
  	 * status line.  Do change focus when releasing the mouse button
  	 * (MOUSE_FOCUS was set above if we dragged first). */
  	if (dragwin == NULL || (flags & MOUSE_RELEASED))
  	    win_enter(wp, TRUE);		/* can make wp invalid! */
! # ifdef CHECK_DOUBLE_CLICK
  	/* set topline, to be able to check for double click ourselves */
  	if (curwin != old_curwin)
  	    set_mouse_topline(curwin);
- # endif
  #endif
  	if (on_status_line)			/* In (or below) status line */
  	{
--- 2758,2772 ----
  # endif
  	}
  #endif
  	/* Only change window focus when not clicking on or dragging the
  	 * status line.  Do change focus when releasing the mouse button
  	 * (MOUSE_FOCUS was set above if we dragged first). */
  	if (dragwin == NULL || (flags & MOUSE_RELEASED))
  	    win_enter(wp, TRUE);		/* can make wp invalid! */
! #ifdef CHECK_DOUBLE_CLICK
  	/* set topline, to be able to check for double click ourselves */
  	if (curwin != old_curwin)
  	    set_mouse_topline(curwin);
  #endif
  	if (on_status_line)			/* In (or below) status line */
  	{
***************
*** 2791,2797 ****
  	    else
  		return IN_STATUS_LINE | CURSOR_MOVED;
  	}
- #ifdef FEAT_WINDOWS
  	if (on_sep_line)			/* In (or below) status line */
  	{
  	    /* Don't use start_arrow() if we're in the same window */
--- 2776,2781 ----
***************
*** 2800,2806 ****
  	    else
  		return IN_SEP_LINE | CURSOR_MOVED;
  	}
- #endif
  
  	curwin->w_cursor.lnum = curwin->w_topline;
  #ifdef FEAT_GUI
--- 2784,2789 ----
***************
*** 2813,2819 ****
      }
      else if (on_status_line && which_button == MOUSE_LEFT)
      {
- #ifdef FEAT_WINDOWS
  	if (dragwin != NULL)
  	{
  	    /* Drag the status line */
--- 2796,2801 ----
***************
*** 2822,2831 ****
  	    win_drag_status_line(dragwin, count);
  	    did_drag |= count;
  	}
- #endif
  	return IN_STATUS_LINE;			/* Cursor didn't move */
      }
- #ifdef FEAT_WINDOWS
      else if (on_sep_line && which_button == MOUSE_LEFT)
      {
  	if (dragwin != NULL)
--- 2804,2811 ----
***************
*** 2838,2844 ****
  	}
  	return IN_SEP_LINE;			/* Cursor didn't move */
      }
- #endif
      else /* keep_window_focus must be TRUE */
      {
  	/* before moving the cursor for a left click, stop Visual mode */
--- 2818,2823 ----
***************
*** 2855,2863 ****
  #endif
  
  	row -= W_WINROW(curwin);
- #ifdef FEAT_WINDOWS
  	col -= W_WINCOL(curwin);
- #endif
  
  	/*
  	 * When clicking beyond the end of the window, scroll the screen.
--- 2834,2840 ----
***************
*** 3100,3106 ****
      return retval;
  }
  
- #if defined(FEAT_WINDOWS) || defined(PROTO)
  /*
   * Find the window at screen position "*rowp" and "*colp".  The positions are
   * updated to become relative to the top-left of the window.
--- 3077,3082 ----
***************
*** 3144,3150 ****
  	    return wp;
      return NULL;
  }
- #endif
  
  #if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_GTK) || defined(FEAT_GUI_MAC) \
  	|| defined(FEAT_GUI_ATHENA) || defined(FEAT_GUI_MSWIN) \
--- 3120,3125 ----
***************
*** 3162,3184 ****
      if (row < 0 || col < 0)		/* check if it makes sense */
  	return IN_UNKNOWN;
  
- #ifdef FEAT_WINDOWS
      /* find the window where the row is in */
      wp = mouse_find_win(&row, &col);
      if (wp == NULL)
  	return IN_UNKNOWN;
- #else
-     wp = firstwin;
- #endif
      /*
       * winpos and height may change in win_enter()!
       */
      if (row >= wp->w_height)	/* In (or below) status line */
  	return IN_STATUS_LINE;
- #ifdef FEAT_WINDOWS
      if (col >= wp->w_width)	/* In vertical separator line */
  	return IN_SEP_LINE;
- #endif
  
      if (wp != curwin)
  	return IN_UNKNOWN;
--- 3137,3153 ----
*** ../vim-8.0.1117/src/version.c	2017-09-16 17:42:37.443279300 +0200
--- src/version.c	2017-09-16 20:53:39.990965426 +0200
***************
*** 667,677 ****
  #else
  	"-user_commands",
  #endif
- #ifdef FEAT_WINDOWS
  	"+vertsplit",
- #else
- 	"-vertsplit",
- #endif
  #ifdef FEAT_VIRTUALEDIT
  	"+virtualedit",
  #else
--- 667,673 ----
***************
*** 703,713 ****
  #else
  	"-wildmenu",
  #endif
- #ifdef FEAT_WINDOWS
  	"+windows",
- #else
- 	"-windows",
- #endif
  #ifdef FEAT_WRITEBACKUP
  	"+writebackup",
  #else
--- 699,705 ----
***************
*** 3436,3444 ****
  {
      if (BUFEMPTY()
  	    && curbuf->b_fname == NULL
- #ifdef FEAT_WINDOWS
  	    && firstwin->w_next == NULL
- #endif
  	    && vim_strchr(p_shm, SHM_INTRO) == NULL)
  	intro_message(FALSE);
  }
--- 3430,3436 ----
***************
*** 3511,3521 ****
      if (!p_cp)
  	blanklines += 4;  /* add 4 for not showing "Vi compatible" message */
  
- #ifdef FEAT_WINDOWS
      /* Don't overwrite a statusline.  Depends on 'cmdheight'. */
      if (p_ls > 1)
  	blanklines -= Rows - topframe->fr_height;
- #endif
      if (blanklines < 0)
  	blanklines = 0;
  
--- 3503,3511 ----
*** ../vim-8.0.1117/src/workshop.c	2017-03-12 18:23:35.861849968 +0100
--- src/workshop.c	2017-09-16 20:24:56.637294010 +0200
***************
*** 1265,1271 ****
      }
      else
      {
- #ifdef FEAT_WINDOWS
  	/* buf is in a window */
  	if (win != curwin)
  	{
--- 1265,1270 ----
***************
*** 1273,1279 ****
  	    /* wsdebug("load_window: window enter %s\n",
  		    win->w_buffer->b_sfname); */
  	}
- #endif
  	if (lnum > 0 && win->w_cursor.lnum != lnum)
  	{
  	    warp_to_pc(lnum);
--- 1272,1277 ----
*** ../vim-8.0.1117/src/if_perl.xs	2017-06-10 15:46:17.934297293 +0200
--- src/if_perl.xs	2017-09-16 20:25:21.889142041 +0200
***************
*** 1451,1474 ****
  }
  #endif /* PERLIO_LAYERS && !USE_SFIO */
  
- #ifndef FEAT_WINDOWS
-     int
- win_valid(win_T *w)
- {
-     return TRUE;
- }
-     int
- win_count(void)
- {
-     return 1;
- }
-     win_T *
- win_find_nr(int n)
- {
-     return curwin;
- }
- #endif
- 
  XS(boot_VIM);
  
      static void
--- 1451,1456 ----
*** ../vim-8.0.1117/src/testdir/test_normal.vim	2017-09-10 18:16:16.511727661 +0200
--- src/testdir/test_normal.vim	2017-09-16 20:27:06.396513338 +0200
***************
*** 2248,2254 ****
  endfunc
  
  func! Test_normal50_commandline()
!   if !has("timers") || !has("cmdline_hist") || !has("vertsplit")
      return
    endif
    func! DoTimerWork(id)
--- 2248,2254 ----
  endfunc
  
  func! Test_normal50_commandline()
!   if !has("timers") || !has("cmdline_hist")
      return
    endif
    func! DoTimerWork(id)
*** ../vim-8.0.1117/src/version.c	2017-09-16 17:42:37.443279300 +0200
--- src/version.c	2017-09-16 20:53:39.990965426 +0200
***************
*** 771,772 ****
--- 763,766 ----
  {   /* Add new patch number below this line */
+ /**/
+     1118,
  /**/

-- 
The coffee just wasn't strong enough to defend itself -- Tom Waits

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
