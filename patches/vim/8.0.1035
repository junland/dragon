To: vim_dev@googlegroups.com
Subject: Patch 8.0.1035
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1035
Problem:    Sending buffer lines to terminal doesn't work on MS-Windows.
Solution:   Use CR instead of NL after every line.  Make the EOF text work
            properly.  Add the ++eof argument to :terminal.
Files:      src/structs.h, src/channel.c, src/terminal.c,
            runtime/doc/terminal.txt, runtime/doc/eval.txt


*** ../vim-8.0.1034/src/structs.h	2017-09-02 14:54:16.384533128 +0200
--- src/structs.h	2017-09-02 15:58:44.846765404 +0200
***************
*** 1632,1637 ****
--- 1632,1638 ----
      int		ch_last_msg_id;	/* ID of the last message */
  
      chanpart_T	ch_part[PART_COUNT]; /* info for socket, out, err and in */
+     int		ch_write_text_mode; /* write buffer lines with CR, not NL */
  
      char	*ch_hostname;	/* only for socket, allocated */
      int		ch_port;	/* only for socket */
*** ../vim-8.0.1034/src/channel.c	2017-09-02 14:54:16.380533155 +0200
--- src/channel.c	2017-09-02 15:57:11.787384013 +0200
***************
*** 1300,1310 ****
  	return;
      memcpy((char *)p, (char *)line, len);
  
!     for (i = 0; i < len; ++i)
! 	if (p[i] == NL)
! 	    p[i] = NUL;
  
!     p[len] = NL;
      p[len + 1] = NUL;
      channel_send(channel, PART_IN, p, len + 1, "write_buf_line");
      vim_free(p);
--- 1300,1315 ----
  	return;
      memcpy((char *)p, (char *)line, len);
  
!     if (channel->ch_write_text_mode)
! 	p[len] = CAR;
!     else
!     {
! 	for (i = 0; i < len; ++i)
! 	    if (p[i] == NL)
! 		p[i] = NUL;
  
! 	p[len] = NL;
!     }
      p[len + 1] = NUL;
      channel_send(channel, PART_IN, p, len + 1, "write_buf_line");
      vim_free(p);
*** ../vim-8.0.1034/src/terminal.c	2017-09-02 14:54:16.384533128 +0200
--- src/terminal.c	2017-09-02 16:22:11.841332399 +0200
***************
*** 496,501 ****
--- 496,519 ----
  	    opt.jo_term_cols = atoi((char *)ep + 1);
  	    p = skiptowhite(cmd);
  	}
+ 	else if ((int)(p - cmd) == 3 && STRNICMP(cmd, "eof", 3) == 0
+ 								 && ep != NULL)
+ 	{
+ # ifdef WIN3264
+ 	    char_u *buf = NULL;
+ 	    char_u *keys;
+ 
+ 	    p = skiptowhite(cmd);
+ 	    *p = NUL;
+ 	    keys = replace_termcodes(ep + 1, &buf, TRUE, TRUE, TRUE);
+ 	    opt.jo_set2 |= JO2_EOF_CHARS;
+ 	    opt.jo_eof_chars = vim_strsave(keys);
+ 	    vim_free(buf);
+ 	    *p = ' ';
+ # else
+ 	    p = skiptowhite(cmd);
+ # endif
+ 	}
  	else
  	{
  	    if (*p)
***************
*** 3069,3076 ****
      if (job == NULL)
  	goto failed;
  
-     /* TODO: when all lines are written and the fd is closed, the command
-      * doesn't get EOF and hangs. */
      if (opt->jo_set & JO_IN_BUF)
  	job->jv_in_buf = buflist_findnr(opt->jo_io_buf[PART_IN]);
  
--- 3087,3092 ----
***************
*** 3092,3097 ****
--- 3108,3116 ----
  	    GENERIC_READ, 0, NULL,
  	    OPEN_EXISTING, 0, NULL));
  
+     /* Write lines with CR instead of NL. */
+     channel->ch_write_text_mode = TRUE;
+ 
      jo = CreateJobObject(NULL, NULL);
      if (jo == NULL)
  	goto failed;
***************
*** 3208,3215 ****
  
      for (term = first_term; term != NULL; term = term->tl_next)
  	if (term->tl_job == ch->ch_job)
! 	    channel_send(ch, PART_IN, term->tl_eof_chars != NULL
! 			 ? term->tl_eof_chars : (char_u *)"\004\r\n", 3, NULL);
  }
  
  # else
--- 3227,3241 ----
  
      for (term = first_term; term != NULL; term = term->tl_next)
  	if (term->tl_job == ch->ch_job)
! 	{
! 	    if (term->tl_eof_chars != NULL)
! 		channel_send(ch, PART_IN, term->tl_eof_chars,
! 					(int)STRLEN(term->tl_eof_chars), NULL);
! 	    else
! 		/* Default: CTRL-D */
! 		channel_send(ch, PART_IN, (char_u *)"\004", 1, NULL);
! 	    channel_send(ch, PART_IN, (char_u *)"\r", 1, NULL);
! 	}
  }
  
  # else
*** ../vim-8.0.1034/runtime/doc/terminal.txt	2017-08-29 22:44:33.376176824 +0200
--- runtime/doc/terminal.txt	2017-09-02 15:53:04.441033691 +0200
***************
*** 133,138 ****
--- 133,146 ----
  					height.
  			++cols={width}  Use {width} for the terminal window
  					width.
+ 			++eof={text}	when using [range], text to send after
+ 					the last line was written. The default
+ 					is to send CTRL-D.  A CR is appended.
+ 					E.g. for a shell use "++eof=exit" and
+ 					for Python "++eof=exit()".  Special
+ 					codes can be used like with `:map`,
+ 					e.g. "<C-Z>" for CTRL-Z.
+ 					{only on MS-Windows}
  
  			If you want to use more options use the |term_start()|
  			function.
***************
*** 141,151 ****
  is killed, similar to calling `job_stop(job, "kill")`
  
  So long as the job is running the window behaves like it contains a modified
! buffer.  Trying to close the window with `CTRL-W :close` or `CTRL-W :hide`
! fails, unless "!" is added, in which case the job is ended.  The text in the
! window is lost.  The buffer still exists, but getting it in a window with
! `:buffer` will show an
! empty buffer.
  
  You can use `CTRL-W :hide` to close the terminal window and make the buffer
  hidden, the job keeps running.  The `:buffer` command can be used to turn the
--- 149,161 ----
  is killed, similar to calling `job_stop(job, "kill")`
  
  So long as the job is running the window behaves like it contains a modified
! buffer.  Trying to close the window with `CTRL-W :quit` fails.  When using
! `CTRL-W :quit!` the job is ended.  The text in the window is lost.  The buffer
! still exists, but getting it in a window with `:buffer` will show an empty
! buffer.
! 
! Trying to close the window with `CTRL-W :close` also fails.   Using
! `CTRL-W :close!` will close the window and make the buffer hidden.
  
  You can use `CTRL-W :hide` to close the terminal window and make the buffer
  hidden, the job keeps running.  The `:buffer` command can be used to turn the
*** ../vim-8.0.1034/runtime/doc/eval.txt	2017-09-01 18:33:57.744660798 +0200
--- runtime/doc/eval.txt	2017-09-02 15:54:16.472551287 +0200
***************
*** 8139,8144 ****
--- 8141,8152 ----
  				     have "%d" where the buffer number goes,
  				     e.g. "10split|buffer %d"; when not
  				     specified "botright sbuf %d" is used
+ 		   "eof_chars"	     Text to send after all buffer lines were
+ 				     written to the terminal.  When not set
+ 				     CTRL-D is used. For Python use CTRL-Z or
+ 				     "exit()". For a shell use "exit".  A CR
+ 				     is always added.
+ 				     {only on MS-Windows}
  
  		{only available when compiled with the |+terminal| feature}
  
*** ../vim-8.0.1034/src/version.c	2017-09-02 14:54:16.384533128 +0200
--- src/version.c	2017-09-02 16:26:52.775448298 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     1035,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
48. You get a tatoo that says "This body best viewed with Netscape 3.1 or
    higher."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
