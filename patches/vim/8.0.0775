To: vim_dev@googlegroups.com
Subject: Patch 8.0.0775
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0775
Problem:    In a terminal the cursor is updated too often.
Solution:   Only flush when needed. (Yasuhiro Matsumoto).  Remeber whether the
            cursor is visible. (closes #1873)
Files:      src/terminal.c


*** ../vim-8.0.0774/src/terminal.c	2017-07-24 23:36:34.890967822 +0200
--- src/terminal.c	2017-07-25 23:07:13.644821395 +0200
***************
*** 106,111 ****
--- 106,112 ----
      int		tl_dirty_row_end;   /* row below last one to update */
  
      pos_T	tl_cursor;
+     int		tl_cursor_visible;
  };
  
  /*
***************
*** 176,181 ****
--- 177,183 ----
      if (term == NULL)
  	return;
      term->tl_dirty_row_end = MAX_ROW;
+     term->tl_cursor_visible = TRUE;
  
      /* Open a new window or tab. */
      vim_memset(&split_ea, 0, sizeof(split_ea));
***************
*** 316,330 ****
  }
  
      static void
! update_cursor()
  {
      /* TODO: this should not always be needed */
      setcursor();
!     out_flush();
  #ifdef FEAT_GUI
!     if (gui.in_use)
! 	gui_update_cursor(FALSE, FALSE);
  #endif
  }
  
  /*
--- 318,335 ----
  }
  
      static void
! update_cursor(term_T *term, int redraw)
  {
      /* TODO: this should not always be needed */
      setcursor();
!     if (redraw && term->tl_buffer == curbuf && term->tl_cursor_visible)
!     {
! 	out_flush();
  #ifdef FEAT_GUI
! 	if (gui.in_use)
! 	    gui_update_cursor(FALSE, FALSE);
  #endif
+     }
  }
  
  /*
***************
*** 342,348 ****
  
      /* TODO: only update once in a while. */
      update_screen(0);
!     update_cursor();
  }
  
  /*
--- 347,353 ----
  
      /* TODO: only update once in a while. */
      update_screen(0);
!     update_cursor(term, TRUE);
  }
  
  /*
***************
*** 473,479 ****
      {
  	/* TODO: skip screen update when handling a sequence of keys. */
  	update_screen(0);
! 	update_cursor();
  	++no_mapping;
  	++allow_keys;
  	got_int = FALSE;
--- 478,484 ----
      {
  	/* TODO: skip screen update when handling a sequence of keys. */
  	update_screen(0);
! 	update_cursor(curbuf->b_term, FALSE);
  	++no_mapping;
  	++allow_keys;
  	got_int = FALSE;
***************
*** 559,570 ****
  	    did_one = TRUE;
  	}
      if (did_one)
-     {
  	redraw_statuslines();
! 	update_cursor();
      }
-     if (curbuf->b_term != NULL && curbuf->b_term->tl_job == job)
- 	maketitle();
  }
  
  /*
--- 564,576 ----
  	    did_one = TRUE;
  	}
      if (did_one)
  	redraw_statuslines();
!     if (curbuf->b_term != NULL)
!     {
! 	if (curbuf->b_term->tl_job == job)
! 	    maketitle();
! 	update_cursor(curbuf->b_term, TRUE);
      }
  }
  
  /*
***************
*** 583,588 ****
--- 589,606 ----
      wp->w_wcol = MIN(pos->col, MAX(0, wp->w_width - 1));
  }
  
+     static void
+ may_toggle_cursor(term_T *term)
+ {
+     if (curbuf == term->tl_buffer)
+     {
+ 	if (term->tl_cursor_visible)
+ 	    cursor_on();
+ 	else
+ 	    cursor_off();
+     }
+ }
+ 
      static int
  handle_damage(VTermRect rect, void *user)
  {
***************
*** 608,614 ****
  handle_movecursor(
  	VTermPos pos,
  	VTermPos oldpos UNUSED,
! 	int visible UNUSED,
  	void *user)
  {
      term_T	*term = (term_T *)user;
--- 626,632 ----
  handle_movecursor(
  	VTermPos pos,
  	VTermPos oldpos UNUSED,
! 	int visible,
  	void *user)
  {
      term_T	*term = (term_T *)user;
***************
*** 625,632 ****
  	}
      }
  
      if (is_current)
! 	update_cursor();
  
      return 1;
  }
--- 643,654 ----
  	}
      }
  
+     term->tl_cursor_visible = visible;
      if (is_current)
!     {
! 	may_toggle_cursor(term);
! 	update_cursor(term, TRUE);
!     }
  
      return 1;
  }
***************
*** 648,658 ****
  	    term->tl_status_text = NULL;
  	    if (term == curbuf->b_term)
  		maketitle();
! 	    return 1;
  	default:
  	    break;
      }
!     return 0;
  }
  
  /*
--- 670,688 ----
  	    term->tl_status_text = NULL;
  	    if (term == curbuf->b_term)
  		maketitle();
! 	    break;
! 
! 	case VTERM_PROP_CURSORVISIBLE:
! 	    term->tl_cursor_visible = value->boolean;
! 	    may_toggle_cursor(term);
! 	    out_flush();
! 	    break;
! 
  	default:
  	    break;
      }
!     /* Always return 1, otherwise vterm doesn't store the value internally. */
!     return 1;
  }
  
  /*
*** ../vim-8.0.0774/src/version.c	2017-07-25 22:06:39.327354063 +0200
--- src/version.c	2017-07-25 22:47:48.713331240 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     775,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
248. You sign your letters with your e-mail address instead of your name.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
