To: vim_dev@googlegroups.com
Subject: Patch 8.0.0908
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0908
Problem:    Cannot set terminal size with options.
Solution:   Add "term_rows", "term_cols" and "vertical".
Files:      src/terminal.c, runtime/doc/eval.txt, src/channel.c,
            src/proto/channel.pro, src/structs.h, src/evalfunc.c,
            src/testdir/test_terminal.vim


*** ../vim-8.0.0907/src/terminal.c	2017-08-11 19:12:05.052966360 +0200
--- src/terminal.c	2017-08-11 21:44:05.607739252 +0200
***************
*** 237,244 ****
      opt->jo_io_buf[PART_OUT] = curbuf->b_fnum;
      opt->jo_io_buf[PART_ERR] = curbuf->b_fnum;
      opt->jo_pty = TRUE;
!     opt->jo_term_rows = rows;
!     opt->jo_term_cols = cols;
  }
  
      static void
--- 237,246 ----
      opt->jo_io_buf[PART_OUT] = curbuf->b_fnum;
      opt->jo_io_buf[PART_ERR] = curbuf->b_fnum;
      opt->jo_pty = TRUE;
!     if ((opt->jo_set2 & JO2_TERM_ROWS) == 0)
! 	opt->jo_term_rows = rows;
!     if ((opt->jo_set2 & JO2_TERM_COLS) == 0)
! 	opt->jo_term_cols = cols;
  }
  
      static void
***************
*** 2361,2371 ****
      if (argvars[1].v_type != VAR_UNKNOWN
  	    && get_job_options(&argvars[1], &opt,
  		JO_TIMEOUT_ALL + JO_STOPONEXIT
! 		+ JO_EXIT_CB + JO_CLOSE_CALLBACK
! 		+ JO2_TERM_NAME + JO2_TERM_FINISH
! 		+ JO2_CWD + JO2_ENV) == FAIL)
  	return;
  
      term_start(cmd, &opt);
  
      if (curbuf->b_term != NULL)
--- 2363,2376 ----
      if (argvars[1].v_type != VAR_UNKNOWN
  	    && get_job_options(&argvars[1], &opt,
  		JO_TIMEOUT_ALL + JO_STOPONEXIT
! 		    + JO_EXIT_CB + JO_CLOSE_CALLBACK,
! 		JO2_TERM_NAME + JO2_TERM_FINISH
! 		    + JO2_TERM_COLS + JO2_TERM_ROWS + JO2_VERTICAL
! 		    + JO2_CWD + JO2_ENV) == FAIL)
  	return;
  
+     if (opt.jo_vertical)
+ 	cmdmod.split = WSP_VERT;
      term_start(cmd, &opt);
  
      if (curbuf->b_term != NULL)
*** ../vim-8.0.0907/runtime/doc/eval.txt	2017-08-11 20:25:22.097565404 +0200
--- runtime/doc/eval.txt	2017-08-11 21:47:44.250173325 +0200
***************
*** 8050,8057 ****
  term_start({cmd}, {options})				*term_start()*
  		Open a terminal window and run {cmd} in it.
  
! 		Returns the buffer number of the terminal window.
! 		When opening the window fails zero is returned.
  
  		{options} are similar to what is used for |job_start()|, see
  		|job-options|.  However, not all options can be used.  These
--- 8050,8059 ----
  term_start({cmd}, {options})				*term_start()*
  		Open a terminal window and run {cmd} in it.
  
! 		Returns the buffer number of the terminal window.  If {cmd}
! 		cannot be executed the window does open and shows an error
! 		message.
! 		If opening the window fails zero is returned.
  
  		{options} are similar to what is used for |job_start()|, see
  		|job-options|.  However, not all options can be used.  These
***************
*** 8067,8076 ****
  		connected to the terminal.  When I/O is connected to the
  		terminal then the callback function for that part is not used.
  
! 		There are two extra options:
  		   "term_name"	     name to use for the buffer name, instead
  				     of the command name.
! 		   "term_finish"     What todo when the job is finished:
  					"close": close any windows
  					"open": open window if needed
  				     Note that "open" can be interruptive.
--- 8069,8083 ----
  		connected to the terminal.  When I/O is connected to the
  		terminal then the callback function for that part is not used.
  
! 		There are extra options:
  		   "term_name"	     name to use for the buffer name, instead
  				     of the command name.
! 		   "term_rows"	     vertical size to use for the terminal,
! 				     instead of using 'termsize'
! 		   "term_cols"	     horizontal size to use for the terminal,
! 		   		     instead of using 'termsize'
! 		   "vertical"	     split the window vertically
! 		   "term_finish"     What to do when the job is finished:
  					"close": close any windows
  					"open": open window if needed
  				     Note that "open" can be interruptive.
*** ../vim-8.0.0907/src/channel.c	2017-08-11 19:12:05.052966360 +0200
--- src/channel.c	2017-08-11 21:39:37.745655960 +0200
***************
*** 927,933 ****
      opt.jo_mode = MODE_JSON;
      opt.jo_timeout = 2000;
      if (get_job_options(&argvars[1], &opt,
! 	      JO_MODE_ALL + JO_CB_ALL + JO_WAITTIME + JO_TIMEOUT_ALL) == FAIL)
  	goto theend;
      if (opt.jo_timeout < 0)
      {
--- 927,933 ----
      opt.jo_mode = MODE_JSON;
      opt.jo_timeout = 2000;
      if (get_job_options(&argvars[1], &opt,
! 	    JO_MODE_ALL + JO_CB_ALL + JO_WAITTIME + JO_TIMEOUT_ALL, 0) == FAIL)
  	goto theend;
      if (opt.jo_timeout < 0)
      {
***************
*** 3429,3435 ****
      rettv->vval.v_string = NULL;
  
      clear_job_options(&opt);
!     if (get_job_options(&argvars[1], &opt, JO_TIMEOUT + JO_PART + JO_ID)
  								      == FAIL)
  	goto theend;
  
--- 3429,3435 ----
      rettv->vval.v_string = NULL;
  
      clear_job_options(&opt);
!     if (get_job_options(&argvars[1], &opt, JO_TIMEOUT + JO_PART + JO_ID, 0)
  								      == FAIL)
  	goto theend;
  
***************
*** 3612,3618 ****
      part_send = channel_part_send(channel);
      *part_read = channel_part_read(channel);
  
!     if (get_job_options(&argvars[2], opt, JO_CALLBACK + JO_TIMEOUT) == FAIL)
  	return NULL;
  
      /* Set the callback. An empty callback means no callback and not reading
--- 3612,3618 ----
      part_send = channel_part_send(channel);
      *part_read = channel_part_read(channel);
  
!     if (get_job_options(&argvars[2], opt, JO_CALLBACK + JO_TIMEOUT, 0) == FAIL)
  	return NULL;
  
      /* Set the callback. An empty callback means no callback and not reading
***************
*** 4169,4179 ****
  /*
   * Get the option entries from the dict in "tv", parse them and put the result
   * in "opt".
!  * Only accept options in "supported".
   * If an option value is invalid return FAIL.
   */
      int
! get_job_options(typval_T *tv, jobopt_T *opt, int supported)
  {
      typval_T	*item;
      char_u	*val;
--- 4169,4179 ----
  /*
   * Get the option entries from the dict in "tv", parse them and put the result
   * in "opt".
!  * Only accept JO_ options in "supported" and JO2_ options in "supported2".
   * If an option value is invalid return FAIL.
   */
      int
! get_job_options(typval_T *tv, jobopt_T *opt, int supported, int supported2)
  {
      typval_T	*item;
      char_u	*val;
***************
*** 4411,4417 ****
  #ifdef FEAT_TERMINAL
  	    else if (STRCMP(hi->hi_key, "term_name") == 0)
  	    {
! 		if (!(supported & JO2_TERM_NAME))
  		    break;
  		opt->jo_set2 |= JO2_TERM_NAME;
  		opt->jo_term_name = get_tv_string_chk(item);
--- 4411,4417 ----
  #ifdef FEAT_TERMINAL
  	    else if (STRCMP(hi->hi_key, "term_name") == 0)
  	    {
! 		if (!(supported2 & JO2_TERM_NAME))
  		    break;
  		opt->jo_set2 |= JO2_TERM_NAME;
  		opt->jo_term_name = get_tv_string_chk(item);
***************
*** 4423,4429 ****
  	    }
  	    else if (STRCMP(hi->hi_key, "term_finish") == 0)
  	    {
! 		if (!(supported & JO2_TERM_FINISH))
  		    break;
  		val = get_tv_string(item);
  		if (STRCMP(val, "open") != 0 && STRCMP(val, "close") != 0)
--- 4423,4429 ----
  	    }
  	    else if (STRCMP(hi->hi_key, "term_finish") == 0)
  	    {
! 		if (!(supported2 & JO2_TERM_FINISH))
  		    break;
  		val = get_tv_string(item);
  		if (STRCMP(val, "open") != 0 && STRCMP(val, "close") != 0)
***************
*** 4434,4443 ****
  		opt->jo_set2 |= JO2_TERM_FINISH;
  		opt->jo_term_finish = *val;
  	    }
  #endif
  	    else if (STRCMP(hi->hi_key, "env") == 0)
  	    {
! 		if (!(supported & JO2_ENV))
  		    break;
  		opt->jo_set |= JO2_ENV;
  		opt->jo_env = item->vval.v_dict;
--- 4434,4464 ----
  		opt->jo_set2 |= JO2_TERM_FINISH;
  		opt->jo_term_finish = *val;
  	    }
+ 	    else if (STRCMP(hi->hi_key, "term_rows") == 0)
+ 	    {
+ 		if (!(supported2 & JO2_TERM_ROWS))
+ 		    break;
+ 		opt->jo_set |= JO2_TERM_ROWS;
+ 		opt->jo_term_rows = get_tv_number(item);
+ 	    }
+ 	    else if (STRCMP(hi->hi_key, "term_cols") == 0)
+ 	    {
+ 		if (!(supported2 & JO2_TERM_COLS))
+ 		    break;
+ 		opt->jo_set |= JO2_TERM_COLS;
+ 		opt->jo_term_cols = get_tv_number(item);
+ 	    }
+ 	    else if (STRCMP(hi->hi_key, "vertical") == 0)
+ 	    {
+ 		if (!(supported2 & JO2_VERTICAL))
+ 		    break;
+ 		opt->jo_set |= JO2_VERTICAL;
+ 		opt->jo_vertical = get_tv_number(item);
+ 	    }
  #endif
  	    else if (STRCMP(hi->hi_key, "env") == 0)
  	    {
! 		if (!(supported2 & JO2_ENV))
  		    break;
  		opt->jo_set |= JO2_ENV;
  		opt->jo_env = item->vval.v_dict;
***************
*** 4445,4451 ****
  	    }
  	    else if (STRCMP(hi->hi_key, "cwd") == 0)
  	    {
! 		if (!(supported & JO2_CWD))
  		    break;
  		opt->jo_cwd = get_tv_string_buf_chk(item, opt->jo_cwd_buf);
  		if (opt->jo_cwd == NULL || !mch_isdir(opt->jo_cwd))
--- 4466,4472 ----
  	    }
  	    else if (STRCMP(hi->hi_key, "cwd") == 0)
  	    {
! 		if (!(supported2 & JO2_CWD))
  		    break;
  		opt->jo_cwd = get_tv_string_buf_chk(item, opt->jo_cwd_buf);
  		if (opt->jo_cwd == NULL || !mch_isdir(opt->jo_cwd))
***************
*** 4956,4962 ****
  	opt.jo_mode = MODE_NL;
  	if (get_job_options(&argvars[1], &opt,
  	    JO_MODE_ALL + JO_CB_ALL + JO_TIMEOUT_ALL + JO_STOPONEXIT
! 			   + JO_EXIT_CB + JO_OUT_IO + JO_BLOCK_WRITE) == FAIL)
  	    goto theend;
      }
  
--- 4977,4983 ----
  	opt.jo_mode = MODE_NL;
  	if (get_job_options(&argvars[1], &opt,
  	    JO_MODE_ALL + JO_CB_ALL + JO_TIMEOUT_ALL + JO_STOPONEXIT
! 			 + JO_EXIT_CB + JO_OUT_IO + JO_BLOCK_WRITE, 0) == FAIL)
  	    goto theend;
      }
  
*** ../vim-8.0.0907/src/proto/channel.pro	2017-08-03 14:49:22.614906252 +0200
--- src/proto/channel.pro	2017-08-11 21:38:38.606079271 +0200
***************
*** 51,65 ****
  int channel_get_timeout(channel_T *channel, ch_part_T part);
  void clear_job_options(jobopt_T *opt);
  void free_job_options(jobopt_T *opt);
! int get_job_options(typval_T *tv, jobopt_T *opt, int supported);
  channel_T *get_channel_arg(typval_T *tv, int check_open, int reading, ch_part_T part);
- job_T *job_alloc(void);
- void job_cleanup(job_T *job);
  void job_free_all(void);
  int set_ref_in_job(int copyID);
  void job_unref(job_T *job);
  int free_unused_jobs_contents(int copyID, int mask);
  void free_unused_jobs(int copyID, int mask);
  void job_set_options(job_T *job, jobopt_T *opt);
  void job_stop_on_exit(void);
  int has_pending_job(void);
--- 51,65 ----
  int channel_get_timeout(channel_T *channel, ch_part_T part);
  void clear_job_options(jobopt_T *opt);
  void free_job_options(jobopt_T *opt);
! int get_job_options(typval_T *tv, jobopt_T *opt, int supported, int supported2);
  channel_T *get_channel_arg(typval_T *tv, int check_open, int reading, ch_part_T part);
  void job_free_all(void);
+ void job_cleanup(job_T *job);
  int set_ref_in_job(int copyID);
  void job_unref(job_T *job);
  int free_unused_jobs_contents(int copyID, int mask);
  void free_unused_jobs(int copyID, int mask);
+ job_T *job_alloc(void);
  void job_set_options(job_T *job, jobopt_T *opt);
  void job_stop_on_exit(void);
  int has_pending_job(void);
*** ../vim-8.0.0907/src/structs.h	2017-08-11 19:12:05.056966332 +0200
--- src/structs.h	2017-08-11 21:44:47.091442203 +0200
***************
*** 1688,1694 ****
  #define JO2_TERM_FINISH	    0x0008	/* "term_finish" */
  #define JO2_ENV		    0x0010	/* "env" */
  #define JO2_CWD		    0x0020	/* "cwd" */
! #define JO2_ALL		    0x003F
  
  #define JO_MODE_ALL	(JO_MODE + JO_IN_MODE + JO_OUT_MODE + JO_ERR_MODE)
  #define JO_CB_ALL \
--- 1688,1697 ----
  #define JO2_TERM_FINISH	    0x0008	/* "term_finish" */
  #define JO2_ENV		    0x0010	/* "env" */
  #define JO2_CWD		    0x0020	/* "cwd" */
! #define JO2_TERM_ROWS	    0x0040	/* "term_rows" */
! #define JO2_TERM_COLS	    0x0080	/* "term_cols" */
! #define JO2_VERTICAL	    0x0100	/* "vertical" */
! #define JO2_ALL		    0x01FF
  
  #define JO_MODE_ALL	(JO_MODE + JO_IN_MODE + JO_OUT_MODE + JO_ERR_MODE)
  #define JO_CB_ALL \
***************
*** 1748,1753 ****
--- 1751,1757 ----
      /* when non-zero run the job in a terminal window of this size */
      int		jo_term_rows;
      int		jo_term_cols;
+     int		jo_vertical;
      char_u	*jo_term_name;
      int		jo_term_finish;
  #endif
*** ../vim-8.0.0907/src/evalfunc.c	2017-08-11 16:24:46.316283895 +0200
--- src/evalfunc.c	2017-08-11 21:35:05.787602994 +0200
***************
*** 2021,2027 ****
  	return;
      clear_job_options(&opt);
      if (get_job_options(&argvars[1], &opt,
! 			      JO_CB_ALL + JO_TIMEOUT_ALL + JO_MODE_ALL) == OK)
  	channel_set_options(channel, &opt);
      free_job_options(&opt);
  }
--- 2021,2027 ----
  	return;
      clear_job_options(&opt);
      if (get_job_options(&argvars[1], &opt,
! 			    JO_CB_ALL + JO_TIMEOUT_ALL + JO_MODE_ALL, 0) == OK)
  	channel_set_options(channel, &opt);
      free_job_options(&opt);
  }
***************
*** 2045,2051 ****
      if (argvars[1].v_type != VAR_UNKNOWN)
      {
  	clear_job_options(&opt);
! 	if (get_job_options(&argvars[1], &opt, JO_PART) == OK
  						     && (opt.jo_set & JO_PART))
  	    part = opt.jo_part;
      }
--- 2045,2051 ----
      if (argvars[1].v_type != VAR_UNKNOWN)
      {
  	clear_job_options(&opt);
! 	if (get_job_options(&argvars[1], &opt, JO_PART, 0) == OK
  						     && (opt.jo_set & JO_PART))
  	    part = opt.jo_part;
      }
***************
*** 6783,6789 ****
      if (job == NULL)
  	return;
      clear_job_options(&opt);
!     if (get_job_options(&argvars[1], &opt, JO_STOPONEXIT + JO_EXIT_CB) == OK)
  	job_set_options(job, &opt);
      free_job_options(&opt);
  }
--- 6783,6789 ----
      if (job == NULL)
  	return;
      clear_job_options(&opt);
!     if (get_job_options(&argvars[1], &opt, JO_STOPONEXIT + JO_EXIT_CB, 0) == OK)
  	job_set_options(job, &opt);
      free_job_options(&opt);
  }
*** ../vim-8.0.0907/src/testdir/test_terminal.vim	2017-08-11 20:20:23.859723236 +0200
--- src/testdir/test_terminal.vim	2017-08-11 21:38:36.390095132 +0200
***************
*** 247,268 ****
--- 247,289 ----
    bwipe!
    call assert_equal(5, size[0])
  
+   call term_start(cmd, {'term_rows': 6})
+   let size = term_getsize('')
+   bwipe!
+   call assert_equal(6, size[0])
+ 
    vsplit
    exe '5,33terminal ' . cmd
    let size = term_getsize('')
    bwipe!
    call assert_equal([5, 33], size)
  
+   call term_start(cmd, {'term_rows': 6, 'term_cols': 36})
+   let size = term_getsize('')
+   bwipe!
+   call assert_equal([6, 36], size)
+ 
    exe 'vertical 20terminal ' . cmd
    let size = term_getsize('')
    bwipe!
    call assert_equal(20, size[1])
  
+   call term_start(cmd, {'vertical': 1, 'term_cols': 26})
+   let size = term_getsize('')
+   bwipe!
+   call assert_equal(26, size[1])
+ 
    split
    exe 'vertical 6,20terminal ' . cmd
    let size = term_getsize('')
    bwipe!
    call assert_equal([6, 20], size)
+ 
+   call term_start(cmd, {'vertical': 1, 'term_rows': 7, 'term_cols': 27})
+   let size = term_getsize('')
+   bwipe!
+   call assert_equal([7, 27], size)
+ 
  endfunc
  
  func Test_finish_close()
*** ../vim-8.0.0907/src/version.c	2017-08-11 20:55:49.024419841 +0200
--- src/version.c	2017-08-11 21:49:58.057215251 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     908,
  /**/

-- 
bashian roulette:
$ ((RANDOM%6)) || rm -rf ~

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
