To: vim_dev@googlegroups.com
Subject: Patch 8.0.1039
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1039
Problem:    Cannot change a line in a buffer other than the current one.
Solution:   Add setbufline(). (Yasuhiro Matsumoto, Ozaki Kiichi, closes #1953)
Files:      src/evalfunc.c, runtime/doc/eval.txt, src/Makefile,
            src/testdir/test_bufline.vim, src/testdir/test_alot.vim


*** ../vim-8.0.1038/src/evalfunc.c	2017-09-02 18:33:52.445554521 +0200
--- src/evalfunc.c	2017-09-02 19:42:51.850274704 +0200
***************
*** 328,333 ****
--- 328,334 ----
  static void f_searchpos(typval_T *argvars, typval_T *rettv);
  static void f_server2client(typval_T *argvars, typval_T *rettv);
  static void f_serverlist(typval_T *argvars, typval_T *rettv);
+ static void f_setbufline(typval_T *argvars, typval_T *rettv);
  static void f_setbufvar(typval_T *argvars, typval_T *rettv);
  static void f_setcharsearch(typval_T *argvars, typval_T *rettv);
  static void f_setcmdpos(typval_T *argvars, typval_T *rettv);
***************
*** 764,769 ****
--- 765,771 ----
      {"searchpos",	1, 4, f_searchpos},
      {"server2client",	2, 2, f_server2client},
      {"serverlist",	0, 0, f_serverlist},
+     {"setbufline",	3, 3, f_setbufline},
      {"setbufvar",	3, 3, f_setbufvar},
      {"setcharsearch",	1, 1, f_setcharsearch},
      {"setcmdpos",	1, 1, f_setcmdpos},
***************
*** 9868,9873 ****
--- 9870,9984 ----
  }
  
  /*
+  * Set line or list of lines in buffer "buf".
+  */
+     static void
+ set_buffer_lines(buf_T *buf, linenr_T lnum, typval_T *lines, typval_T *rettv)
+ {
+     char_u	*line = NULL;
+     list_T	*l = NULL;
+     listitem_T	*li = NULL;
+     long	added = 0;
+     linenr_T	lcount;
+     buf_T	*curbuf_save;
+     int		is_curbuf = buf == curbuf;
+ 
+     if (buf == NULL || buf->b_ml.ml_mfp == NULL || lnum < 1)
+     {
+ 	rettv->vval.v_number = 1;	/* FAIL */
+ 	return;
+     }
+ 
+     curbuf_save = curbuf;
+     curbuf = buf;
+ 
+     lcount = curbuf->b_ml.ml_line_count;
+ 
+     if (lines->v_type == VAR_LIST)
+     {
+ 	l = lines->vval.v_list;
+ 	li = l->lv_first;
+     }
+     else
+ 	line = get_tv_string_chk(lines);
+ 
+     /* default result is zero == OK */
+     for (;;)
+     {
+ 	if (l != NULL)
+ 	{
+ 	    /* list argument, get next string */
+ 	    if (li == NULL)
+ 		break;
+ 	    line = get_tv_string_chk(&li->li_tv);
+ 	    li = li->li_next;
+ 	}
+ 
+ 	rettv->vval.v_number = 1;	/* FAIL */
+ 	if (line == NULL || lnum < 1 || lnum > curbuf->b_ml.ml_line_count + 1)
+ 	    break;
+ 
+ 	/* When coming here from Insert mode, sync undo, so that this can be
+ 	 * undone separately from what was previously inserted. */
+ 	if (u_sync_once == 2)
+ 	{
+ 	    u_sync_once = 1; /* notify that u_sync() was called */
+ 	    u_sync(TRUE);
+ 	}
+ 
+ 	if (lnum <= curbuf->b_ml.ml_line_count)
+ 	{
+ 	    /* existing line, replace it */
+ 	    if (u_savesub(lnum) == OK && ml_replace(lnum, line, TRUE) == OK)
+ 	    {
+ 		changed_bytes(lnum, 0);
+ 		if (is_curbuf && lnum == curwin->w_cursor.lnum)
+ 		    check_cursor_col();
+ 		rettv->vval.v_number = 0;	/* OK */
+ 	    }
+ 	}
+ 	else if (added > 0 || u_save(lnum - 1, lnum) == OK)
+ 	{
+ 	    /* lnum is one past the last line, append the line */
+ 	    ++added;
+ 	    if (ml_append(lnum - 1, line, (colnr_T)0, FALSE) == OK)
+ 		rettv->vval.v_number = 0;	/* OK */
+ 	}
+ 
+ 	if (l == NULL)			/* only one string argument */
+ 	    break;
+ 	++lnum;
+     }
+ 
+     if (added > 0)
+ 	appended_lines_mark(lcount, added);
+ 
+     curbuf = curbuf_save;
+ }
+ 
+ /*
+  * "setbufline()" function
+  */
+     static void
+ f_setbufline(argvars, rettv)
+     typval_T	*argvars;
+     typval_T	*rettv;
+ {
+     linenr_T	lnum;
+     buf_T	*buf;
+ 
+     buf = get_buf_tv(&argvars[0], FALSE);
+     if (buf == NULL)
+ 	rettv->vval.v_number = 1; /* FAIL */
+     else
+     {
+ 	lnum = get_tv_lnum_buf(&argvars[1], buf);
+ 
+ 	set_buffer_lines(buf, lnum, &argvars[2], rettv);
+     }
+ }
+ 
+ /*
   * "setbufvar()" function
   */
      static void
***************
*** 10021,10092 ****
      static void
  f_setline(typval_T *argvars, typval_T *rettv)
  {
!     linenr_T	lnum;
!     char_u	*line = NULL;
!     list_T	*l = NULL;
!     listitem_T	*li = NULL;
!     long	added = 0;
!     linenr_T	lcount = curbuf->b_ml.ml_line_count;
  
!     lnum = get_tv_lnum(&argvars[0]);
!     if (argvars[1].v_type == VAR_LIST)
!     {
! 	l = argvars[1].vval.v_list;
! 	li = l->lv_first;
!     }
!     else
! 	line = get_tv_string_chk(&argvars[1]);
! 
!     /* default result is zero == OK */
!     for (;;)
!     {
! 	if (l != NULL)
! 	{
! 	    /* list argument, get next string */
! 	    if (li == NULL)
! 		break;
! 	    line = get_tv_string_chk(&li->li_tv);
! 	    li = li->li_next;
! 	}
! 
! 	rettv->vval.v_number = 1;	/* FAIL */
! 	if (line == NULL || lnum < 1 || lnum > curbuf->b_ml.ml_line_count + 1)
! 	    break;
! 
! 	/* When coming here from Insert mode, sync undo, so that this can be
! 	 * undone separately from what was previously inserted. */
! 	if (u_sync_once == 2)
! 	{
! 	    u_sync_once = 1; /* notify that u_sync() was called */
! 	    u_sync(TRUE);
! 	}
! 
! 	if (lnum <= curbuf->b_ml.ml_line_count)
! 	{
! 	    /* existing line, replace it */
! 	    if (u_savesub(lnum) == OK && ml_replace(lnum, line, TRUE) == OK)
! 	    {
! 		changed_bytes(lnum, 0);
! 		if (lnum == curwin->w_cursor.lnum)
! 		    check_cursor_col();
! 		rettv->vval.v_number = 0;	/* OK */
! 	    }
! 	}
! 	else if (added > 0 || u_save(lnum - 1, lnum) == OK)
! 	{
! 	    /* lnum is one past the last line, append the line */
! 	    ++added;
! 	    if (ml_append(lnum - 1, line, (colnr_T)0, FALSE) == OK)
! 		rettv->vval.v_number = 0;	/* OK */
! 	}
! 
! 	if (l == NULL)			/* only one string argument */
! 	    break;
! 	++lnum;
!     }
! 
!     if (added > 0)
! 	appended_lines_mark(lcount, added);
  }
  
  static void set_qf_ll_list(win_T *wp, typval_T *list_arg, typval_T *action_arg, typval_T *what_arg, typval_T *rettv);
--- 10132,10140 ----
      static void
  f_setline(typval_T *argvars, typval_T *rettv)
  {
!     linenr_T	lnum = get_tv_lnum(&argvars[0]);
  
!     set_buffer_lines(curbuf, lnum, &argvars[1], rettv);
  }
  
  static void set_qf_ll_list(win_T *wp, typval_T *list_arg, typval_T *action_arg, typval_T *what_arg, typval_T *rettv);
*** ../vim-8.0.1038/runtime/doc/eval.txt	2017-09-02 18:33:52.437554573 +0200
--- runtime/doc/eval.txt	2017-09-02 19:41:38.522760525 +0200
***************
*** 2316,2321 ****
--- 2316,2324 ----
  server2client({clientid}, {string})
  				Number	send reply string
  serverlist()			String	get a list of available servers
+ setbufline( {expr}, {lnum}, {line})
+ 				Number	set line {lnum} to {line} in buffer
+ 					{expr}
  setbufvar({expr}, {varname}, {val})
  				none	set {varname} in buffer {expr} to {val}
  setcharsearch({dict})		Dict	set character search from {dict}
***************
*** 6856,6861 ****
--- 6861,6879 ----
  		Example: >
  			:echo serverlist()
  <
+ setbufline({expr}, {lnum}, {text})			*setbufline()*
+ 		Set line {lnum} to {text} in buffer {expr}.  To insert
+ 		lines use |append()|.
+ 
+ 		For the use of {expr}, see |bufname()| above.
+ 
+ 		{lnum} is used like with |setline()|.
+ 		This works like |setline()| for the specified buffer.
+ 		On success 0 is returned, on failure 1 is returned.
+ 
+ 		If {expr} is not a valid buffer or {lnum} is not valid, an
+ 		error message is given.
+ 
  setbufvar({expr}, {varname}, {val})			*setbufvar()*
  		Set option or local variable {varname} in buffer {expr} to
  		{val}.
***************
*** 6924,6936 ****
  
  setline({lnum}, {text})					*setline()*
  		Set line {lnum} of the current buffer to {text}.  To insert
! 		lines use |append()|.
  		{lnum} is used like with |getline()|.
  		When {lnum} is just below the last line the {text} will be
  		added as a new line.
  		If this succeeds, 0 is returned.  If this fails (most likely
! 		because {lnum} is invalid) 1 is returned.  Example: >
  			:call setline(5, strftime("%c"))
  <		When {text} is a |List| then line {lnum} and following lines
  		will be set to the items in the list.  Example: >
  			:call setline(5, ['aaa', 'bbb', 'ccc'])
--- 6942,6960 ----
  
  setline({lnum}, {text})					*setline()*
  		Set line {lnum} of the current buffer to {text}.  To insert
! 		lines use |append()|. To set lines in another buffer use
! 		|setbufline()|.
! 
  		{lnum} is used like with |getline()|.
  		When {lnum} is just below the last line the {text} will be
  		added as a new line.
+ 
  		If this succeeds, 0 is returned.  If this fails (most likely
! 		because {lnum} is invalid) 1 is returned.
! 
! 		Example: >
  			:call setline(5, strftime("%c"))
+ 
  <		When {text} is a |List| then line {lnum} and following lines
  		will be set to the items in the list.  Example: >
  			:call setline(5, ['aaa', 'bbb', 'ccc'])
*** ../vim-8.0.1038/src/testdir/test_bufline.vim	2017-09-02 19:42:25.382450060 +0200
--- src/testdir/test_bufline.vim	2017-09-02 19:36:15.196902841 +0200
***************
*** 0 ****
--- 1,26 ----
+ " Tests for setbufline() and getbufline()
+ 
+ func Test_setbufline_getbufline()
+   new
+   let b = bufnr('%')
+   hide
+   call assert_equal(0, setbufline(b, 1, ['foo', 'bar']))
+   call assert_equal(['foo'], getbufline(b, 1))
+   call assert_equal(['bar'], getbufline(b, 2))
+   call assert_equal(['foo', 'bar'], getbufline(b, 1, 2))
+   exe "bd!" b
+   call assert_equal([], getbufline(b, 1, 2))
+ 
+   split Xtest
+   call setline(1, ['a', 'b', 'c'])
+   let b = bufnr('%')
+   wincmd w
+   call assert_equal(1, setbufline(b, 5, ['x']))
+   call assert_equal(1, setbufline(1234, 1, ['x']))
+   call assert_equal(0, setbufline(b, 4, ['d', 'e']))
+   call assert_equal(['c'], getbufline(b, 3))
+   call assert_equal(['d'], getbufline(b, 4))
+   call assert_equal(['e'], getbufline(b, 5))
+   call assert_equal([], getbufline(b, 6))
+   exe "bwipe! " . b
+ endfunc
*** ../vim-8.0.1038/src/Makefile	2017-08-30 20:21:54.254963240 +0200
--- src/Makefile	2017-09-02 18:42:13.402276729 +0200
***************
*** 2122,2127 ****
--- 2122,2128 ----
  	test_autocmd \
  	test_backspace_opt \
  	test_breakindent \
+ 	test_bufline \
  	test_bufwintabinfo \
  	test_cd \
  	test_cdo \
*** ../vim-8.0.1038/src/testdir/test_alot.vim	2017-08-19 15:05:16.048003367 +0200
--- src/testdir/test_alot.vim	2017-09-02 18:42:38.798110346 +0200
***************
*** 3,8 ****
--- 3,9 ----
  
  set belloff=all
  source test_assign.vim
+ source test_bufline.vim
  source test_cd.vim
  source test_changedtick.vim
  source test_cursor_func.vim
*** ../vim-8.0.1038/src/version.c	2017-09-02 18:33:52.457554443 +0200
--- src/version.c	2017-09-02 19:42:08.978558740 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     1039,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
52. You ask a plumber how much it would cost to replace the chair in front of
    your computer with a toilet.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
