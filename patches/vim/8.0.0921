To: vim_dev@googlegroups.com
Subject: Patch 8.0.0921
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0921
Problem:    Terminal window cursor shape not supported in the GUI.
Solution:   Use the terminal window cursor shape in the GUI.
Files:      src/terminal.c, src/proto/terminal.pro, src/gui.c, src/syntax.c,
            src/proto/syntax.pro


*** ../vim-8.0.0920/src/terminal.c	2017-08-12 21:15:30.717568729 +0200
--- src/terminal.c	2017-08-12 22:50:07.299390908 +0200
***************
*** 1163,1173 ****
--- 1163,1219 ----
      }
  }
  
+ #if defined(FEAT_GUI) || defined(PROTO)
+ /*
+  * Return TRUE when the cursor of the terminal should be displayed.
+  */
+     int
+ use_terminal_cursor()
+ {
+     return in_terminal_loop != NULL;
+ }
+ 
+     cursorentry_T *
+ term_get_cursor_shape(guicolor_T *fg, guicolor_T *bg)
+ {
+     term_T		 *term = in_terminal_loop;
+     static cursorentry_T entry;
+ 
+     vim_memset(&entry, 0, sizeof(entry));
+     entry.shape = entry.mshape =
+ 	term->tl_cursor_shape == VTERM_PROP_CURSORSHAPE_UNDERLINE ? SHAPE_HOR :
+ 	term->tl_cursor_shape == VTERM_PROP_CURSORSHAPE_BAR_LEFT ? SHAPE_VER :
+ 	SHAPE_BLOCK;
+     entry.percentage = 20;
+     if (term->tl_cursor_blink)
+     {
+ 	entry.blinkwait = 700;
+ 	entry.blinkon = 400;
+ 	entry.blinkon = 250;
+     }
+     *fg = gui.back_pixel;
+     if (term->tl_cursor_color == NULL)
+ 	*bg = gui.norm_pixel;
+     else
+ 	*bg = color_name2handle(term->tl_cursor_color);
+     entry.name = "n";
+     entry.used_for = SHAPE_CURSOR;
+ 
+     return &entry;
+ }
+ #endif
+ 
  static int did_change_cursor = FALSE;
  
      static void
  may_set_cursor_props(term_T *term)
  {
+ #ifdef FEAT_GUI
+     /* For the GUI the cursor properties are obtained with
+      * term_get_cursor_shape(). */
+     if (gui.in_use)
+ 	return;
+ #endif
      if (in_terminal_loop == term)
      {
  	did_change_cursor = TRUE;
***************
*** 1184,1189 ****
--- 1230,1239 ----
      static void
  may_restore_cursor_props(void)
  {
+ #ifdef FEAT_GUI
+     if (gui.in_use)
+ 	return;
+ #endif
      if (did_change_cursor)
      {
  	did_change_cursor = FALSE;
***************
*** 1241,1246 ****
--- 1291,1298 ----
  	if (!term_use_loop())
  	    /* job finished while waiting for a character */
  	    break;
+ 	if (c == K_IGNORE)
+ 	    continue;
  
  #ifdef UNIX
  	may_send_sigint(c, curbuf->b_term->tl_job->jv_pid, 0);
***************
*** 1447,1453 ****
  
  	case VTERM_PROP_CURSORCOLOR:
  	    vim_free(term->tl_cursor_color);
! 	    term->tl_cursor_color = vim_strsave((char_u *)value->string);
  	    may_set_cursor_props(term);
  	    break;
  
--- 1499,1508 ----
  
  	case VTERM_PROP_CURSORCOLOR:
  	    vim_free(term->tl_cursor_color);
! 	    if (*value->string == NUL)
! 		term->tl_cursor_color = NULL;
! 	    else
! 		term->tl_cursor_color = vim_strsave((char_u *)value->string);
  	    may_set_cursor_props(term);
  	    break;
  
*** ../vim-8.0.0920/src/proto/terminal.pro	2017-08-11 16:24:46.312283924 +0200
--- src/proto/terminal.pro	2017-08-12 22:50:05.803400009 +0200
***************
*** 6,11 ****
--- 6,13 ----
  int term_in_normal_mode(void);
  void term_enter_job_mode(void);
  int send_keys_to_term(term_T *term, int c, int typed);
+ int use_terminal_cursor(void);
+ cursorentry_T *term_get_cursor_shape(guicolor_T *fg, guicolor_T *bg);
  int term_use_loop(void);
  int terminal_loop(void);
  void term_job_ended(job_T *job);
*** ../vim-8.0.0920/src/gui.c	2017-06-17 18:44:17.002000920 +0200
--- src/gui.c	2017-08-12 22:47:23.028390411 +0200
***************
*** 1051,1058 ****
      int		cur_width = 0;
      int		cur_height = 0;
      int		old_hl_mask;
!     int		idx;
      int		id;
      guicolor_T	cfg, cbg, cc;	/* cursor fore-/background color */
      int		cattr;		/* cursor attributes */
      int		attr;
--- 1051,1062 ----
      int		cur_width = 0;
      int		cur_height = 0;
      int		old_hl_mask;
!     cursorentry_T *shape;
      int		id;
+ #ifdef FEAT_TERMINAL
+     guicolor_T	shape_fg = INVALCOLOR;
+     guicolor_T	shape_bg = INVALCOLOR;
+ #endif
      guicolor_T	cfg, cbg, cc;	/* cursor fore-/background color */
      int		cattr;		/* cursor attributes */
      int		attr;
***************
*** 1094,1113 ****
  
  	/*
  	 * How the cursor is drawn depends on the current mode.
  	 */
! 	idx = get_shape_idx(FALSE);
  	if (State & LANGMAP)
! 	    id = shape_table[idx].id_lm;
  	else
! 	    id = shape_table[idx].id;
  
  	/* get the colors and attributes for the cursor.  Default is inverted */
  	cfg = INVALCOLOR;
  	cbg = INVALCOLOR;
  	cattr = HL_INVERSE;
! 	gui_mch_set_blinking(shape_table[idx].blinkwait,
! 			     shape_table[idx].blinkon,
! 			     shape_table[idx].blinkoff);
  	if (id > 0)
  	{
  	    cattr = syn_id2colors(id, &cfg, &cbg);
--- 1098,1132 ----
  
  	/*
  	 * How the cursor is drawn depends on the current mode.
+ 	 * When in a terminal window use the shape/color specified there.
  	 */
! #ifdef FEAT_TERMINAL
! 	if (use_terminal_cursor())
! 	    shape = term_get_cursor_shape(&shape_fg, &shape_bg);
! 	else
! #endif
! 	    shape = &shape_table[get_shape_idx(FALSE)];
  	if (State & LANGMAP)
! 	    id = shape->id_lm;
  	else
! 	    id = shape->id;
  
  	/* get the colors and attributes for the cursor.  Default is inverted */
  	cfg = INVALCOLOR;
  	cbg = INVALCOLOR;
  	cattr = HL_INVERSE;
! 	gui_mch_set_blinking(shape->blinkwait,
! 			     shape->blinkon,
! 			     shape->blinkoff);
! #ifdef FEAT_TERMINAL
! 	if (shape_bg != INVALCOLOR)
! 	{
! 	    cattr = 0;
! 	    cfg = shape_fg;
! 	    cbg = shape_bg;
! 	}
! 	else
! #endif
  	if (id > 0)
  	{
  	    cattr = syn_id2colors(id, &cfg, &cbg);
***************
*** 1202,1208 ****
  	}
  
  	old_hl_mask = gui.highlight_mask;
! 	if (shape_table[idx].shape == SHAPE_BLOCK
  #ifdef FEAT_HANGULIN
  		|| composing_hangul
  #endif
--- 1221,1227 ----
  	}
  
  	old_hl_mask = gui.highlight_mask;
! 	if (shape->shape == SHAPE_BLOCK
  #ifdef FEAT_HANGULIN
  		|| composing_hangul
  #endif
***************
*** 1242,1257 ****
  	     * First draw the partial cursor, then overwrite with the text
  	     * character, using a transparent background.
  	     */
! 	    if (shape_table[idx].shape == SHAPE_VER)
  	    {
  		cur_height = gui.char_height;
! 		cur_width = (gui.char_width * shape_table[idx].percentage
! 								  + 99) / 100;
  	    }
  	    else
  	    {
! 		cur_height = (gui.char_height * shape_table[idx].percentage
! 								  + 99) / 100;
  		cur_width = gui.char_width;
  	    }
  #ifdef FEAT_MBYTE
--- 1261,1274 ----
  	     * First draw the partial cursor, then overwrite with the text
  	     * character, using a transparent background.
  	     */
! 	    if (shape->shape == SHAPE_VER)
  	    {
  		cur_height = gui.char_height;
! 		cur_width = (gui.char_width * shape->percentage + 99) / 100;
  	    }
  	    else
  	    {
! 		cur_height = (gui.char_height * shape->percentage + 99) / 100;
  		cur_width = gui.char_width;
  	    }
  #ifdef FEAT_MBYTE
***************
*** 1259,1265 ****
  				    LineOffset[gui.row] + screen_Columns) > 1)
  	    {
  		/* Double wide character. */
! 		if (shape_table[idx].shape != SHAPE_VER)
  		    cur_width += gui.char_width;
  # ifdef FEAT_RIGHTLEFT
  		if (CURSOR_BAR_RIGHT)
--- 1276,1282 ----
  				    LineOffset[gui.row] + screen_Columns) > 1)
  	    {
  		/* Double wide character. */
! 		if (shape->shape != SHAPE_VER)
  		    cur_width += gui.char_width;
  # ifdef FEAT_RIGHTLEFT
  		if (CURSOR_BAR_RIGHT)
***************
*** 1728,1734 ****
      void
  gui_update_cursor_later(void)
  {
!  OUT_STR(IF_EB("\033|s", ESC_STR "|s"));
  }
  
      void
--- 1745,1751 ----
      void
  gui_update_cursor_later(void)
  {
!     OUT_STR(IF_EB("\033|s", ESC_STR "|s"));
  }
  
      void
*** ../vim-8.0.0920/src/syntax.c	2017-08-12 15:12:26.535991914 +0200
--- src/syntax.c	2017-08-12 21:50:36.788948996 +0200
***************
*** 103,109 ****
  
  #if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)
  static void gui_do_one_color(int idx, int do_menu, int do_tooltip);
- static guicolor_T color_name2handle(char_u *name);
  #endif
  #ifdef FEAT_GUI
  static int  set_group_colors(char_u *name, guicolor_T *fgp, guicolor_T *bgp, int do_menu, int use_norm, int do_tooltip);
--- 103,108 ----
***************
*** 8622,8628 ****
   * Return the handle for a color name.
   * Returns INVALCOLOR when failed.
   */
!     static guicolor_T
  color_name2handle(char_u *name)
  {
      if (STRCMP(name, "NONE") == 0)
--- 8621,8627 ----
   * Return the handle for a color name.
   * Returns INVALCOLOR when failed.
   */
!     guicolor_T
  color_name2handle(char_u *name)
  {
      if (STRCMP(name, "NONE") == 0)
*** ../vim-8.0.0920/src/proto/syntax.pro	2017-08-01 18:03:59.830694237 +0200
--- src/proto/syntax.pro	2017-08-12 21:50:55.996833536 +0200
***************
*** 32,37 ****
--- 32,38 ----
  void hl_set_font_name(char_u *font_name);
  void hl_set_bg_color_name(char_u *name);
  void hl_set_fg_color_name(char_u *name);
+ guicolor_T color_name2handle(char_u *name);
  int get_cterm_attr_idx(int attr, int fg, int bg);
  int get_tgc_attr_idx(int attr, guicolor_T fg, guicolor_T bg);
  int get_gui_attr_idx(int attr, guicolor_T fg, guicolor_T bg);
*** ../vim-8.0.0920/src/version.c	2017-08-12 21:15:30.717568729 +0200
--- src/version.c	2017-08-12 21:36:08.210212922 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     921,
  /**/

-- 
"Software is like sex... it's better when it's free."
		-- Linus Torvalds, initiator of the free Linux OS
Makes me wonder what FSF stands for...?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
