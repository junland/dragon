To: vim_dev@googlegroups.com
Subject: Patch 8.0.1186
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1186
Problem:    Still quite a few old style tests.
Solution:   Convert old to new style tests. (Yegappan Lakshmanan)
            Avoid ringing the bell while running tests.
Files:      src/Makefile, src/testdir/Make_all.mak, src/testdir/Make_ming.mak,
            src/testdir/Make_vms.mms, src/testdir/main.aap,
            src/testdir/test31.in, src/testdir/test31.ok,
            src/testdir/test4.in, src/testdir/test4.ok, src/testdir/test5.in,
            src/testdir/test5.ok, src/testdir/test60.in,
            src/testdir/test60.ok, src/testdir/test60.vim,
            src/testdir/test7.in, src/testdir/test7.ok, src/testdir/test78.in,
            src/testdir/test78.ok, src/testdir/test_autocmd.vim,
            src/testdir/test_exists.vim, src/testdir/test_recover.vim,
            src/testdir/test_winbuf_close.vim, src/testdir/runtest.vim


*** ../vim-8.0.1185/src/Makefile	2017-09-28 21:51:52.574655020 +0200
--- src/Makefile	2017-10-12 20:30:58.181021307 +0200
***************
*** 2100,2113 ****
  	test_listchars \
  	test_search_mbyte \
  	test_wordcount \
! 	test3 test4 test5 test7 test8 \
  	test11 test12 test14 test15 test17 test19 \
  	test20 test25 test28 test29 \
! 	test30 test31 test32 test34 test36 test37 test38 test39 \
  	test40 test42 test44 test45 test48 test49 \
  	test50 test52 test54 test55 test59 \
! 	test60 test64 test66 test68 test69 \
! 	test70 test72 test73 test77 test78 test79 \
  	test83 test85 test86 test87 test88 \
  	test94 test95 test99 \
  	test108:
--- 2101,2114 ----
  	test_listchars \
  	test_search_mbyte \
  	test_wordcount \
! 	test3 test8 \
  	test11 test12 test14 test15 test17 test19 \
  	test20 test25 test28 test29 \
! 	test30 test32 test34 test36 test37 test38 test39 \
  	test40 test42 test44 test45 test48 test49 \
  	test50 test52 test54 test55 test59 \
! 	test64 test66 test68 test69 \
! 	test70 test72 test73 test77 test79 \
  	test83 test85 test86 test87 test88 \
  	test94 test95 test99 \
  	test108:
***************
*** 2149,2154 ****
--- 2150,2156 ----
  	test_ex_z \
  	test_exec_while_if \
  	test_execute_func \
+ 	test_exists \
  	test_exists_autocmd \
  	test_expand \
  	test_expand_dllpath \
***************
*** 2279,2284 ****
--- 2281,2287 ----
  	test_virtualedit \
  	test_visual \
  	test_winbar \
+ 	test_winbuf_close \
  	test_window_cmd \
  	test_window_id \
  	test_windows_home \
*** ../vim-8.0.1185/src/testdir/Make_all.mak	2017-09-28 21:51:52.574655020 +0200
--- src/testdir/Make_all.mak	2017-10-12 20:30:58.181021307 +0200
***************
*** 14,22 ****
  # Tests that run on all systems.
  SCRIPTS_ALL = \
  	test3.out \
- 	test4.out \
- 	test5.out \
- 	test7.out \
  	test8.out \
  	test14.out \
  	test15.out \
--- 14,19 ----
***************
*** 24,30 ****
  	test20.out \
  	test28.out \
  	test29.out \
- 	test31.out \
  	test34.out \
  	test36.out \
  	test37.out \
--- 21,26 ----
***************
*** 36,42 ****
  	test45.out \
  	test48.out \
  	test55.out \
- 	test60.out \
  	test64.out \
  	test66.out \
  	test68.out \
--- 32,37 ----
***************
*** 89,95 ****
  	test32.out \
  	test59.out \
  	test72.out \
- 	test78.out \
  	test83.out
  
  
--- 84,89 ----
***************
*** 125,130 ****
--- 119,125 ----
  	    test_digraph.res \
  	    test_display.res \
  	    test_edit.res \
+ 	    test_exists.res \
  	    test_farsi.res \
  	    test_file_size.res \
  	    test_fnameescape.res \
***************
*** 196,201 ****
--- 191,197 ----
  	    test_vimscript.res \
  	    test_visual.res \
  	    test_winbar.res \
+ 	    test_winbuf_close.res \
  	    test_window_id.res \
  	    test_windows_home.res \
  	    test_writefile.res \
***************
*** 207,212 ****
  # Explicit dependencies.
  test49.out: test49.vim
  
- test60.out: test60.vim
- 
  test_options.res test_alot.res: opt_test.vim
--- 203,206 ----
*** ../vim-8.0.1185/src/testdir/Make_ming.mak	2017-10-07 21:05:14.371150972 +0200
--- src/testdir/Make_ming.mak	2017-10-12 20:30:58.181021307 +0200
***************
*** 68,74 ****
  fixff:
  	-$(VIMPROG) -u dos.vim $(NO_INITS) "+argdo set ff=dos|upd" +q *.in *.ok
  	-$(VIMPROG) -u dos.vim $(NO_INITS) "+argdo set ff=unix|upd" +q \
! 		dotest.in test60.ok test_listchars.ok \
  		test_wordcount.ok
  
  clean:
--- 68,74 ----
  fixff:
  	-$(VIMPROG) -u dos.vim $(NO_INITS) "+argdo set ff=dos|upd" +q *.in *.ok
  	-$(VIMPROG) -u dos.vim $(NO_INITS) "+argdo set ff=unix|upd" +q \
! 		dotest.in test_listchars.ok \
  		test_wordcount.ok
  
  clean:
*** ../vim-8.0.1185/src/testdir/Make_vms.mms	2017-09-28 21:51:52.574655020 +0200
--- src/testdir/Make_vms.mms	2017-10-12 20:30:58.181021307 +0200
***************
*** 73,92 ****
  
  .SUFFIXES : .out .in
  
! SCRIPT = test1.out  test3.out  test4.out  test5.out  \
!        test7.out  test8.out  \
         test14.out test15.out \
         test19.out test20.out \
!        test28.out test29.out test30.out test31.out test32.out \
         test34.out test36.out test37.out \
         test38.out test39.out test40.out test42.out \
         test44.out test45.out \
         test48.out test49.out test54.out \
!        test55.out test60.out \
         test64.out \
         test66.out test68.out test69.out \
         test72.out \
!        test77a.out test78.out test79.out \
         test88.out \
         test94.out \
         test95.out test99.out \
--- 73,92 ----
  
  .SUFFIXES : .out .in
  
! SCRIPT = test1.out test3.out \
!        test8.out  \
         test14.out test15.out \
         test19.out test20.out \
!        test28.out test29.out test30.out test32.out \
         test34.out test36.out test37.out \
         test38.out test39.out test40.out test42.out \
         test44.out test45.out \
         test48.out test49.out test54.out \
!        test55.out \
         test64.out \
         test66.out test68.out test69.out \
         test72.out \
!        test77a.out test79.out \
         test88.out \
         test94.out \
         test95.out test99.out \
*** ../vim-8.0.1185/src/testdir/main.aap	2017-09-28 21:51:52.574655020 +0200
--- src/testdir/main.aap	2017-10-12 20:30:58.185021281 +0200
***************
*** 4,15 ****
  
  VimProg ?= ../vim
  
! Scripts = test1.out test2.out test3.out test4.out test5.out test6.out
! 		test7.out test8.out test11.out
  		test12.out  test13.out test14.out test15.out test17.out
  		test18.out test19.out test20.out test21.out
  		test25.out test27.out
! 		test28.out test29.out test30.out test31.out test32.out
  		test34.out test36.out test37.out
  		test38.out test39.out test40.out test42.out
  		test44.out test45.out test46.out test47.out
--- 4,15 ----
  
  VimProg ?= ../vim
  
! Scripts = test1.out test2.out test3.out test6.out
! 		test8.out test11.out
  		test12.out  test13.out test14.out test15.out test17.out
  		test18.out test19.out test20.out test21.out
  		test25.out test27.out
! 		test28.out test29.out test30.out test32.out
  		test34.out test36.out test37.out
  		test38.out test39.out test40.out test42.out
  		test44.out test45.out test46.out test47.out
*** ../vim-8.0.1185/src/testdir/test31.in	2016-01-03 14:31:14.000000000 +0100
--- src/testdir/test31.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,95 ****
- Test for commands that close windows and/or buffers:
- :quit
- :close
- :hide
- :only
- :sall
- :all
- :ball
- :buf
- :edit
- 
- STARTTEST
- :so small.vim
- GA 1:$w! Xtest1
- $r2:$w! Xtest2
- $r3:$w! Xtest3
- :n! Xtest1 Xtest2
- A 1:set hidden
- :" test for working :n when hidden set; write "testtext 2"
- :n
- :w! test.out
- :" test for failing :rew when hidden not set; write "testtext 2 2"
- :set nohidden
- A 2:rew
- :w >>test.out
- :" test for working :rew when hidden set; write "testtext 1 1"
- :set hidden
- :rew
- :w >>test.out
- :" test for :all keeping a buffer when it's modified; write "testtext 1 1 1"
- :set nohidden
- A 1:sp
- :n Xtest2 Xtest3
- :all
- :1wincmd w
- :w >>test.out
- :" test abandoning changed buffer, should be unloaded even when 'hidden' set
- :" write "testtext 2 2" twice
- :set hidden
- A 1:q!
- :w >>test.out
- :unhide
- :w >>test.out
- :" test ":hide" hides anyway when 'hidden' not set; write "testtext 3"
- :set nohidden
- A 2:hide
- :w >>test.out
- :" test ":edit" failing in modified buffer when 'hidden' not set
- :" write "testtext 3 3"
- A 3:e Xtest1
- :w >>test.out
- :" test ":edit" working in modified buffer when 'hidden' set; write "testtext 1"
- :set hidden
- :e Xtest1
- :w >>test.out
- :" test ":close" not hiding when 'hidden' not set in modified buffer;
- :" write "testtext 3 3 3"
- :sp Xtest3
- :set nohidden
- A 3:close
- :w >>test.out
- :" test ":close!" does hide when 'hidden' not set in modified buffer;
- :" write "testtext 1"
- A 3:close!
- :w >>test.out
- :set nohidden
- :" test ":all!" hides changed buffer; write "testtext 2 2 2"
- :sp Xtest4
- GA 4:all!
- :1wincmd w
- :w >>test.out
- :"
- :" test ":q!" and hidden buffer.
- :bw! Xtest1 Xtest2 Xtest3 Xtest4
- :sp Xtest1
- :wincmd w
- :bw!
- :set modified
- :bot sp Xtest2
- :set modified
- :bot sp Xtest3
- :set modified
- :wincmd t
- :hide
- :q!
- :w >>test.out
- :q!
- :w >>test.out
- :q!
- :call append(line('$'), "Oh, Not finished yet.")
- :w >>test.out
- :qa!
- ENDTEST
- 
- testtext
--- 0 ----
*** ../vim-8.0.1185/src/testdir/test31.ok	2016-01-02 22:13:18.000000000 +0100
--- src/testdir/test31.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,14 ****
- testtext 2
- testtext 2 2
- testtext 1 1
- testtext 1 1 1
- testtext 2 2
- testtext 2 2
- testtext 3
- testtext 3 3
- testtext 1
- testtext 3 3 3
- testtext 1
- testtext 2 2 2
- testtext 3
- testtext 1
--- 0 ----
*** ../vim-8.0.1185/src/testdir/test4.in	2015-08-11 18:30:19.000000000 +0200
--- src/testdir/test4.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,34 ****
- Test for autocommand that changes current buffer on BufEnter event.
- Check if modelines are interpreted for the correct buffer.
- 
- STARTTEST
- :so small.vim
- :set nocompatible viminfo+=nviminfo
- :au BufEnter Xxx brew
- /start of
- :.,/end of/w! Xxx   " write test file Xxx
- :set ai modeline modelines=3
- :sp Xxx             " split to Xxx, autocmd will do :brew
- G?this is a
- othis should be auto-indented
- :                   " Append text with autoindent to this file
- :au! BufEnter Xxx
- :buf Xxx            " go to Xxx, no autocmd anymore
- G?this is a
- othis should be in column 1:wq " append text without autoindent to Xxx
- G:r Xxx             " include Xxx in the current file
- :set fo+=r          " issue #57 do not move cursor on <c-o> when autoindent is set
- Go# abcdef2hi
- d0o# abcdef2hid0:
- :?startstart?,$w! test.out
- :qa!
- ENDTEST
- 
- startstart
- start of test file Xxx
- vim: set noai :
- 	this is a test
- 	this is a test
- 	this is a test
- 	this is a test
- end of test file Xxx
--- 0 ----
*** ../vim-8.0.1185/src/testdir/test4.ok	2014-10-31 19:10:21.000000000 +0100
--- src/testdir/test4.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,20 ****
- startstart
- start of test file Xxx
- vim: set noai :
- 	this is a test
- 	this is a test
- 	this is a test
- 	this is a test
- 	this should be auto-indented
- end of test file Xxx
- start of test file Xxx
- vim: set noai :
- 	this is a test
- 	this is a test
- 	this is a test
- 	this is a test
- this should be in column 1
- end of test file Xxx
- # abc
- def
- def
--- 0 ----
*** ../vim-8.0.1185/src/testdir/test5.in	2010-05-15 13:04:10.000000000 +0200
--- src/testdir/test5.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,29 ****
- Test for autocommand that deletes the current buffer on BufLeave event.
- Also test deleting the last buffer, should give a new, empty buffer.
- 
- STARTTEST
- :so small.vim
- :au BufLeave Xxx bwipe
- /start of
- :.,/end of/w! Xxx               " write test file Xxx
- :sp Xxx                         " split to Xxx
- :bwipe                          " delete buffer Xxx, now we're back here
- G?this is a
- othis is some more text
- :                               " Append some text to this file
- :?start?,$w! test.out           " Write current file contents
- :bwipe test.out                 " delete alternate buffer
- :au bufleave test5.in bwipe
- :bwipe!                         " delete current buffer, get an empty one
- ithis is another test line:w >>test.out
- :                               " append an extra line to the output file
- :qa!
- ENDTEST
- 
- start of test file Xxx
- vim: set noai :
- 	this is a test
- 	this is a test
- 	this is a test
- 	this is a test
- end of test file Xxx
--- 0 ----
*** ../vim-8.0.1185/src/testdir/test5.ok	2010-05-15 13:04:10.000000000 +0200
--- src/testdir/test5.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,9 ****
- start of test file Xxx
- vim: set noai :
- 	this is a test
- 	this is a test
- 	this is a test
- 	this is a test
- this is some more text
- end of test file Xxx
- this is another test line
--- 0 ----
*** ../vim-8.0.1185/src/testdir/test60.in	2016-03-26 21:21:08.000000000 +0100
--- src/testdir/test60.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,601 ****
- Tests for the exists() and has() functions.  vim: set ft=vim ts=8 sw=2 :
- 
- STARTTEST
- :so small.vim
- :function! RunTest(str, result)
-     if exists(a:str) == a:result
- 	echo "OK"
-     else
- 	echo "FAILED: Checking for " . a:str
-     endif
- endfunction
- :function! TestExists()
-     augroup myagroup
- 	autocmd! BufEnter       *.my     echo "myfile edited"
- 	autocmd! FuncUndefined  UndefFun exec "fu UndefFun()\nendfu"
-     augroup END
-     set rtp+=./sautest
- 
-     let test_cases = []
- 
-     " valid autocmd group
-     let test_cases += [['#myagroup', 1]]
-     " valid autocmd group with garbage
-     let test_cases += [['#myagroup+b', 0]]
-     " Valid autocmd group and event
-     let test_cases += [['#myagroup#BufEnter', 1]]
-     " Valid autocmd group, event and pattern
-     let test_cases += [['#myagroup#BufEnter#*.my', 1]]
-     " Valid autocmd event
-     let test_cases += [['#BufEnter', 1]]
-     " Valid autocmd event and pattern
-     let test_cases += [['#BufEnter#*.my', 1]]
-     " Non-existing autocmd group or event
-     let test_cases += [['#xyzagroup', 0]]
-     " Non-existing autocmd group and valid autocmd event
-     let test_cases += [['#xyzagroup#BufEnter', 0]]
-     " Valid autocmd group and event with no matching pattern
-     let test_cases += [['#myagroup#CmdwinEnter', 0]]
-     " Valid autocmd group and non-existing autocmd event
-     let test_cases += [['#myagroup#xyzacmd', 0]]
-     " Valid autocmd group and event and non-matching pattern
-     let test_cases += [['#myagroup#BufEnter#xyzpat', 0]]
-     " Valid autocmd event and non-matching pattern
-     let test_cases += [['#BufEnter#xyzpat', 0]]
-     " Empty autocmd group, event and pattern
-     let test_cases += [['###', 0]]
-     " Empty autocmd group and event or empty event and pattern
-     let test_cases += [['##', 0]]
-     " Valid autocmd event
-     let test_cases += [['##FileReadCmd', 1]]
-     " Non-existing autocmd event
-     let test_cases += [['##MySpecialCmd', 0]]
- 
-     " Existing and working option (long form)
-     let test_cases += [['&textwidth', 1]]
-     " Existing and working option (short form)
-     let test_cases += [['&tw', 1]]
-     " Existing and working option with garbage
-     let test_cases += [['&tw-', 0]]
-     " Global option
-     let test_cases += [['&g:errorformat', 1]]
-     " Local option
-     let test_cases += [['&l:errorformat', 1]]
-     " Negative form of existing and working option (long form)
-     let test_cases += [['&nojoinspaces', 0]]
-     " Negative form of existing and working option (short form)
-     let test_cases += [['&nojs', 0]]
-     " Non-existing option
-     let test_cases += [['&myxyzoption', 0]]
- 
-     " Existing and working option (long form)
-     let test_cases += [['+incsearch', 1]]
-     " Existing and working option with garbage
-     let test_cases += [['+incsearch!1', 0]]
-     " Existing and working option (short form)
-     let test_cases += [['+is', 1]]
-     " Existing option that is hidden.
-     let test_cases += [['+autoprint', 0]]
- 
-     " Existing environment variable
-     let $EDITOR_NAME = 'Vim Editor'
-     let test_cases += [['$EDITOR_NAME', 1]]
-     " Non-existing environment variable
-     let test_cases += [['$NON_ENV_VAR', 0]]
- 
-     " Valid internal function
-     let test_cases += [['*bufnr', 1]]
-     " Valid internal function with ()
-     let test_cases += [['*bufnr()', 1]]
-     " Non-existing internal function
-     let test_cases += [['*myxyzfunc', 0]]
-     " Valid internal function with garbage
-     let test_cases += [['*bufnr&6', 0]]
- 
-     " Valid user defined function
-     let test_cases += [['*TestExists', 1]]
-     " Non-existing user defined function
-     let test_cases += [['*MyxyzFunc', 0]]
- 
-     " Function that may be created by FuncUndefined event
-     let test_cases += [['*UndefFun', 0]]
-     " Function that may be created by script autoloading
-     let test_cases += [['*footest#F', 0]]
- 
-     redir! > test.out
- 
-     for [test_case, result] in test_cases
-         echo test_case . ": " . result
-         call RunTest(test_case, result)
-     endfor
- 
-     " Valid internal command (full match)
-     echo ':edit: 2'
-     if exists(':edit') == 2
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Valid internal command (full match) with garbage
-     echo ':edit/a: 0'
-     if exists(':edit/a') == 0
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Valid internal command (partial match)
-     echo ':q: 1'
-     if exists(':q') == 1
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing internal command
-     echo ':invalidcmd: 0'
-     if !exists(':invalidcmd')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " User defined command (full match)
-     command! MyCmd :echo 'My command'
-     echo ':MyCmd: 2'
-     if exists(':MyCmd') == 2
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " User defined command (partial match)
-     command! MyOtherCmd :echo 'Another command'
-     echo ':My: 3'
-     if exists(':My') == 3
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Command modifier
-     echo ':rightbelow: 2'
-     if exists(':rightbelow') == 2
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing user defined command (full match)
-     delcommand MyCmd
- 
-     echo ':MyCmd: 0'
-     if !exists(':MyCmd')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing user defined command (partial match)
-     delcommand MyOtherCmd
- 
-     echo ':My: 0'
-     if !exists(':My')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Valid local variable
-     let local_var = 1
-     echo 'local_var: 1'
-     if exists('local_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Valid local variable with garbage
-     let local_var = 1
-     echo 'local_var%n: 0'
-     if !exists('local_var%n')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing local variable
-     unlet local_var
-     echo 'local_var: 0'
-     if !exists('local_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing autoload variable that may be autoloaded
-     echo 'footest#x: 0'
-     if !exists('footest#x')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Valid local list
-     let local_list = ["blue", "orange"]
-     echo 'local_list: 1'
-     if exists('local_list')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Valid local list item
-     echo 'local_list[1]: 1'
-     if exists('local_list[1]')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Valid local list item with garbage
-     echo 'local_list[1]+5: 0'
-     if !exists('local_list[1]+5')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Invalid local list item
-     echo 'local_list[2]: 0'
-     if !exists('local_list[2]')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing local list
-     unlet local_list
-     echo 'local_list: 0'
-     if !exists('local_list')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Valid local dictionary
-     let local_dict = {"xcord":100, "ycord":2}
-     echo 'local_dict: 1'
-     if exists('local_dict')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing local dictionary
-     unlet local_dict
-     echo 'local_dict: 0'
-     if !exists('local_dict')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Existing local curly-brace variable
-     let str = "local"
-     let curly_{str}_var = 1
-     echo 'curly_' . str . '_var: 1'
-     if exists('curly_{str}_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing local curly-brace variable
-     unlet curly_{str}_var
-     echo 'curly_' . str . '_var: 0'
-     if !exists('curly_{str}_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
- 
-     " Existing global variable
-     let g:global_var = 1
-     echo 'g:global_var: 1'
-     if exists('g:global_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Existing global variable with garbage
-     echo 'g:global_var-n: 1'
-     if !exists('g:global_var-n')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing global variable
-     unlet g:global_var
-     echo 'g:global_var: 0'
-     if !exists('g:global_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Existing global list
-     let g:global_list = ["blue", "orange"]
-     echo 'g:global_list: 1'
-     if exists('g:global_list')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing global list
-     unlet g:global_list
-     echo 'g:global_list: 0'
-     if !exists('g:global_list')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Existing global dictionary
-     let g:global_dict = {"xcord":100, "ycord":2}
-     echo 'g:global_dict: 1'
-     if exists('g:global_dict')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing global dictionary
-     unlet g:global_dict
-     echo 'g:global_dict: 0'
-     if !exists('g:global_dict')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Existing global curly-brace variable
-     let str = "global"
-     let g:curly_{str}_var = 1
-     echo 'g:curly_' . str . '_var: 1'
-     if exists('g:curly_{str}_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing global curly-brace variable
-     unlet g:curly_{str}_var
-     echo 'g:curly_' . str . '_var: 0'
-     if !exists('g:curly_{str}_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Existing window variable
-     echo 'w:window_var: 1'
-     let w:window_var = 1
-     if exists('w:window_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing window variable
-     unlet w:window_var
-     echo 'w:window_var: 0'
-     if !exists('w:window_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Existing window list
-     let w:window_list = ["blue", "orange"]
-     echo 'w:window_list: 1'
-     if exists('w:window_list')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing window list
-     unlet w:window_list
-     echo 'w:window_list: 0'
-     if !exists('w:window_list')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Existing window dictionary
-     let w:window_dict = {"xcord":100, "ycord":2}
-     echo 'w:window_dict: 1'
-     if exists('w:window_dict')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing window dictionary
-     unlet w:window_dict
-     echo 'w:window_dict: 0'
-     if !exists('w:window_dict')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Existing window curly-brace variable
-     let str = "window"
-     let w:curly_{str}_var = 1
-     echo 'w:curly_' . str . '_var: 1'
-     if exists('w:curly_{str}_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing window curly-brace variable
-     unlet w:curly_{str}_var
-     echo 'w:curly_' . str . '_var: 0'
-     if !exists('w:curly_{str}_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Existing buffer variable
-     echo 'b:buffer_var: 1'
-     let b:buffer_var = 1
-     if exists('b:buffer_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing buffer variable
-     unlet b:buffer_var
-     echo 'b:buffer_var: 0'
-     if !exists('b:buffer_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Existing buffer list
-     let b:buffer_list = ["blue", "orange"]
-     echo 'b:buffer_list: 1'
-     if exists('b:buffer_list')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing buffer list
-     unlet b:buffer_list
-     echo 'b:buffer_list: 0'
-     if !exists('b:buffer_list')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Existing buffer dictionary
-     let b:buffer_dict = {"xcord":100, "ycord":2}
-     echo 'b:buffer_dict: 1'
-     if exists('b:buffer_dict')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing buffer dictionary
-     unlet b:buffer_dict
-     echo 'b:buffer_dict: 0'
-     if !exists('b:buffer_dict')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Existing buffer curly-brace variable
-     let str = "buffer"
-     let b:curly_{str}_var = 1
-     echo 'b:curly_' . str . '_var: 1'
-     if exists('b:curly_{str}_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing buffer curly-brace variable
-     unlet b:curly_{str}_var
-     echo 'b:curly_' . str . '_var: 0'
-     if !exists('b:curly_{str}_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Script-local tests
-     source test60.vim
- 
-     " Existing Vim internal variable
-     echo 'v:version: 1'
-     if exists('v:version')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Non-existing Vim internal variable
-     echo 'v:non_exists_var: 0'
-     if !exists('v:non_exists_var')
- 	echo "OK"
-     else
- 	echo "FAILED"
-     endif
- 
-     " Function arguments
-     function TestFuncArg(func_arg, ...)
-         echo 'a:func_arg: 1'
-         if exists('a:func_arg')
-             echo "OK"
-         else
-             echo "FAILED"
-         endif
- 
-         echo 'a:non_exists_arg: 0'
-         if !exists('a:non_exists_arg')
-             echo "OK"
-         else
-             echo "FAILED"
-         endif
- 
-         echo 'a:1: 1'
-         if exists('a:1')
-             echo "OK"
-         else
-             echo "FAILED"
-         endif
- 
-         echo 'a:2: 0'
-         if !exists('a:2')
-             echo "OK"
-         else
-             echo "FAILED"
-         endif
-     endfunction
- 
-     call TestFuncArg("arg1", "arg2")
- 
-     echo ' g:footest#x =' g:footest#x
-     echo '   footest#F()' footest#F()
-     echo 'UndefFun()' UndefFun()
- 
-     redir END
- endfunction
- :call TestExists()
- :"
- :delfunc TestExists
- :delfunc RunTest
- :delfunc TestFuncArg
- :edit! test.out
- :set ff=unix
- :w
- :qa!
- :while getchar(1) | call getchar() | endwhile
- ENDTEST
- 
--- 0 ----
*** ../vim-8.0.1185/src/testdir/test60.ok	2016-03-26 21:21:02.000000000 +0100
--- src/testdir/test60.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,206 ****
- 
- #myagroup: 1
- OK
- #myagroup+b: 0
- OK
- #myagroup#BufEnter: 1
- OK
- #myagroup#BufEnter#*.my: 1
- OK
- #BufEnter: 1
- OK
- #BufEnter#*.my: 1
- OK
- #xyzagroup: 0
- OK
- #xyzagroup#BufEnter: 0
- OK
- #myagroup#CmdwinEnter: 0
- OK
- #myagroup#xyzacmd: 0
- OK
- #myagroup#BufEnter#xyzpat: 0
- OK
- #BufEnter#xyzpat: 0
- OK
- ###: 0
- OK
- ##: 0
- OK
- ##FileReadCmd: 1
- OK
- ##MySpecialCmd: 0
- OK
- &textwidth: 1
- OK
- &tw: 1
- OK
- &tw-: 0
- OK
- &g:errorformat: 1
- OK
- &l:errorformat: 1
- OK
- &nojoinspaces: 0
- OK
- &nojs: 0
- OK
- &myxyzoption: 0
- OK
- +incsearch: 1
- OK
- +incsearch!1: 0
- OK
- +is: 1
- OK
- +autoprint: 0
- OK
- $EDITOR_NAME: 1
- OK
- $NON_ENV_VAR: 0
- OK
- *bufnr: 1
- OK
- *bufnr(): 1
- OK
- *myxyzfunc: 0
- OK
- *bufnr&6: 0
- OK
- *TestExists: 1
- OK
- *MyxyzFunc: 0
- OK
- *UndefFun: 0
- OK
- *footest#F: 0
- OK
- :edit: 2
- OK
- :edit/a: 0
- OK
- :q: 1
- OK
- :invalidcmd: 0
- OK
- :MyCmd: 2
- OK
- :My: 3
- OK
- :rightbelow: 2
- OK
- :MyCmd: 0
- OK
- :My: 0
- OK
- local_var: 1
- OK
- local_var%n: 0
- OK
- local_var: 0
- OK
- footest#x: 0
- OK
- local_list: 1
- OK
- local_list[1]: 1
- OK
- local_list[1]+5: 0
- OK
- local_list[2]: 0
- OK
- local_list: 0
- OK
- local_dict: 1
- OK
- local_dict: 0
- OK
- curly_local_var: 1
- OK
- curly_local_var: 0
- OK
- g:global_var: 1
- OK
- g:global_var-n: 1
- OK
- g:global_var: 0
- OK
- g:global_list: 1
- OK
- g:global_list: 0
- OK
- g:global_dict: 1
- OK
- g:global_dict: 0
- OK
- g:curly_global_var: 1
- OK
- g:curly_global_var: 0
- OK
- w:window_var: 1
- OK
- w:window_var: 0
- OK
- w:window_list: 1
- OK
- w:window_list: 0
- OK
- w:window_dict: 1
- OK
- w:window_dict: 0
- OK
- w:curly_window_var: 1
- OK
- w:curly_window_var: 0
- OK
- b:buffer_var: 1
- OK
- b:buffer_var: 0
- OK
- b:buffer_list: 1
- OK
- b:buffer_list: 0
- OK
- b:buffer_dict: 1
- OK
- b:buffer_dict: 0
- OK
- b:curly_buffer_var: 1
- OK
- b:curly_buffer_var: 0
- OK
- s:script_var: 1
- OK
- s:script_var: 0
- OK
- s:script_list: 1
- OK
- s:script_list: 0
- OK
- s:script_dict: 1
- OK
- s:script_dict: 0
- OK
- s:curly_script_var: 1
- OK
- s:curly_script_var: 0
- OK
- *s:my_script_func: 1
- OK
- *s:my_script_func: 0
- OK
- v:version: 1
- OK
- v:non_exists_var: 0
- OK
- a:func_arg: 1
- OK
- a:non_exists_arg: 0
- OK
- a:1: 1
- OK
- a:2: 0
- OK
-  g:footest#x = 1
-    footest#F() 0
- UndefFun() 0
--- 0 ----
*** ../vim-8.0.1185/src/testdir/test60.vim	2010-05-15 13:04:10.000000000 +0200
--- src/testdir/test60.vim	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,98 ****
- " Vim script for exists() function test
- " Script-local variables are checked here
- 
- " Existing script-local variable
- let s:script_var = 1
- echo 's:script_var: 1'
- if exists('s:script_var')
-     echo "OK"
- else
-     echo "FAILED"
- endif
- 
- " Non-existing script-local variable
- unlet s:script_var
- echo 's:script_var: 0'
- if !exists('s:script_var')
-     echo "OK"
- else
-     echo "FAILED"
- endif
- 
- " Existing script-local list
- let s:script_list = ["blue", "orange"]
- echo 's:script_list: 1'
- if exists('s:script_list')
-     echo "OK"
- else
-     echo "FAILED"
- endif
- 
- " Non-existing script-local list
- unlet s:script_list
- echo 's:script_list: 0'
- if !exists('s:script_list')
-     echo "OK"
- else
-     echo "FAILED"
- endif
- 
- " Existing script-local dictionary
- let s:script_dict = {"xcord":100, "ycord":2}
- echo 's:script_dict: 1'
- if exists('s:script_dict')
-     echo "OK"
- else
-     echo "FAILED"
- endif
- 
- " Non-existing script-local dictionary
- unlet s:script_dict
- echo 's:script_dict: 0'
- if !exists('s:script_dict')
-     echo "OK"
- else
-     echo "FAILED"
- endif
- 
- " Existing script curly-brace variable
- let str = "script"
- let s:curly_{str}_var = 1
- echo 's:curly_' . str . '_var: 1'
- if exists('s:curly_{str}_var')
-     echo "OK"
- else
-     echo "FAILED"
- endif
- 
- " Non-existing script-local curly-brace variable
- unlet s:curly_{str}_var
- echo 's:curly_' . str . '_var: 0'
- if !exists('s:curly_{str}_var')
-     echo "OK"
- else
-     echo "FAILED"
- endif
- 
- " Existing script-local function
- function! s:my_script_func()
- endfunction
- 
- echo '*s:my_script_func: 1'
- if exists('*s:my_script_func')
-     echo "OK"
- else
-     echo "FAILED"
- endif
- 
- " Non-existing script-local function
- delfunction s:my_script_func
- 
- echo '*s:my_script_func: 0'
- if !exists('*s:my_script_func')
-     echo "OK"
- else
-     echo "FAILED"
- endif
- unlet str
- 
--- 0 ----
*** ../vim-8.0.1185/src/testdir/test7.in	2010-05-15 13:04:10.000000000 +0200
--- src/testdir/test7.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,26 ****
- Test for autocommand that changes the buffer list, when doing ":ball".
- 
- STARTTEST
- :so small.vim
- /^start of
- A1:.,/end of/w! Xxx1   " write test file Xxx1
- :sp Xxx1
- :close
- $r2:.,/end of/w! Xxx2    " write test file Xxx2
- :sp Xxx2
- :close
- $r3:.,/end of/w! Xxx3    " write test file Xxx3
- :sp Xxx3
- :close
- :au BufReadPost Xxx2 bwipe
- $r4:ball                 " open window for all args, close Xxx2
- :.,$w! test.out          " Write contents of this file
- :w >>test.out        " Append contents of second window (Xxx1)
- :/^start of/,$w >>test.out   " Append contents of last window (this file)
- :qa!
- ENDTEST
- 
- start of test file Xxx
- 	this is a test
- 	this is a test
- end of test file Xxx
--- 0 ----
*** ../vim-8.0.1185/src/testdir/test7.ok	2010-05-15 13:04:10.000000000 +0200
--- src/testdir/test7.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,12 ****
- start of test file Xxx4
- 	this is a test
- 	this is a test
- end of test file Xxx
- start of test file Xxx1
- 	this is a test
- 	this is a test
- end of test file Xxx
- start of test file Xxx4
- 	this is a test
- 	this is a test
- end of test file Xxx
--- 0 ----
*** ../vim-8.0.1185/src/testdir/test78.in	2017-03-08 22:55:14.914181221 +0100
--- src/testdir/test78.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,46 ****
- Inserts 10000 lines with text to fill the swap file with two levels of pointer
- blocks.  Then recovers from the swap file and checks all text is restored.
- 
- We need about 10000 lines of 100 characters to get two levels of pointer
- blocks.
- 
- STARTTEST
- :so small.vim
- :set nocp fileformat=unix undolevels=-1 viminfo+=nviminfo belloff=all
- :e! Xtest
- ggdG
- :let text = "\tabcdefghijklmnoparstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnoparstuvwxyz0123456789"
- :let i = 1
- :let linecount = 10000
- :while i <= linecount | call append(i - 1, i . text) | let i += 1 | endwhile
- :preserve
- :" get the name of the swap file
- :redir => swapname
- :swapname
- :redir END
- :let swapname = substitute(swapname, '[[:blank:][:cntrl:]]*\(.\{-}\)[[:blank:][:cntrl:]]*$', '\1', '')
- :" make a copy of the swap file in Xswap
- :set bin
- :exe 'sp ' . swapname
- :w! Xswap
- :echo swapname
- :set nobin
- :new
- :only!
- :bwipe! Xtest
- :call rename('Xswap', swapname)
- :recover Xtest
- :call delete(swapname)
- :new
- :call append(0, 'recovery start')
- :wincmd w
- :let linedollar = line('$')
- :if linedollar < linecount | exe 'wincmd w' | call append(line('$'), "expected " . linecount . " lines but found only " . linedollar) | exe 'wincmd w' | let linecount = linedollar | endif
- :let i = 1
- :while i <= linecount | if getline(i) != i . text | exe 'wincmd w' | call append(line('$'), i . ' differs') | exe 'wincmd w' | endif | let i += 1 | endwhile
- :q!
- :call append(line('$'), 'recovery end')
- :w! test.out
- :qa!
- ENDTEST
- 
--- 0 ----
*** ../vim-8.0.1185/src/testdir/test78.ok	2011-06-13 00:25:05.000000000 +0200
--- src/testdir/test78.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,3 ****
- recovery start
- 
- recovery end
--- 0 ----
*** ../vim-8.0.1185/src/testdir/test_autocmd.vim	2017-08-20 15:47:16.668536499 +0200
--- src/testdir/test_autocmd.vim	2017-10-12 20:30:58.189021254 +0200
***************
*** 436,441 ****
--- 436,443 ----
      return
    endif
  
+   badd test_autocmd.vim
+ 
    call test_override('starting', 1)
    set nocp
    au OptionSet * :call s:AutoCommandOptionSet(expand("<amatch>"))
***************
*** 529,537 ****
    let g:options=[['backup', 0, 1, 'local']]
    " try twice, first time, shouldn't trigger because option name is invalid,
    " second time, it should trigger
!   call assert_fails("call setbufvar(1, '&l:bk', 1)", "E355")
    " should trigger, use correct option name
!   call setbufvar(1, '&backup', 1)
    call assert_equal([], g:options)
    call assert_equal(g:opt[0], g:opt[1])
  
--- 531,540 ----
    let g:options=[['backup', 0, 1, 'local']]
    " try twice, first time, shouldn't trigger because option name is invalid,
    " second time, it should trigger
!   let bnum = bufnr('%')
!   call assert_fails("call setbufvar(bnum, '&l:bk', 1)", "E355")
    " should trigger, use correct option name
!   call setbufvar(bnum, '&backup', 1)
    call assert_equal([], g:options)
    call assert_equal(g:opt[0], g:opt[1])
  
***************
*** 645,647 ****
--- 648,776 ----
    new
    bwipe! Xfile1
  endfunc
+ 
+ " Test for autocommand that changes the buffer list, when doing ":ball".
+ func Test_Acmd_BufAll()
+   enew!
+   %bwipe!
+   call writefile(['Test file Xxx1'], 'Xxx1')
+   call writefile(['Test file Xxx2'], 'Xxx2')
+   call writefile(['Test file Xxx3'], 'Xxx3')
+ 
+   " Add three files to the buffer list
+   split Xxx1
+   close
+   split Xxx2
+   close
+   split Xxx3
+   close
+ 
+   " Wipe the buffer when the buffer is opened
+   au BufReadPost Xxx2 bwipe
+ 
+   call append(0, 'Test file Xxx4')
+   ball
+ 
+   call assert_equal(2, winnr('$'))
+   call assert_equal('Xxx1', bufname(winbufnr(winnr('$'))))
+   wincmd t
+ 
+   au! BufReadPost
+   %bwipe!
+   call delete('Xxx1')
+   call delete('Xxx2')
+   call delete('Xxx3')
+   enew! | only
+ endfunc
+ 
+ " Test for autocommand that changes current buffer on BufEnter event.
+ " Check if modelines are interpreted for the correct buffer.
+ func Test_Acmd_BufEnter()
+   %bwipe!
+   call writefile(['start of test file Xxx1',
+ 	      \ "\<Tab>this is a test",
+ 	      \ 'end of test file Xxx1'], 'Xxx1')
+   call writefile(['start of test file Xxx2',
+ 	      \ 'vim: set noai :',
+ 	      \ "\<Tab>this is a test",
+ 	      \ 'end of test file Xxx2'], 'Xxx2')
+ 
+   au BufEnter Xxx2 brew
+   set ai modeline modelines=3
+   edit Xxx1
+   " edit Xxx2, autocmd will do :brew
+   edit Xxx2
+   exe "normal G?this is a\<CR>"
+   " Append text with autoindent to this file
+   normal othis should be auto-indented
+   call assert_equal("\<Tab>this should be auto-indented", getline('.'))
+   call assert_equal(3, line('.'))
+   " Remove autocmd and edit Xxx2 again
+   au! BufEnter Xxx2
+   buf! Xxx2
+   exe "normal G?this is a\<CR>"
+   " append text without autoindent to Xxx
+   normal othis should be in column 1
+   call assert_equal("this should be in column 1", getline('.'))
+   call assert_equal(4, line('.'))
+ 
+   %bwipe!
+   call delete('Xxx1')
+   call delete('Xxx2')
+   set ai&vim modeline&vim modelines&vim
+ endfunc
+ 
+ " Test for issue #57
+ " do not move cursor on <c-o> when autoindent is set
+ func Test_ai_CTRL_O()
+   enew!
+   set ai
+   let save_fo = &fo
+   set fo+=r
+   exe "normal o# abcdef\<Esc>2hi\<CR>\<C-O>d0\<Esc>"
+   exe "normal o# abcdef\<Esc>2hi\<C-O>d0\<Esc>"
+   call assert_equal(['# abc', 'def', 'def'], getline(2, 4))
+ 
+   set ai&vim
+   let &fo = save_fo
+   enew!
+ endfunc
+ 
+ " Test for autocommand that deletes the current buffer on BufLeave event.
+ " Also test deleting the last buffer, should give a new, empty buffer.
+ func Test_BufLeave_Wipe()
+   %bwipe!
+   let content = ['start of test file Xxx',
+ 	      \ 'this is a test',
+ 	      \ 'end of test file Xxx']
+   call writefile(content, 'Xxx1')
+   call writefile(content, 'Xxx2')
+ 
+   au BufLeave Xxx2 bwipe
+   edit Xxx1
+   split Xxx2
+   " delete buffer Xxx2, we should be back to Xxx1
+   bwipe
+   call assert_equal('Xxx1', bufname('%'))
+   call assert_equal(1, winnr('$'))
+ 
+   " Create an alternate buffer
+   %write! test.out
+   call assert_equal('test.out', bufname('#'))
+   " delete alternate buffer
+   bwipe test.out
+   call assert_equal('Xxx1', bufname('%'))
+   call assert_equal('', bufname('#'))
+ 
+   au BufLeave Xxx1 bwipe
+   " delete current buffer, get an empty one
+   bwipe!
+   call assert_equal(1, line('$'))
+   call assert_equal('', bufname('%'))
+   call assert_equal(1, len(getbufinfo()))
+ 
+   call delete('Xxx1')
+   call delete('Xxx2')
+   %bwipe
+   au! BufLeave
+ endfunc
*** ../vim-8.0.1185/src/testdir/test_exists.vim	2017-10-12 21:28:13.625712658 +0200
--- src/testdir/test_exists.vim	2017-10-12 20:30:58.189021254 +0200
***************
*** 0 ****
--- 1,321 ----
+ " Tests for the exists() function
+ func Test_exists()
+   augroup myagroup
+       autocmd! BufEnter       *.my     echo "myfile edited"
+       autocmd! FuncUndefined  UndefFun exec "fu UndefFun()\nendfu"
+   augroup END
+   set rtp+=./sautest
+ 
+   " valid autocmd group
+   call assert_equal(1, exists('#myagroup'))
+   " valid autocmd group with garbage
+   call assert_equal(0, exists('#myagroup+b'))
+   " Valid autocmd group and event
+   call assert_equal(1, exists('#myagroup#BufEnter'))
+   " Valid autocmd group, event and pattern
+   call assert_equal(1, exists('#myagroup#BufEnter#*.my'))
+   " Valid autocmd event
+   call assert_equal(1, exists('#BufEnter'))
+   " Valid autocmd event and pattern
+   call assert_equal(1, exists('#BufEnter#*.my'))
+   " Non-existing autocmd group or event
+   call assert_equal(0, exists('#xyzagroup'))
+   " Non-existing autocmd group and valid autocmd event
+   call assert_equal(0, exists('#xyzagroup#BufEnter'))
+   " Valid autocmd group and event with no matching pattern
+   call assert_equal(0, exists('#myagroup#CmdwinEnter'))
+   " Valid autocmd group and non-existing autocmd event
+   call assert_equal(0, exists('#myagroup#xyzacmd'))
+   " Valid autocmd group and event and non-matching pattern
+   call assert_equal(0, exists('#myagroup#BufEnter#xyzpat'))
+   " Valid autocmd event and non-matching pattern
+   call assert_equal(0, exists('#BufEnter#xyzpat'))
+   " Empty autocmd group, event and pattern
+   call assert_equal(0, exists('###'))
+   " Empty autocmd group and event or empty event and pattern
+   call assert_equal(0, exists('##'))
+   " Valid autocmd event
+   call assert_equal(1, exists('##FileReadCmd'))
+   " Non-existing autocmd event
+   call assert_equal(0, exists('##MySpecialCmd'))
+ 
+   " Existing and working option (long form)
+   call assert_equal(1, exists('&textwidth'))
+   " Existing and working option (short form)
+   call assert_equal(1, exists('&tw'))
+   " Existing and working option with garbage
+   call assert_equal(0, exists('&tw-'))
+   " Global option
+   call assert_equal(1, exists('&g:errorformat'))
+   " Local option
+   call assert_equal(1, exists('&l:errorformat'))
+   " Negative form of existing and working option (long form)
+   call assert_equal(0, exists('&nojoinspaces'))
+   " Negative form of existing and working option (short form)
+   call assert_equal(0, exists('&nojs'))
+   " Non-existing option
+   call assert_equal(0, exists('&myxyzoption'))
+ 
+   " Existing and working option (long form)
+   call assert_equal(1, exists('+incsearch'))
+   " Existing and working option with garbage
+   call assert_equal(0, exists('+incsearch!1'))
+   " Existing and working option (short form)
+   call assert_equal(1, exists('+is'))
+   " Existing option that is hidden.
+   call assert_equal(0, exists('+autoprint'))
+ 
+   " Existing environment variable
+   let $EDITOR_NAME = 'Vim Editor'
+   call assert_equal(1, exists('$EDITOR_NAME'))
+   " Non-existing environment variable
+   call assert_equal(0, exists('$NON_ENV_VAR'))
+ 
+   " Valid internal function
+   call assert_equal(1, exists('*bufnr'))
+   " Valid internal function with ()
+   call assert_equal(1, exists('*bufnr()'))
+   " Non-existing internal function
+   call assert_equal(0, exists('*myxyzfunc'))
+   " Valid internal function with garbage
+   call assert_equal(0, exists('*bufnr&6'))
+   " Valid user defined function
+   call assert_equal(1, exists('*Test_exists'))
+   " Non-existing user defined function
+   call assert_equal(0, exists('*MyxyzFunc'))
+   " Function that may be created by FuncUndefined event
+   call assert_equal(0, exists('*UndefFun'))
+   " Function that may be created by script autoloading
+   call assert_equal(0, exists('*footest#F'))
+ 
+   " Valid internal command (full match)
+   call assert_equal(2, exists(':edit'))
+   " Valid internal command (full match) with garbage
+   call assert_equal(0, exists(':edit/a'))
+   " Valid internal command (partial match)
+   call assert_equal(1, exists(':q'))
+   " Non-existing internal command
+   call assert_equal(0, exists(':invalidcmd'))
+ 
+   " User defined command (full match)
+   command! MyCmd :echo 'My command'
+   call assert_equal(2, exists(':MyCmd'))
+   " User defined command (partial match)
+   command! MyOtherCmd :echo 'Another command'
+   call assert_equal(3, exists(':My'))
+ 
+   " Command modifier
+   call assert_equal(2, exists(':rightbelow'))
+ 
+   " Non-existing user defined command (full match)
+   delcommand MyCmd
+   call assert_equal(0, exists(':MyCmd'))
+ 
+   " Non-existing user defined command (partial match)
+   delcommand MyOtherCmd
+   call assert_equal(0, exists(':My'))
+ 
+   " Valid local variable
+   let local_var = 1
+   call assert_equal(1, exists('local_var'))
+   " Valid local variable with garbage
+   call assert_equal(0, exists('local_var%n'))
+   " Non-existing local variable
+   unlet local_var
+   call assert_equal(0, exists('local_var'))
+ 
+   " Non-existing autoload variable that may be autoloaded
+   call assert_equal(0, exists('footest#x'))
+ 
+   " Valid local list
+   let local_list = ["blue", "orange"]
+   call assert_equal(1, exists('local_list'))
+   " Valid local list item
+   call assert_equal(1, exists('local_list[1]'))
+   " Valid local list item with garbage
+   call assert_equal(0, exists('local_list[1]+5'))
+   " Invalid local list item
+   call assert_equal(0, exists('local_list[2]'))
+   " Non-existing local list
+   unlet local_list
+   call assert_equal(0, exists('local_list'))
+   " Valid local dictionary
+   let local_dict = {"xcord":100, "ycord":2}
+   call assert_equal(1, exists('local_dict'))
+   " Non-existing local dictionary
+   unlet local_dict
+   call assert_equal(0, exists('local_dict'))
+   " Existing local curly-brace variable
+   let str = "local"
+   let curly_{str}_var = 1
+   call assert_equal(1, exists('curly_{str}_var'))
+   " Non-existing local curly-brace variable
+   unlet curly_{str}_var
+   call assert_equal(0, exists('curly_{str}_var'))
+ 
+   " Existing global variable
+   let g:global_var = 1
+   call assert_equal(1, exists('g:global_var'))
+   " Existing global variable with garbage
+   call assert_equal(0, exists('g:global_var-n'))
+   " Non-existing global variable
+   unlet g:global_var
+   call assert_equal(0, exists('g:global_var'))
+   " Existing global list
+   let g:global_list = ["blue", "orange"]
+   call assert_equal(1, exists('g:global_list'))
+   " Non-existing global list
+   unlet g:global_list
+   call assert_equal(0, exists('g:global_list'))
+   " Existing global dictionary
+   let g:global_dict = {"xcord":100, "ycord":2}
+   call assert_equal(1, exists('g:global_dict'))
+   " Non-existing global dictionary
+   unlet g:global_dict
+   call assert_equal(0, exists('g:global_dict'))
+   " Existing global curly-brace variable
+   let str = "global"
+   let g:curly_{str}_var = 1
+   call assert_equal(1, exists('g:curly_{str}_var'))
+   " Non-existing global curly-brace variable
+   unlet g:curly_{str}_var
+   call assert_equal(0, exists('g:curly_{str}_var'))
+ 
+   " Existing window variable
+   let w:window_var = 1
+   call assert_equal(1, exists('w:window_var'))
+   " Non-existing window variable
+   unlet w:window_var
+   call assert_equal(0, exists('w:window_var'))
+   " Existing window list
+   let w:window_list = ["blue", "orange"]
+   call assert_equal(1, exists('w:window_list'))
+   " Non-existing window list
+   unlet w:window_list
+   call assert_equal(0, exists('w:window_list'))
+   " Existing window dictionary
+   let w:window_dict = {"xcord":100, "ycord":2}
+   call assert_equal(1, exists('w:window_dict'))
+   " Non-existing window dictionary
+   unlet w:window_dict
+   call assert_equal(0, exists('w:window_dict'))
+   " Existing window curly-brace variable
+   let str = "window"
+   let w:curly_{str}_var = 1
+   call assert_equal(1, exists('w:curly_{str}_var'))
+   " Non-existing window curly-brace variable
+   unlet w:curly_{str}_var
+   call assert_equal(0, exists('w:curly_{str}_var'))
+ 
+   " Existing tab variable
+   let t:tab_var = 1
+   call assert_equal(1, exists('t:tab_var'))
+   " Non-existing tab variable
+   unlet t:tab_var
+   call assert_equal(0, exists('t:tab_var'))
+   " Existing tab list
+   let t:tab_list = ["blue", "orange"]
+   call assert_equal(1, exists('t:tab_list'))
+   " Non-existing tab list
+   unlet t:tab_list
+   call assert_equal(0, exists('t:tab_list'))
+   " Existing tab dictionary
+   let t:tab_dict = {"xcord":100, "ycord":2}
+   call assert_equal(1, exists('t:tab_dict'))
+   " Non-existing tab dictionary
+   unlet t:tab_dict
+   call assert_equal(0, exists('t:tab_dict'))
+   " Existing tab curly-brace variable
+   let str = "tab"
+   let t:curly_{str}_var = 1
+   call assert_equal(1, exists('t:curly_{str}_var'))
+   " Non-existing tab curly-brace variable
+   unlet t:curly_{str}_var
+   call assert_equal(0, exists('t:curly_{str}_var'))
+ 
+   " Existing buffer variable
+   let b:buffer_var = 1
+   call assert_equal(1, exists('b:buffer_var'))
+   " Non-existing buffer variable
+   unlet b:buffer_var
+   call assert_equal(0, exists('b:buffer_var'))
+   " Existing buffer list
+   let b:buffer_list = ["blue", "orange"]
+   call assert_equal(1, exists('b:buffer_list'))
+   " Non-existing buffer list
+   unlet b:buffer_list
+   call assert_equal(0, exists('b:buffer_list'))
+   " Existing buffer dictionary
+   let b:buffer_dict = {"xcord":100, "ycord":2}
+   call assert_equal(1, exists('b:buffer_dict'))
+   " Non-existing buffer dictionary
+   unlet b:buffer_dict
+   call assert_equal(0, exists('b:buffer_dict'))
+   " Existing buffer curly-brace variable
+   let str = "buffer"
+   let b:curly_{str}_var = 1
+   call assert_equal(1, exists('b:curly_{str}_var'))
+   " Non-existing buffer curly-brace variable
+   unlet b:curly_{str}_var
+   call assert_equal(0, exists('b:curly_{str}_var'))
+ 
+   " Existing Vim internal variable
+   call assert_equal(1, exists('v:version'))
+   " Non-existing Vim internal variable
+   call assert_equal(0, exists('v:non_exists_var'))
+ 
+   " Existing script-local variable
+   let s:script_var = 1
+   call assert_equal(1, exists('s:script_var'))
+   " Non-existing script-local variable
+   unlet s:script_var
+   call assert_equal(0, exists('s:script_var'))
+   " Existing script-local list
+   let s:script_list = ["blue", "orange"]
+   call assert_equal(1, exists('s:script_list'))
+   " Non-existing script-local list
+   unlet s:script_list
+   call assert_equal(0, exists('s:script_list'))
+   " Existing script-local dictionary
+   let s:script_dict = {"xcord":100, "ycord":2}
+   call assert_equal(1, exists('s:script_dict'))
+   " Non-existing script-local dictionary
+   unlet s:script_dict
+   call assert_equal(0, exists('s:script_dict'))
+   " Existing script curly-brace variable
+   let str = "script"
+   let s:curly_{str}_var = 1
+   call assert_equal(1, exists('s:curly_{str}_var'))
+   " Non-existing script-local curly-brace variable
+   unlet s:curly_{str}_var
+   call assert_equal(0, exists('s:curly_{str}_var'))
+ 
+   " Existing script-local function
+   function! s:my_script_func()
+   endfunction
+ 
+   echo '*s:my_script_func: 1'
+   call assert_equal(1, exists('*s:my_script_func'))
+ 
+   " Non-existing script-local function
+   delfunction s:my_script_func
+ 
+   call assert_equal(0, exists('*s:my_script_func'))
+   unlet str
+ 
+   call assert_equal(1, g:footest#x)
+   call assert_equal(0, footest#F())
+   call assert_equal(0, UndefFun())
+ endfunc
+ 
+ " exists() test for Function arguments
+ func FuncArg_Tests(func_arg, ...)
+   call assert_equal(1, exists('a:func_arg'))
+   call assert_equal(0, exists('a:non_exists_arg'))
+   call assert_equal(1, exists('a:1'))
+   call assert_equal(0, exists('a:2'))
+ endfunc
+ 
+ func Test_exists_funcarg()
+   call FuncArg_Tests("arg1", "arg2")
+ endfunc
*** ../vim-8.0.1185/src/testdir/test_recover.vim	2017-05-18 16:23:32.809827877 +0200
--- src/testdir/test_recover.vim	2017-10-12 21:17:30.262107240 +0200
***************
*** 15,18 ****
    set dir&
  endfunc
  
! " TODO: move recover tests from test78.in to here.
--- 15,62 ----
    set dir&
  endfunc
  
! " Inserts 10000 lines with text to fill the swap file with two levels of pointer
! " blocks.  Then recovers from the swap file and checks all text is restored.
! "
! " We need about 10000 lines of 100 characters to get two levels of pointer
! " blocks.
! func Test_swap_file()
!   set fileformat=unix undolevels=-1 belloff=all
!   edit! Xtest
!   let text = "\tabcdefghijklmnoparstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnoparstuvwxyz0123456789"
!   let i = 1
!   let linecount = 10000
!   while i <= linecount
!     call append(i - 1, i . text)
!     let i += 1
!   endwhile
!   $delete
!   preserve
!   " get the name of the swap file
!   let swname = split(execute("swapname"))[0]
!   let swname = substitute(swname, '[[:blank:][:cntrl:]]*\(.\{-}\)[[:blank:][:cntrl:]]*$', '\1', '')
!   " make a copy of the swap file in Xswap
!   set binary
!   exe 'sp ' . swname
!   w! Xswap
!   set nobinary
!   new
!   only!
!   bwipe! Xtest
!   call rename('Xswap', swname)
!   recover Xtest
!   call delete(swname)
!   let linedollar = line('$')
!   call assert_equal(linecount, linedollar)
!   if linedollar < linecount
!     let linecount = linedollar
!   endif
!   let i = 1
!   while i <= linecount
!     call assert_equal(i . text, getline(i))
!     let i += 1
!   endwhile
! 
!   set undolevels&
!   enew! | only
! endfunc
*** ../vim-8.0.1185/src/testdir/test_winbuf_close.vim	2017-10-12 21:28:13.633712603 +0200
--- src/testdir/test_winbuf_close.vim	2017-10-12 20:30:58.189021254 +0200
***************
*** 0 ****
--- 1,124 ----
+ " Test for commands that close windows and/or buffers:
+ " :quit
+ " :close
+ " :hide
+ " :only
+ " :sall
+ " :all
+ " :ball
+ " :buf
+ " :edit
+ "
+ func Test_winbuf_close()
+   enew | only
+ 
+   call writefile(['testtext 1'], 'Xtest1')
+   call writefile(['testtext 2'], 'Xtest2')
+   call writefile(['testtext 3'], 'Xtest3')
+ 
+   next! Xtest1 Xtest2
+   call setline(1, 'testtext 1 1')
+ 
+   " test for working :n when hidden set
+   set hidden
+   next
+   call assert_equal('Xtest2', bufname('%'))
+ 
+   " test for failing :rew when hidden not set
+   set nohidden
+   call setline(1, 'testtext 2 2')
+   call assert_fails('rewind', 'E37')
+   call assert_equal('Xtest2', bufname('%'))
+   call assert_equal('testtext 2 2', getline(1))
+ 
+   " test for working :rew when hidden set
+   set hidden
+   rewind
+   call assert_equal('Xtest1', bufname('%'))
+   call assert_equal('testtext 1 1', getline(1))
+ 
+   " test for :all keeping a buffer when it's modified
+   set nohidden
+   call setline(1, 'testtext 1 1 1')
+   split
+   next Xtest2 Xtest3
+   all
+   1wincmd w
+   call assert_equal('Xtest1', bufname('%'))
+   call assert_equal('testtext 1 1 1', getline(1))
+ 
+   " test abandoning changed buffer, should be unloaded even when 'hidden' set
+   set hidden
+   call setline(1, 'testtext 1 1 1 1')
+   quit!
+   call assert_equal('Xtest2', bufname('%'))
+   call assert_equal('testtext 2 2', getline(1))
+   unhide
+   call assert_equal('Xtest2', bufname('%'))
+   call assert_equal('testtext 2 2', getline(1))
+ 
+   " test ":hide" hides anyway when 'hidden' not set
+   set nohidden
+   call setline(1, 'testtext 2 2 2')
+   hide
+   call assert_equal('Xtest3', bufname('%'))
+   call assert_equal('testtext 3', getline(1))
+ 
+   " test ":edit" failing in modified buffer when 'hidden' not set
+   call setline(1, 'testtext 3 3')
+   call assert_fails('edit Xtest1', 'E37')
+   call assert_equal('Xtest3', bufname('%'))
+   call assert_equal('testtext 3 3', getline(1))
+ 
+   " test ":edit" working in modified buffer when 'hidden' set
+   set hidden
+   edit Xtest1
+   call assert_equal('Xtest1', bufname('%'))
+   call assert_equal('testtext 1', getline(1))
+ 
+   " test ":close" not hiding when 'hidden' not set in modified buffer
+   split Xtest3
+   set nohidden
+   call setline(1, 'testtext 3 3 3')
+   call assert_fails('close', 'E37')
+   call assert_equal('Xtest3', bufname('%'))
+   call assert_equal('testtext 3 3 3', getline(1))
+ 
+   " test ":close!" does hide when 'hidden' not set in modified buffer;
+   call setline(1, 'testtext 3 3 3 3')
+   close!
+   call assert_equal('Xtest1', bufname('%'))
+   call assert_equal('testtext 1', getline(1))
+ 
+   set nohidden
+ 
+   " test ":all!" hides changed buffer
+   split Xtest4
+   call setline(1, 'testtext 4')
+   all!
+   1wincmd w
+   call assert_equal('Xtest2', bufname('%'))
+   call assert_equal('testtext 2 2 2', getline(1))
+ 
+   " test ":q!" and hidden buffer.
+   bwipe! Xtest1 Xtest2 Xtest3 Xtest4
+   split Xtest1
+   wincmd w
+   bwipe!
+   set modified
+   bot split Xtest2
+   set modified
+   bot split Xtest3
+   set modified
+   wincmd t
+   hide
+   call assert_equal('Xtest2', bufname('%'))
+   quit!
+   call assert_equal('Xtest3', bufname('%'))
+   call assert_fails('silent! quit!', 'E162')
+   call assert_equal('Xtest1', bufname('%'))
+ 
+   call delete('Xtest1')
+   call delete('Xtest2')
+   call delete('Xtest3')
+ endfunc
*** ../vim-8.0.1185/src/testdir/runtest.vim	2017-09-07 22:24:37.372486913 +0200
--- src/testdir/runtest.vim	2017-10-12 21:23:54.519488092 +0200
***************
*** 250,255 ****
--- 250,258 ----
  
  " Execute the tests in alphabetical order.
  for s:test in sort(s:tests)
+   " Silence, please!
+   set belloff=all
+ 
    call RunTheTest(s:test)
  
    if len(v:errors) > 0 && index(s:flaky, s:test) >= 0
*** ../vim-8.0.1185/src/version.c	2017-10-12 12:33:39.043344450 +0200
--- src/version.c	2017-10-12 20:32:17.548487415 +0200
***************
*** 763,764 ****
--- 763,766 ----
  {   /* Add new patch number below this line */
+ /**/
+     1186,
  /**/

-- 
   An extraordinary TALL KNIGHT in all black (possibly John with Mike on his
   shoulders) walks out from the dark trees.  He is extremely fierce and
   gruesome countenance.  He walks towards KING ARTHUR and PATSY, who are
   wazzing like mad.  (Salopian slang, meaning very scared.  almost to the
   point of wetting oneself, e.g. before an important football match or
   prior to a postering.  Salopian slang meaning a beating by the school
   praeposters.  Sorry about the Salopian slant to this stage direction - Ed.)
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
