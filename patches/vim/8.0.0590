To: vim_dev@googlegroups.com
Subject: Patch 8.0.0590
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0590
Problem:    Cannot add a context to locations.
Solution:   Add the "context" entry in location entries. (Yegappan Lakshmanan,
            closes #1012)
Files:      src/eval.c, src/proto/quickfix.pro, src/quickfix.c,
            src/testdir/test_quickfix.vim


*** ../vim-8.0.0589/src/eval.c	2017-04-07 16:17:35.585077280 +0200
--- src/eval.c	2017-04-30 13:59:57.950287165 +0200
***************
*** 5327,5332 ****
--- 5327,5336 ----
      abort = abort || set_ref_in_timer(copyID);
  #endif
  
+ #ifdef FEAT_QUICKFIX
+     abort = abort || set_ref_in_quickfix(copyID);
+ #endif
+ 
      if (!abort)
      {
  	/*
*** ../vim-8.0.0589/src/proto/quickfix.pro	2017-03-05 17:43:10.620245573 +0100
--- src/proto/quickfix.pro	2017-04-30 13:59:57.950287165 +0200
***************
*** 29,34 ****
--- 29,35 ----
  int get_errorlist(win_T *wp, int qf_idx, list_T *list);
  int get_errorlist_properties(win_T *wp, dict_T *what, dict_T *retdict);
  int set_errorlist(win_T *wp, list_T *list, int action, char_u *title, dict_T *what);
+ int set_ref_in_quickfix(int copyID);
  void ex_cbuffer(exarg_T *eap);
  void ex_cexpr(exarg_T *eap);
  void ex_helpgrep(exarg_T *eap);
*** ../vim-8.0.0589/src/quickfix.c	2017-04-23 17:19:38.561541663 +0200
--- src/quickfix.c	2017-04-30 14:04:11.924779282 +0200
***************
*** 57,62 ****
--- 57,63 ----
      int		qf_nonevalid;	/* TRUE if not a single valid entry found */
      char_u	*qf_title;	/* title derived from the command that created
  				 * the error list */
+     typval_T	*qf_ctx;	/* context set by setqflist/setloclist */
  } qf_list_T;
  
  struct qf_info_S
***************
*** 1596,1601 ****
--- 1597,1610 ----
  	    to_qfl->qf_title = vim_strsave(from_qfl->qf_title);
  	else
  	    to_qfl->qf_title = NULL;
+ 	if (from_qfl->qf_ctx != NULL)
+ 	{
+ 	    to_qfl->qf_ctx = alloc_tv();
+ 	    if (to_qfl->qf_ctx != NULL)
+ 		copy_tv(from_qfl->qf_ctx, to_qfl->qf_ctx);
+ 	}
+ 	else
+ 	    to_qfl->qf_ctx = NULL;
  
  	if (from_qfl->qf_count)
  	{
***************
*** 2749,2754 ****
--- 2758,2765 ----
      }
      vim_free(qi->qf_lists[idx].qf_title);
      qi->qf_lists[idx].qf_title = NULL;
+     free_tv(qi->qf_lists[idx].qf_ctx);
+     qi->qf_lists[idx].qf_ctx = NULL;
      qi->qf_lists[idx].qf_index = 0;
      qi->qf_lists[idx].qf_start = NULL;
      qi->qf_lists[idx].qf_last = NULL;
***************
*** 4629,4634 ****
--- 4640,4646 ----
      QF_GETLIST_ITEMS	= 0x2,
      QF_GETLIST_NR	= 0x4,
      QF_GETLIST_WINID	= 0x8,
+     QF_GETLIST_CONTEXT	= 0x10,
      QF_GETLIST_ALL	= 0xFF
  };
  
***************
*** 4681,4686 ****
--- 4693,4701 ----
      if (dict_find(what, (char_u *)"winid", -1) != NULL)
  	flags |= QF_GETLIST_WINID;
  
+     if (dict_find(what, (char_u *)"context", -1) != NULL)
+ 	flags |= QF_GETLIST_CONTEXT;
+ 
      if (flags & QF_GETLIST_TITLE)
      {
  	char_u	*t;
***************
*** 4699,4704 ****
--- 4714,4734 ----
  	    status = dict_add_nr_str(retdict, "winid", win->w_id, NULL);
      }
  
+     if ((status == OK) && (flags & QF_GETLIST_CONTEXT))
+     {
+ 	if (qi->qf_lists[qf_idx].qf_ctx != NULL)
+ 	{
+ 	    di = dictitem_alloc((char_u *)"context");
+ 	    if (di != NULL)
+ 	    {
+ 		copy_tv(qi->qf_lists[qf_idx].qf_ctx, &di->di_tv);
+ 		dict_add(retdict, di);
+ 	    }
+ 	}
+ 	else
+ 	    status = dict_add_nr_str(retdict, "context", 0L, (char_u *)"");
+     }
+ 
      return status;
  }
  
***************
*** 4874,4879 ****
--- 4904,4919 ----
  	}
      }
  
+     if ((di = dict_find(what, (char_u *)"context", -1)) != NULL)
+     {
+ 	typval_T	*ctx;
+ 	free_tv(qi->qf_lists[qi->qf_curlist].qf_ctx);
+ 	ctx =  alloc_tv();
+ 	if (ctx != NULL)
+ 	    copy_tv(&di->di_tv, ctx);
+ 	qi->qf_lists[qi->qf_curlist].qf_ctx = ctx;
+     }
+ 
      return retval;
  }
  
***************
*** 4981,4986 ****
--- 5021,5072 ----
  
      return retval;
  }
+ 
+     static int
+ mark_quickfix_ctx(qf_info_T *qi, int copyID)
+ {
+     int		i;
+     int		abort = FALSE;
+     typval_T	*ctx;
+ 
+     for (i = 0; i < LISTCOUNT && !abort; ++i)
+     {
+ 	ctx = qi->qf_lists[i].qf_ctx;
+ 	if (ctx != NULL && ctx->v_type != VAR_NUMBER &&
+ 		ctx->v_type != VAR_STRING && ctx->v_type != VAR_FLOAT)
+ 	    abort = set_ref_in_item(ctx, copyID, NULL, NULL);
+     }
+ 
+     return abort;
+ }
+ 
+ /*
+  * Mark the context of the quickfix list and the location lists (if present) as
+  * "in use". So that garabage collection doesn't free the context.
+  */
+     int
+ set_ref_in_quickfix(int copyID)
+ {
+     int		abort = FALSE;
+     tabpage_T	*tp;
+     win_T	*win;
+ 
+     abort = mark_quickfix_ctx(&ql_info, copyID);
+     if (abort)
+ 	return abort;
+ 
+     FOR_ALL_TAB_WINDOWS(tp, win)
+     {
+ 	if (win->w_llist != NULL)
+ 	{
+ 	    abort = mark_quickfix_ctx(win->w_llist, copyID);
+ 	    if (abort)
+ 		return abort;
+ 	}
+     }
+ 
+     return abort;
+ }
  #endif
  
  /*
*** ../vim-8.0.0589/src/testdir/test_quickfix.vim	2017-04-22 21:20:42.355092203 +0200
--- src/testdir/test_quickfix.vim	2017-04-30 13:59:57.950287165 +0200
***************
*** 1772,1777 ****
--- 1772,1809 ----
      if a:cchar == 'l'
  	call assert_equal({}, getloclist(99, {'title': 1}))
      endif
+ 
+     " Context related tests
+     call g:Xsetlist([], 'a', {'context':[1,2,3]})
+     call test_garbagecollect_now()
+     let d = g:Xgetlist({'context':1})
+     call assert_equal([1,2,3], d.context)
+     call g:Xsetlist([], 'a', {'context':{'color':'green'}})
+     let d = g:Xgetlist({'context':1})
+     call assert_equal({'color':'green'}, d.context)
+     call g:Xsetlist([], 'a', {'context':"Context info"})
+     let d = g:Xgetlist({'context':1})
+     call assert_equal("Context info", d.context)
+     call g:Xsetlist([], 'a', {'context':246})
+     let d = g:Xgetlist({'context':1})
+     call assert_equal(246, d.context)
+     if a:cchar == 'l'
+ 	" Test for copying context across two different location lists
+ 	new | only
+ 	let w1_id = win_getid()
+ 	let l = [1]
+ 	call setloclist(0, [], 'a', {'context':l})
+ 	new
+ 	let w2_id = win_getid()
+ 	call add(l, 2)
+ 	call assert_equal([1, 2], getloclist(w1_id, {'context':1}).context)
+ 	call assert_equal([1, 2], getloclist(w2_id, {'context':1}).context)
+ 	unlet! l
+ 	call assert_equal([1, 2], getloclist(w2_id, {'context':1}).context)
+ 	only
+ 	call setloclist(0, [], 'f')
+ 	call assert_equal({}, getloclist(0, {'context':1}))
+     endif
  endfunc
  
  func Test_qf_property()
*** ../vim-8.0.0589/src/version.c	2017-04-29 17:40:04.372484578 +0200
--- src/version.c	2017-04-30 14:02:43.637303406 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     590,
  /**/

-- 
An indication you must be a manager:
You can explain to somebody the difference between "re-engineering",
"down-sizing", "right-sizing", and "firing people's asses".

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
