To: vim_dev@googlegroups.com
Subject: Patch 8.0.1271
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1271
Problem:    Still too many old style tests.
Solution:   Convert a few more tests to new style. (Yegappan Lakshmanan,
            closes #2290)
Files:      src/Makefile, src/testdir/Make_all.mak, src/testdir/Make_vms.mms,
            src/testdir/sautest/autoload/footest.vim, src/testdir/test55.in,
            src/testdir/test55.ok, src/testdir/test_changelist.in,
            src/testdir/test_changelist.ok, src/testdir/test_fold.vim,
            src/testdir/test_ins_complete.vim,
            src/testdir/test_insertcount.in, src/testdir/test_insertcount.ok,
            src/testdir/test_listdict.vim, src/testdir/test_normal.vim,
            src/testdir/test_search.vim, src/testdir/test_search_mbyte.in,
            src/testdir/test_search_mbyte.ok


*** ../vim-8.0.1270/src/Makefile	2017-11-04 21:34:57.016967191 +0100
--- src/Makefile	2017-11-05 20:55:18.450232117 +0100
***************
*** 2094,2112 ****
  # Run individual OLD style test.
  # These do not depend on the executable, compile it when needed.
  test1 \
- 	test_changelist \
  	test_close_count \
  	test_erasebackword \
  	test_eval \
  	test_fixeol \
- 	test_insertcount \
  	test_listchars \
- 	test_search_mbyte \
  	test_wordcount \
  	test3 test11 test14 test15 test17 \
  	test29 test30 test36 test37 test39 \
  	test42 test44 test48 test49 \
! 	test50 test52 test55 test59 \
  	test64 test68 test69 \
  	test70 test72 test73 \
  	test85 test86 test87 test88 \
--- 2094,2109 ----
  # Run individual OLD style test.
  # These do not depend on the executable, compile it when needed.
  test1 \
  	test_close_count \
  	test_erasebackword \
  	test_eval \
  	test_fixeol \
  	test_listchars \
  	test_wordcount \
  	test3 test11 test14 test15 test17 \
  	test29 test30 test36 test37 test39 \
  	test42 test44 test48 test49 \
! 	test50 test52 test59 \
  	test64 test68 test69 \
  	test70 test72 test73 \
  	test85 test86 test87 test88 \
***************
*** 2200,2205 ****
--- 2197,2203 ----
  	test_let \
  	test_lineending \
  	test_lispwords \
+ 	test_listdict \
  	test_listlbr \
  	test_listlbr_utf8 \
  	test_lua \
*** ../vim-8.0.1270/src/testdir/Make_all.mak	2017-11-02 21:04:17.983345100 +0100
--- src/testdir/Make_all.mak	2017-11-05 20:53:03.830998911 +0100
***************
*** 23,29 ****
  	test42.out \
  	test44.out \
  	test48.out \
- 	test55.out \
  	test64.out \
  	test68.out \
  	test69.out \
--- 23,28 ----
***************
*** 34,47 ****
  	test95.out \
  	test99.out \
  	test108.out \
- 	test_changelist.out \
  	test_close_count.out \
  	test_erasebackword.out \
  	test_eval.out \
  	test_fixeol.out \
- 	test_insertcount.out \
  	test_listchars.out \
- 	test_search_mbyte.out \
  	test_wordcount.out
  
  
--- 33,43 ----
***************
*** 123,128 ****
--- 119,125 ----
  	    test_langmap.res \
  	    test_let.res \
  	    test_lineending.res \
+ 	    test_listdict.res \
  	    test_listlbr.res \
  	    test_listlbr_utf8.res \
  	    test_lua.res \
*** ../vim-8.0.1270/src/testdir/Make_vms.mms	2017-11-02 21:04:17.987345075 +0100
--- src/testdir/Make_vms.mms	2017-11-05 20:53:03.830998911 +0100
***************
*** 78,99 ****
         test29.out \
         test30.out test36.out test37.out test39.out \
         test42.out test44.out test48.out test49.out \
-        test55.out \
         test64.out test68.out test69.out \
         test72.out test77a.out test88.out \
         test94.out test95.out test99.out test108.out \
         test_autocmd_option.out \
         test_breakindent.out \
-        test_changelist.out \
         test_close_count.out \
         test_erasebackword.out \
         test_eval.out \
         test_fixeol.out \
-        test_insertcount.out \
         test_listchars.out \
         test_listlbr.out \
         test_listlbr_utf8.out \
-        test_search_mbyte.out \
         test_utf8.out \
         test_wordcount.out
  
--- 78,95 ----
*** ../vim-8.0.1270/src/testdir/sautest/autoload/footest.vim	2014-01-14 14:52:06.000000000 +0100
--- src/testdir/sautest/autoload/footest.vim	2017-11-05 20:53:03.830998911 +0100
***************
*** 1,4 ****
! " Autoload script used by test55 and test60
  let footest#x = 1
  func footest#F()
    return 0
--- 1,4 ----
! " Autoload script used by test_listdict.vim, test_exists.vim and test_let.vim
  let footest#x = 1
  func footest#F()
    return 0
*** ../vim-8.0.1270/src/testdir/test55.in	2016-03-16 21:28:27.000000000 +0100
--- src/testdir/test55.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,586 ****
- Tests for List and Dictionary types.     vim: set ft=vim :
- 
- STARTTEST
- :so small.vim
- :fun Test(...)
- :lang C
- :" Creating List directly with different types
- :let l = [1, 'as''d', [1, 2, function("strlen")], {'a': 1},]
- :$put =string(l)
- :$put =string(l[-1])
- :$put =string(l[-4])
- :try
- :  $put =string(l[-5])
- :catch
- :  $put =v:exception[:14]
- :endtry
- :" List slices
- :$put =string(l[:])
- :$put =string(l[1:])
- :$put =string(l[:-2])
- :$put =string(l[0:8])
- :$put =string(l[8:-1])
- :"
- :" List identity
- :let ll = l
- :let lx = copy(l)
- :try
- :  $put =(l == ll) . (l isnot ll) . (l is ll) . (l == lx) . (l is lx) . (l isnot lx)
- :catch
- :  $put =v:exception
- :endtry
- :"
- :" Creating Dictionary directly with different types
- :let d = {001: 'asd', 'b': [1, 2, function('strlen')], -1: {'a': 1},}
- :$put =string(d) . d.1
- :$put =string(sort(keys(d)))
- :$put =string (values(d))
- :for [key, val] in items(d)
- :  $put =key . ':' . string(val)
- :  unlet key val
- :endfor
- :call extend  (d, {3:33, 1:99})
- :call extend(d, {'b':'bbb', 'c':'ccc'}, "keep")
- :try
- :  call extend(d, {3:333,4:444}, "error")
- :catch
- :  $put =v:exception[:15] . v:exception[-1:-1]
- :endtry
- :$put =string(d)
- :call filter(d, 'v:key =~ ''[ac391]''')
- :$put =string(d)
- :"
- :" Dictionary identity
- :let dd = d
- :let dx = copy(d)
- :try
- :  $put =(d == dd) . (d isnot dd) . (d is dd) . (d == dx) . (d is dx) . (d isnot dx)
- :catch
- :  $put =v:exception
- :endtry
- :"
- :"
- :" removing items with :unlet
- :unlet l[2]
- :$put =string(l)
- :let l = range(8)
- :try
- :unlet l[:3]
- :unlet l[1:]
- :catch
- :$put =v:exception
- :endtry
- :$put =string(l)
- :"
- :unlet d.c
- :unlet d[-1]
- :$put =string(d)
- :"
- :" removing items out of range: silently skip items that don't exist
- let l = [0, 1, 2, 3]
- :unlet l[2:1]
- :$put =string(l)
- let l = [0, 1, 2, 3]
- :unlet l[2:2]
- :$put =string(l)
- let l = [0, 1, 2, 3]
- :unlet l[2:3]
- :$put =string(l)
- let l = [0, 1, 2, 3]
- :unlet l[2:4]
- :$put =string(l)
- let l = [0, 1, 2, 3]
- :unlet l[2:5]
- :$put =string(l)
- let l = [0, 1, 2, 3]
- :unlet l[-1:2]
- :$put =string(l)
- let l = [0, 1, 2, 3]
- :unlet l[-2:2]
- :$put =string(l)
- let l = [0, 1, 2, 3]
- :unlet l[-3:2]
- :$put =string(l)
- let l = [0, 1, 2, 3]
- :unlet l[-4:2]
- :$put =string(l)
- let l = [0, 1, 2, 3]
- :unlet l[-5:2]
- :$put =string(l)
- let l = [0, 1, 2, 3]
- :unlet l[-6:2]
- :$put =string(l)
- :"
- :" assignment to a list
- :let l = [0, 1, 2, 3]
- :let [va, vb] = l[2:3]
- :$put =va
- :$put =vb
- :try
- :  let [va, vb] = l
- :catch
- :  $put =v:exception[:14]
- :endtry
- :try
- :  let [va, vb] = l[1:1]
- :catch
- :  $put =v:exception[:14]
- :endtry
- :"
- :" manipulating a big Dictionary (hashtable.c has a border of 1000 entries)
- :let d = {}
- :for i in range(1500)
- : let d[i] = 3000 - i
- :endfor
- :$put =d[0] . ' ' . d[100] . ' ' . d[999] . ' ' . d[1400] . ' ' . d[1499]
- :try
- :  let n = d[1500]
- :catch
- :  $put =substitute(v:exception, '\v(.{14}).*( \d{4}).*', '\1\2', '')
- :endtry
- :" lookup each items
- :for i in range(1500)
- : if d[i] != 3000 - i
- :  $put =d[i]
- : endif
- :endfor
- : let i += 1
- :" delete even items
- :while i >= 2
- : let i -= 2
- : unlet d[i]
- :endwhile
- :$put =get(d, 1500 - 100, 'NONE') . ' ' . d[1]
- :" delete odd items, checking value, one intentionally wrong
- :let d[33] = 999
- :let i = 1
- :while i < 1500
- : if d[i] != 3000 - i
- :  $put =i . '=' . d[i]
- : else
- :  unlet d[i]
- : endif
- : let i += 2
- :endwhile
- :$put =string(d)  " must be almost empty now
- :unlet d
- :"
- :" Dictionary function
- :let dict = {}
- :func dict.func(a) dict
- :  $put =a:a . len(self.data)
- :endfunc
- :let dict.data = [1,2,3]
- :call dict.func("len: ")
- :let x = dict.func("again: ")
- :let Fn = dict.func
- :call Fn('xxx')
- :" 
- :" Function in script-local List or Dict
- :let g:dict = {}
- :function g:dict.func() dict
- :  $put ='g:dict.func'.self.foo[1].self.foo[0]('asdf')
- :endfunc
- :let g:dict.foo = ['-', 2, 3]
- :call insert(g:dict.foo, function('strlen'))
- :call g:dict.func()
- :" 
- :" Nasty: remove func from Dict that's being called (works)
- :let d = {1:1}
- :func d.func(a)
- :  return "a:". a:a
- :endfunc
- :$put =d.func(string(remove(d, 'func')))
- :"
- :" Nasty: deepcopy() dict that refers to itself (fails when noref used)
- :let d = {1:1, 2:2}
- :let l = [4, d, 6]
- :let d[3] = l
- :let dc = deepcopy(d)
- :try
- :  let dc = deepcopy(d, 1)
- :catch
- :  $put =v:exception[:14]
- :endtry
- :let l2 = [0, l, l, 3]
- :let l[1] = l2
- :let l3 = deepcopy(l2)
- :$put ='same list: ' . (l3[1] is l3[2])
- :"
- :" Locked variables
- :for depth in range(5)
- :  $put ='depth is ' . depth
- :  for u in range(3)
- :    unlet l
- :    let l = [0, [1, [2, 3]], {4: 5, 6: {7: 8}}]
- :    exe "lockvar " . depth . " l"
- :    if u == 1
- :      exe "unlockvar l"
- :    elseif u == 2
- :      exe "unlockvar " . depth . " l"
- :    endif
- :    let ps = islocked("l").islocked("l[1]").islocked("l[1][1]").islocked("l[1][1][0]").'-'.islocked("l[2]").islocked("l[2]['6']").islocked("l[2]['6'][7]")
- :    $put =ps
- :    let ps = ''
- :    try
- :      let l[1][1][0] = 99
- :      let ps .= 'p'
- :    catch
- :      let ps .= 'F'
- :    endtry
- :    try
- :      let l[1][1] = [99]
- :      let ps .= 'p'
- :    catch
- :      let ps .= 'F'
- :    endtry
- :    try
- :      let l[1] = [99]
- :      let ps .= 'p'
- :    catch
- :      let ps .= 'F'
- :    endtry
- :    try
- :      let l[2]['6'][7] = 99
- :      let ps .= 'p'
- :    catch
- :      let ps .= 'F'
- :    endtry
- :    try
- :      let l[2][6] = {99: 99}
- :      let ps .= 'p'
- :    catch
- :      let ps .= 'F'
- :    endtry
- :    try
- :      let l[2] = {99: 99}
- :      let ps .= 'p'
- :    catch
- :      let ps .= 'F'
- :    endtry
- :    try
- :      let l = [99]
- :      let ps .= 'p'
- :    catch
- :      let ps .= 'F'
- :    endtry
- :    $put =ps
- :  endfor
- :endfor
- :"
- :" Unletting locked variables
- :$put ='Unletting:'
- :for depth in range(5)
- :  $put ='depth is ' . depth
- :  for u in range(3)
- :    unlet l
- :    let l = [0, [1, [2, 3]], {4: 5, 6: {7: 8}}]
- :    exe "lockvar " . depth . " l"
- :    if u == 1
- :      exe "unlockvar l"
- :    elseif u == 2
- :      exe "unlockvar " . depth . " l"
- :    endif
- :    let ps = islocked("l").islocked("l[1]").islocked("l[1][1]").islocked("l[1][1][0]").'-'.islocked("l[2]").islocked("l[2]['6']").islocked("l[2]['6'][7]")
- :    $put =ps
- :    let ps = ''
- :    try
- :      unlet l[2]['6'][7]
- :      let ps .= 'p'
- :    catch
- :      let ps .= 'F'
- :    endtry
- :    try
- :      unlet l[2][6]
- :      let ps .= 'p'
- :    catch
- :      let ps .= 'F'
- :    endtry
- :    try
- :      unlet l[2]
- :      let ps .= 'p'
- :    catch
- :      let ps .= 'F'
- :    endtry
- :    try
- :      unlet l[1][1][0]
- :      let ps .= 'p'
- :    catch
- :      let ps .= 'F'
- :    endtry
- :    try
- :      unlet l[1][1]
- :      let ps .= 'p'
- :    catch
- :      let ps .= 'F'
- :    endtry
- :    try
- :      unlet l[1]
- :      let ps .= 'p'
- :    catch
- :      let ps .= 'F'
- :    endtry
- :    try
- :      unlet l
- :      let ps .= 'p'
- :    catch
- :      let ps .= 'F'
- :    endtry
- :    $put =ps
- :  endfor
- :endfor
- :"
- :" Locked variables and :unlet or list / dict functions
- :$put ='Locks and commands or functions:'
- :"
- :$put ='No :unlet after lock on dict:'
- :unlet! d
- :let d = {'a': 99, 'b': 100}
- :lockvar 1 d
- :try
- :  unlet d.a
- :  $put ='did :unlet'
- :catch
- :  $put =v:exception[:16]
- :endtry
- :$put =string(d)
- :"
- :$put =':unlet after lock on dict item:'
- :unlet! d
- :let d = {'a': 99, 'b': 100}
- :lockvar d.a
- :try
- :  unlet d.a
- :  $put ='did :unlet'
- :catch
- :  $put =v:exception[:16]
- :endtry
- :$put =string(d)
- :"
- :$put ='filter() after lock on dict item:'
- :unlet! d
- :let d = {'a': 99, 'b': 100}
- :lockvar d.a
- :try
- :  call filter(d, 'v:key != "a"')
- :  $put ='did filter()'
- :catch
- :  $put =v:exception[:16]
- :endtry
- :$put =string(d)
- :"
- :$put ='map() after lock on dict:'
- :unlet! d
- :let d = {'a': 99, 'b': 100}
- :lockvar 1 d
- :try
- :  call map(d, 'v:val + 200')
- :  $put ='did map()'
- :catch
- :  $put =v:exception[:16]
- :endtry
- :$put =string(d)
- :"
- :$put ='No extend() after lock on dict item:'
- :unlet! d
- :let d = {'a': 99, 'b': 100}
- :lockvar d.a
- :try
- :  $put =string(extend(d, {'a': 123}))
- :  $put ='did extend()'
- :catch
- :  $put =v:exception[:14]
- :endtry
- :$put =string(d)
- :"
- :$put ='No remove() of write-protected scope-level variable:'
- :fun! Tfunc(this_is_a_loooooooooong_parameter_name)
- :  try
- :    $put =string(remove(a:, 'this_is_a_loooooooooong_parameter_name'))
- :    $put ='did remove()'
- :  catch
- :    $put =v:exception[:14]
- :  endtry
- :endfun
- :call Tfunc('testval')
- :"
- :$put ='No extend() of write-protected scope-level variable:'
- :fun! Tfunc(this_is_a_loooooooooong_parameter_name)
- :  try
- :    $put =string(extend(a:, {'this_is_a_loooooooooong_parameter_name': 1234}))
- :    $put ='did extend()'
- :  catch
- :    $put =v:exception[:14]
- :  endtry
- :endfun
- :call Tfunc('testval')
- :"
- :$put ='No :unlet of variable in locked scope:'
- :let b:testvar = 123
- :lockvar 1 b:
- :try
- :  unlet b:testvar
- :  $put ='b:testvar was :unlet: '. (!exists('b:testvar'))
- :catch
- :  $put =v:exception[:16]
- :endtry
- :unlockvar 1 b:
- :unlet! b:testvar
- :"
- :$put ='No :let += of locked list variable:'
- :let l = ['a', 'b', 3]
- :lockvar 1 l
- :try
- :  let l += ['x']
- :  $put ='did :let +='
- :catch
- :  $put =v:exception[:14]
- :endtry
- :$put =string(l)
- :"
- :unlet l
- :let l = [1, 2, 3, 4]
- :lockvar! l
- :$put =string(l)
- :unlockvar l[1]
- :unlet l[0:1]
- :$put =string(l)
- :unlet l[1:2]
- :$put =string(l)
- :unlockvar l[1]
- :let l[0:1] = [0, 1]
- :$put =string(l)
- :let l[1:2] = [0, 1]
- :$put =string(l)
- :unlet l
- :" :lockvar/islocked() triggering script autoloading
- :set rtp+=./sautest
- :lockvar g:footest#x
- :unlockvar g:footest#x
- :$put ='locked g:footest#x:'.islocked('g:footest#x')
- :$put ='exists g:footest#x:'.exists('g:footest#x')
- :$put ='g:footest#x: '.g:footest#x
- :"
- :" a:000 function argument
- :" first the tests that should fail
- :try
- :  let a:000 = [1, 2]
- :catch
- :  $put ='caught a:000'
- :endtry
- :try
- :  let a:000[0] = 9
- :catch
- :  $put ='caught a:000[0]'
- :endtry
- :try
- :  let a:000[2] = [9, 10]
- :catch
- :  $put ='caught a:000[2]'
- :endtry
- :try
- :  let a:000[3] = {9: 10}
- :catch
- :  $put ='caught a:000[3]'
- :endtry
- :" now the tests that should pass
- :try
- :  let a:000[2][1] = 9
- :  call extend(a:000[2], [5, 6])
- :  let a:000[3][5] = 8
- :  let a:000[3]['a'] = 12
- :  $put =string(a:000)
- :catch
- :  $put ='caught ' . v:exception
- :endtry
- :"
- :" reverse(), sort(), uniq()
- :let l = ['-0', 'A11', 2, 2, 'xaaa', 4, 'foo', 'foo6', 'foo', [0, 1, 2], 'x8', [0, 1, 2], 1.5]
- :$put =string(uniq(copy(l)))
- :$put =string(reverse(l))
- :$put =string(reverse(reverse(l)))
- :$put =string(sort(l))
- :$put =string(reverse(sort(l)))
- :$put =string(sort(reverse(sort(l))))
- :$put =string(uniq(sort(l)))
- :let l=[7, 9, 'one', 18, 12, 22, 'two', 10.0e-16, -1, 'three', 0xff, 0.22, 'four']
- :$put =string(sort(copy(l), 'n'))
- :let l=[7, 9, 18, 12, 22, 10.0e-16, -1, 0xff, 0, -0, 0.22, 'bar', 'BAR', 'Bar', 'Foo', 'FOO', 'foo', 'FOOBAR', {}, []]
- :$put =string(sort(copy(l), 1))
- :$put =string(sort(copy(l), 'i'))
- :$put =string(sort(copy(l)))
- :"
- :" splitting a string to a List
- :$put =string(split('  aa  bb '))
- :$put =string(split('  aa  bb  ', '\W\+', 0))
- :$put =string(split('  aa  bb  ', '\W\+', 1))
- :$put =string(split('  aa  bb  ', '\W', 1))
- :$put =string(split(':aa::bb:', ':', 0))
- :$put =string(split(':aa::bb:', ':', 1))
- :$put =string(split('aa,,bb, cc,', ',\s*', 1))
- :$put =string(split('abc', '\zs'))
- :$put =string(split('abc', '\zs', 1))
- :"
- :" compare recursively linked list and dict
- :let l = [1, 2, 3, 4]
- :let d = {'1': 1, '2': l, '3': 3}
- :let l[1] = d
- :$put =(l == l)
- :$put =(d == d)
- :$put =(l != deepcopy(l))
- :$put =(d != deepcopy(d))
- :"
- :" compare complex recursively linked list and dict
- :let l = []
- :call add(l, l)
- :let dict4 = {"l": l}
- :call add(dict4.l, dict4)
- :let lcopy = deepcopy(l)
- :let dict4copy = deepcopy(dict4)
- :$put =(l == lcopy)
- :$put =(dict4 == dict4copy)
- :"
- :" Pass the same List to extend()
- :let l = [1, 2, 3, 4, 5]
- :call extend(l, l)
- :$put =string(l)
- :"
- :" Pass the same Dict to extend()
- :let d = { 'a': {'b': 'B'}}
- :call extend(d, d)
- :$put =string(d)
- :"
- :" Pass the same Dict to extend() with "error"
- :try
- :  call extend(d, d, "error")
- :catch
- :  $put =v:exception[:15] . v:exception[-1:-1]
- :endtry
- :$put =string(d)
- :"
- :" test for range assign
- :let l = [0]
- :let l[:] = [1, 2]
- :$put =string(l)
- :endfun
- :"
- :call Test(1, 2, [3, 4], {5: 6})  " This may take a while
- :"
- :delfunc Test
- :unlet dict
- :call garbagecollect(1)
- :"
- :" test for patch 7.3.637
- :let a = 'No error caught'
- :try|foldopen|catch|let a = matchstr(v:exception,'^[^ ]*')|endtry
- o=a:"
- :lang C
- :redir => a
- :try|foobar|catch|let a = matchstr(v:exception,'^[^ ]*')|endtry
- :redir END
- o=a:"
- :"
- :/^start:/,$wq! test.out
- ENDTEST
- 
- start:
--- 0 ----
*** ../vim-8.0.1270/src/testdir/test55.ok	2016-03-16 21:28:32.000000000 +0100
--- src/testdir/test55.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,197 ****
- start:
- [1, 'as''d', [1, 2, function('strlen')], {'a': 1}]
- {'a': 1}
- 1
- Vim(put):E684: 
- [1, 'as''d', [1, 2, function('strlen')], {'a': 1}]
- ['as''d', [1, 2, function('strlen')], {'a': 1}]
- [1, 'as''d', [1, 2, function('strlen')]]
- [1, 'as''d', [1, 2, function('strlen')], {'a': 1}]
- []
- 101101
- {'1': 'asd', 'b': [1, 2, function('strlen')], '-1': {'a': 1}}asd
- ['-1', '1', 'b']
- ['asd', [1, 2, function('strlen')], {'a': 1}]
- 1:'asd'
- b:[1, 2, function('strlen')]
- -1:{'a': 1}
- Vim(call):E737: 3
- {'c': 'ccc', '1': 99, 'b': [1, 2, function('strlen')], '3': 33, '-1': {'a': 1}}
- {'c': 'ccc', '1': 99, '3': 33, '-1': {'a': 1}}
- 101101
- [1, 'as''d', {'a': 1}]
- [4]
- {'1': 99, '3': 33}
- [0, 1, 2, 3]
- [0, 1, 3]
- [0, 1]
- [0, 1]
- [0, 1]
- [0, 1, 2, 3]
- [0, 1, 3]
- [0, 3]
- [3]
- [3]
- [3]
- 2
- 3
- Vim(let):E687: 
- Vim(let):E688: 
- 3000 2900 2001 1600 1501
- Vim(let):E716: 1500
- NONE 2999
- 33=999
- {'33': 999}
- len: 3
- again: 3
- xxx3
- g:dict.func-4
- a:function('3')
- Vim(let):E698: 
- same list: 1
- depth is 0
- 0000-000
- ppppppp
- 0000-000
- ppppppp
- 0000-000
- ppppppp
- depth is 1
- 1000-000
- ppppppF
- 0000-000
- ppppppp
- 0000-000
- ppppppp
- depth is 2
- 1100-100
- ppFppFF
- 0000-000
- ppppppp
- 0000-000
- ppppppp
- depth is 3
- 1110-110
- pFFpFFF
- 0010-010
- pFppFpp
- 0000-000
- ppppppp
- depth is 4
- 1111-111
- FFFFFFF
- 0011-011
- FFpFFpp
- 0000-000
- ppppppp
- Unletting:
- depth is 0
- 0000-000
- ppppppp
- 0000-000
- ppppppp
- 0000-000
- ppppppp
- depth is 1
- 1000-000
- ppFppFp
- 0000-000
- ppppppp
- 0000-000
- ppppppp
- depth is 2
- 1100-100
- pFFpFFp
- 0000-000
- ppppppp
- 0000-000
- ppppppp
- depth is 3
- 1110-110
- FFFFFFp
- 0010-010
- FppFppp
- 0000-000
- ppppppp
- depth is 4
- 1111-111
- FFFFFFp
- 0011-011
- FppFppp
- 0000-000
- ppppppp
- Locks and commands or functions:
- No :unlet after lock on dict:
- Vim(unlet):E741: 
- {'a': 99, 'b': 100}
- :unlet after lock on dict item:
- did :unlet
- {'b': 100}
- filter() after lock on dict item:
- did filter()
- {'b': 100}
- map() after lock on dict:
- did map()
- {'a': 299, 'b': 300}
- No extend() after lock on dict item:
- Vim(put):E741: 
- {'a': 99, 'b': 100}
- No remove() of write-protected scope-level variable:
- Vim(put):E795: 
- No extend() of write-protected scope-level variable:
- Vim(put):E742: 
- No :unlet of variable in locked scope:
- Vim(unlet):E741: 
- No :let += of locked list variable:
- Vim(let):E741: 
- ['a', 'b', 3]
- [1, 2, 3, 4]
- [1, 2, 3, 4]
- [1, 2, 3, 4]
- [1, 2, 3, 4]
- [1, 2, 3, 4]
- locked g:footest#x:-1
- exists g:footest#x:0
- g:footest#x: 1
- caught a:000
- caught a:000[0]
- caught a:000[2]
- caught a:000[3]
- [1, 2, [3, 9, 5, 6], {'a': 12, '5': 8}]
- ['-0', 'A11', 2, 'xaaa', 4, 'foo', 'foo6', 'foo', [0, 1, 2], 'x8', [0, 1, 2], 1.5]
- [1.5, [0, 1, 2], 'x8', [0, 1, 2], 'foo', 'foo6', 'foo', 4, 'xaaa', 2, 2, 'A11', '-0']
- [1.5, [0, 1, 2], 'x8', [0, 1, 2], 'foo', 'foo6', 'foo', 4, 'xaaa', 2, 2, 'A11', '-0']
- ['-0', 'A11', 'foo', 'foo', 'foo6', 'x8', 'xaaa', 1.5, 2, 2, 4, [0, 1, 2], [0, 1, 2]]
- [[0, 1, 2], [0, 1, 2], 4, 2, 2, 1.5, 'xaaa', 'x8', 'foo6', 'foo', 'foo', 'A11', '-0']
- ['-0', 'A11', 'foo', 'foo', 'foo6', 'x8', 'xaaa', 1.5, 2, 2, 4, [0, 1, 2], [0, 1, 2]]
- ['-0', 'A11', 'foo', 'foo6', 'x8', 'xaaa', 1.5, 2, 4, [0, 1, 2]]
- [-1, 'one', 'two', 'three', 'four', 1.0e-15, 0.22, 7, 9, 12, 18, 22, 255]
- ['bar', 'BAR', 'Bar', 'Foo', 'FOO', 'foo', 'FOOBAR', -1, 0, 0, 0.22, 1.0e-15, 12, 18, 22, 255, 7, 9, [], {}]
- ['bar', 'BAR', 'Bar', 'Foo', 'FOO', 'foo', 'FOOBAR', -1, 0, 0, 0.22, 1.0e-15, 12, 18, 22, 255, 7, 9, [], {}]
- ['BAR', 'Bar', 'FOO', 'FOOBAR', 'Foo', 'bar', 'foo', -1, 0, 0, 0.22, 1.0e-15, 12, 18, 22, 255, 7, 9, [], {}]
- ['aa', 'bb']
- ['aa', 'bb']
- ['', 'aa', 'bb', '']
- ['', '', 'aa', '', 'bb', '', '']
- ['aa', '', 'bb']
- ['', 'aa', '', 'bb', '']
- ['aa', '', 'bb', 'cc', '']
- ['a', 'b', 'c']
- ['', 'a', '', 'b', '', 'c', '']
- 1
- 1
- 0
- 0
- 1
- 1
- [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]
- {'a': {'b': 'B'}}
- Vim(call):E737: a
- {'a': {'b': 'B'}}
- [1, 2]
- Vim(foldopen):E490:
- 
- 
- Error detected while processing :
- E492: Not an editor command: foobar|catch|let a = matchstr(v:exception,'^[^ ]*')|endtry
- 
--- 0 ----
*** ../vim-8.0.1270/src/testdir/test_changelist.in	2014-07-30 13:52:21.000000000 +0200
--- src/testdir/test_changelist.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,22 ****
- Test changelist position after splitting window
- Set 'undolevels' to make changelist for sourced file
- 
- STARTTEST
- :so small.vim
- Gkylp:set ul=100
- Gylp:set ul=100
- gg
- :vsplit
- :try
- :  normal g;
- :  normal ggVGcpass
- :catch
- :  normal ggVGcfail
- :finally
- :  %w! test.out
- :endtry
- :qa!
- ENDTEST
- 
- 1
- 2
--- 0 ----
*** ../vim-8.0.1270/src/testdir/test_changelist.ok	2014-07-30 13:53:41.000000000 +0200
--- src/testdir/test_changelist.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1 ****
- pass
--- 0 ----
*** ../vim-8.0.1270/src/testdir/test_fold.vim	2017-11-02 21:04:17.987345075 +0100
--- src/testdir/test_fold.vim	2017-11-05 20:53:03.834998887 +0100
***************
*** 627,629 ****
--- 627,650 ----
    set fdm& sw& fdl&
    enew!
  endfunc
+ 
+ " test for patch 7.3.637
+ " Cannot catch the error caused by a foldopen when there is no fold.
+ func Test_foldopen_exception()
+   enew!
+   let a = 'No error caught'
+   try
+     foldopen
+   catch
+     let a = matchstr(v:exception,'^[^ ]*')
+   endtry
+   call assert_equal('Vim(foldopen):E490:', a)
+ 
+   let a = 'No error caught'
+   try
+     foobar
+   catch
+     let a = matchstr(v:exception,'^[^ ]*')
+   endtry
+   call assert_match('E492:', a)
+ endfunc
*** ../vim-8.0.1270/src/testdir/test_ins_complete.vim	2017-11-02 15:44:07.913903708 +0100
--- src/testdir/test_ins_complete.vim	2017-11-05 20:53:03.834998887 +0100
***************
*** 2,7 ****
--- 2,12 ----
  " Test for insert expansion
  func Test_ins_complete()
    edit test_ins_complete.vim
+   " The files in the current directory interferes with the files
+   " used by this test. So use a separate directory for the test.
+   call mkdir('Xdir')
+   cd Xdir
+ 
    set ff=unix
    call writefile(["test11\t36Gepeto\t/Tag/",
  	      \ "asd\ttest11file\t36G",
***************
*** 89,94 ****
--- 94,101 ----
    call delete('Xtest11.two')
    call delete('Xtestdata')
    set cpt& cot& def& tags& tagbsearch& hidden&
+   cd ..
+   call delete('Xdir', 'rf')
  endfunc
  
  func Test_omni_dash()
*** ../vim-8.0.1270/src/testdir/test_insertcount.in	2014-07-30 14:47:36.000000000 +0200
--- src/testdir/test_insertcount.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,14 ****
- Tests for repeating insert and replace.
- 
- STARTTEST
- :so small.vim
- :/Second
- 4gro
- :/^First/,$wq! test.out
- :" get here when failed and in Insert mode
- :.wq! test.out
- ENDTEST
- 
- First line
- Second line
- Last line
--- 0 ----
*** ../vim-8.0.1270/src/testdir/test_insertcount.ok	2014-07-30 14:45:43.000000000 +0200
--- src/testdir/test_insertcount.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,3 ****
- First line
- ooooecond line
- Last line
--- 0 ----
*** ../vim-8.0.1270/src/testdir/test_listdict.vim	2017-11-05 20:57:56.069337854 +0100
--- src/testdir/test_listdict.vim	2017-11-05 20:53:03.834998887 +0100
***************
*** 0 ****
--- 1,603 ----
+ " Tests for the List and Dict types
+ 
+ func TearDown()
+   " Run garbage collection after every test
+   call test_garbagecollect_now()
+ endfunc
+ 
+ " Tests for List type
+ 
+ " List creation
+ func Test_list_create()
+   " Creating List directly with different types
+   let l = [1, 'as''d', [1, 2, function("strlen")], {'a': 1},]
+   call assert_equal("[1, 'as''d', [1, 2, function('strlen')], {'a': 1}]", string(l))
+   call assert_equal({'a' : 1}, l[-1])
+   call assert_equal(1, l[-4])
+   let x = 10
+   try
+     let x = l[-5]
+   catch
+     call assert_match('E684:', v:exception)
+   endtry
+   call assert_equal(10, x)
+ endfunc
+ 
+ " List slices
+ func Test_list_slice()
+   let l = [1, 'as''d', [1, 2, function("strlen")], {'a': 1},]
+   call assert_equal([1, 'as''d', [1, 2, function('strlen')], {'a': 1}], l[:])
+   call assert_equal(['as''d', [1, 2, function('strlen')], {'a': 1}], l[1:])
+   call assert_equal([1, 'as''d', [1, 2, function('strlen')]], l[:-2])
+   call assert_equal([1, 'as''d', [1, 2, function('strlen')], {'a': 1}], l[0:8])
+   call assert_equal([], l[8:-1])
+ endfunc
+ 
+ " List identity
+ func Test_list_identity()
+   let l = [1, 'as''d', [1, 2, function("strlen")], {'a': 1},]
+   let ll = l
+   let lx = copy(l)
+   call assert_true(l == ll)
+   call assert_false(l isnot ll)
+   call assert_true(l is ll)
+   call assert_true(l == lx)
+   call assert_false(l is lx)
+   call assert_true(l isnot lx)
+ endfunc
+ 
+ " removing items with :unlet
+ func Test_list_unlet()
+   let l = [1, 'as''d', [1, 2, function("strlen")], {'a': 1},]
+   unlet l[2]
+   call assert_equal([1, 'as''d', {'a': 1}], l)
+   let l = range(8)
+   unlet l[:3]
+   unlet l[1:]
+   call assert_equal([4], l)
+ 
+   " removing items out of range: silently skip items that don't exist
+   let l = [0, 1, 2, 3]
+   call assert_fails('unlet l[2:1]', 'E684')
+   let l = [0, 1, 2, 3]
+   unlet l[2:2]
+   call assert_equal([0, 1, 3], l)
+   let l = [0, 1, 2, 3]
+   unlet l[2:3]
+   call assert_equal([0, 1], l)
+   let l = [0, 1, 2, 3]
+   unlet l[2:4]
+   call assert_equal([0, 1], l)
+   let l = [0, 1, 2, 3]
+   unlet l[2:5]
+   call assert_equal([0, 1], l)
+   let l = [0, 1, 2, 3]
+   call assert_fails('unlet l[-1:2]', 'E684')
+   let l = [0, 1, 2, 3]
+   unlet l[-2:2]
+   call assert_equal([0, 1, 3], l)
+   let l = [0, 1, 2, 3]
+   unlet l[-3:2]
+   call assert_equal([0, 3], l)
+   let l = [0, 1, 2, 3]
+   unlet l[-4:2]
+   call assert_equal([3], l)
+   let l = [0, 1, 2, 3]
+   unlet l[-5:2]
+   call assert_equal([3], l)
+   let l = [0, 1, 2, 3]
+   unlet l[-6:2]
+   call assert_equal([3], l)
+ endfunc
+ 
+ " assignment to a list
+ func Test_list_assign()
+   let l = [0, 1, 2, 3]
+   let [va, vb] = l[2:3]
+   call assert_equal([2, 3], [va, vb])
+   call assert_fails('let [va, vb] = l', 'E687')
+   call assert_fails('let [va, vb] = l[1:1]', 'E688')
+ endfunc
+ 
+ " test for range assign
+ func Test_list_range_assign()
+   let l = [0]
+   let l[:] = [1, 2]
+   call assert_equal([1, 2], l)
+ endfunc
+ 
+ " Tests for Dictionary type
+ 
+ func Test_dict()
+   " Creating Dictionary directly with different types
+   let d = {001: 'asd', 'b': [1, 2, function('strlen')], -1: {'a': 1},}
+   call assert_equal("{'1': 'asd', 'b': [1, 2, function('strlen')], '-1': {'a': 1}}", string(d))
+   call assert_equal('asd', d.1)
+   call assert_equal(['-1', '1', 'b'], sort(keys(d)))
+   call assert_equal(['asd', [1, 2, function('strlen')], {'a': 1}], values(d))
+   let v = []
+   for [key, val] in items(d)
+     call extend(v, [key, val])
+     unlet key val
+   endfor
+   call assert_equal(['1','asd','b',[1, 2, function('strlen')],'-1',{'a': 1}], v)
+ 
+   call extend(d, {3:33, 1:99})
+   call extend(d, {'b':'bbb', 'c':'ccc'}, "keep")
+   call assert_fails("call extend(d, {3:333,4:444}, 'error')", 'E737')
+   call assert_equal({'c': 'ccc', '1': 99, 'b': [1, 2, function('strlen')], '3': 33, '-1': {'a': 1}}, d)
+   call filter(d, 'v:key =~ ''[ac391]''')
+   call assert_equal({'c': 'ccc', '1': 99, '3': 33, '-1': {'a': 1}}, d)
+ endfunc
+ 
+ " Dictionary identity
+ func Test_dict_identity()
+   let d = {001: 'asd', 'b': [1, 2, function('strlen')], -1: {'a': 1},}
+   let dd = d
+   let dx = copy(d)
+   call assert_true(d == dd)
+   call assert_false(d isnot dd)
+   call assert_true(d is dd)
+   call assert_true(d == dx)
+   call assert_false(d is dx)
+   call assert_true(d isnot dx)
+ endfunc
+ 
+ " removing items with :unlet
+ func Test_dict_unlet()
+   let d = {'b':'bbb', '1': 99, '3': 33, '-1': {'a': 1}}
+   unlet d.b
+   unlet d[-1]
+   call assert_equal({'1': 99, '3': 33}, d)
+ endfunc
+ 
+ " manipulating a big Dictionary (hashtable.c has a border of 1000 entries)
+ func Test_dict_big()
+   let d = {}
+   for i in range(1500)
+     let d[i] = 3000 - i
+   endfor
+   call assert_equal([3000, 2900, 2001, 1600, 1501], [d[0], d[100], d[999], d[1400], d[1499]])
+   let str = ''
+   try
+     let n = d[1500]
+   catch
+     let str=substitute(v:exception, '\v(.{14}).*( \d{4}).*', '\1\2', '')
+   endtry
+   call assert_equal('Vim(let):E716: 1500', str)
+ 
+   " lookup each items
+   for i in range(1500)
+     call assert_equal(3000 - i, d[i])
+   endfor
+   let i += 1
+ 
+   " delete even items
+   while i >= 2
+     let i -= 2
+     unlet d[i]
+   endwhile
+   call assert_equal('NONE', get(d, 1500 - 100, 'NONE'))
+   call assert_equal(2999, d[1])
+ 
+   " delete odd items, checking value, one intentionally wrong
+   let d[33] = 999
+   let i = 1
+   while i < 1500
+    if i != 33
+      call assert_equal(3000 - i, d[i])
+    else
+      call assert_equal(999, d[i])
+    endif
+    unlet d[i]
+    let i += 2
+   endwhile
+   call assert_equal({}, d)
+   unlet d
+ endfunc
+ 
+ " Dictionary function
+ func Test_dict_func()
+   let d = {}
+   func d.func(a) dict
+     return a:a . len(self.data)
+   endfunc
+   let d.data = [1,2,3]
+   call assert_equal('len: 3', d.func('len: '))
+   let x = d.func('again: ')
+   call assert_equal('again: 3', x)
+   let Fn = d.func
+   call assert_equal('xxx3', Fn('xxx'))
+ endfunc
+ 
+ " Function in script-local List or Dict
+ func Test_script_local_dict_func()
+   let g:dict = {}
+   function g:dict.func() dict
+     return 'g:dict.func' . self.foo[1] . self.foo[0]('asdf')
+   endfunc
+   let g:dict.foo = ['-', 2, 3]
+   call insert(g:dict.foo, function('strlen'))
+   call assert_equal('g:dict.func-4', g:dict.func())
+   unlet g:dict
+ endfunc
+ 
+ " Nasty: remove func from Dict that's being called (works)
+ func Test_dict_func_remove_in_use()
+   let d = {1:1}
+   func d.func(a)
+     return "a:" . a:a
+   endfunc
+   let expected = 'a:' . string(get(d, 'func'))
+   call assert_equal(expected, d.func(string(remove(d, 'func'))))
+ endfunc
+ 
+ " Nasty: deepcopy() dict that refers to itself (fails when noref used)
+ func Test_dict_deepcopy()
+   let d = {1:1, 2:2}
+   let l = [4, d, 6]
+   let d[3] = l
+   let dc = deepcopy(d)
+   call assert_fails('call deepcopy(d, 1)', 'E698')
+   let l2 = [0, l, l, 3]
+   let l[1] = l2
+   let l3 = deepcopy(l2)
+   call assert_true(l3[1] is l3[2])
+ endfunc
+ 
+ " Locked variables
+ func Test_list_locked_var()
+   let expected = [
+ 	      \ [['0000-000', 'ppppppp'],
+ 	      \  ['0000-000', 'ppppppp'],
+ 	      \  ['0000-000', 'ppppppp']],
+ 	      \ [['1000-000', 'ppppppF'],
+ 	      \  ['0000-000', 'ppppppp'],
+ 	      \  ['0000-000', 'ppppppp']],
+ 	      \ [['1100-100', 'ppFppFF'],
+ 	      \  ['0000-000', 'ppppppp'],
+ 	      \  ['0000-000', 'ppppppp']],
+ 	      \ [['1110-110', 'pFFpFFF'],
+ 	      \  ['0010-010', 'pFppFpp'],
+ 	      \  ['0000-000', 'ppppppp']],
+ 	      \ [['1111-111', 'FFFFFFF'],
+ 	      \  ['0011-011', 'FFpFFpp'],
+ 	      \  ['0000-000', 'ppppppp']]
+ 	      \ ]
+   for depth in range(5)
+     for u in range(3)
+       unlet! l
+       let l = [0, [1, [2, 3]], {4: 5, 6: {7: 8}}]
+       exe "lockvar " . depth . " l"
+       if u == 1
+         exe "unlockvar l"
+       elseif u == 2
+         exe "unlockvar " . depth . " l"
+       endif
+       let ps = islocked("l").islocked("l[1]").islocked("l[1][1]").islocked("l[1][1][0]").'-'.islocked("l[2]").islocked("l[2]['6']").islocked("l[2]['6'][7]")
+       call assert_equal(expected[depth][u][0], ps)
+       let ps = ''
+       try
+         let l[1][1][0] = 99
+         let ps .= 'p'
+       catch
+         let ps .= 'F'
+       endtry
+       try
+         let l[1][1] = [99]
+         let ps .= 'p'
+       catch
+         let ps .= 'F'
+       endtry
+       try
+         let l[1] = [99]
+         let ps .= 'p'
+       catch
+         let ps .= 'F'
+       endtry
+       try
+         let l[2]['6'][7] = 99
+         let ps .= 'p'
+       catch
+         let ps .= 'F'
+       endtry
+       try
+         let l[2][6] = {99: 99}
+         let ps .= 'p'
+       catch
+         let ps .= 'F'
+       endtry
+       try
+         let l[2] = {99: 99}
+         let ps .= 'p'
+       catch
+         let ps .= 'F'
+       endtry
+       try
+         let l = [99]
+         let ps .= 'p'
+       catch
+         let ps .= 'F'
+       endtry
+       call assert_equal(expected[depth][u][1], ps)
+     endfor
+   endfor
+ endfunc
+ 
+ " Unletting locked variables
+ func Test_list_locked_var_unlet()
+   let expected = [
+ 	      \ [['0000-000', 'ppppppp'],
+ 	      \  ['0000-000', 'ppppppp'],
+ 	      \  ['0000-000', 'ppppppp']],
+ 	      \ [['1000-000', 'ppFppFp'],
+ 	      \  ['0000-000', 'ppppppp'],
+ 	      \  ['0000-000', 'ppppppp']],
+ 	      \ [['1100-100', 'pFFpFFp'],
+ 	      \  ['0000-000', 'ppppppp'],
+ 	      \  ['0000-000', 'ppppppp']],
+ 	      \ [['1110-110', 'FFFFFFp'],
+ 	      \  ['0010-010', 'FppFppp'],
+ 	      \  ['0000-000', 'ppppppp']],
+ 	      \ [['1111-111', 'FFFFFFp'],
+ 	      \  ['0011-011', 'FppFppp'],
+ 	      \  ['0000-000', 'ppppppp']]
+ 	      \ ]
+ 
+   for depth in range(5)
+     for u in range(3)
+       unlet! l
+       let l = [0, [1, [2, 3]], {4: 5, 6: {7: 8}}]
+       exe "lockvar " . depth . " l"
+       if u == 1
+         exe "unlockvar l"
+       elseif u == 2
+         exe "unlockvar " . depth . " l"
+       endif
+       let ps = islocked("l").islocked("l[1]").islocked("l[1][1]").islocked("l[1][1][0]").'-'.islocked("l[2]").islocked("l[2]['6']").islocked("l[2]['6'][7]")
+       call assert_equal(expected[depth][u][0], ps)
+       let ps = ''
+       try
+         unlet l[2]['6'][7]
+         let ps .= 'p'
+       catch
+         let ps .= 'F'
+       endtry
+       try
+         unlet l[2][6]
+         let ps .= 'p'
+       catch
+         let ps .= 'F'
+       endtry
+       try
+         unlet l[2]
+         let ps .= 'p'
+       catch
+         let ps .= 'F'
+       endtry
+       try
+         unlet l[1][1][0]
+         let ps .= 'p'
+       catch
+         let ps .= 'F'
+       endtry
+       try
+         unlet l[1][1]
+         let ps .= 'p'
+       catch
+         let ps .= 'F'
+       endtry
+       try
+         unlet l[1]
+         let ps .= 'p'
+       catch
+         let ps .= 'F'
+       endtry
+       try
+         unlet l
+         let ps .= 'p'
+       catch
+         let ps .= 'F'
+       endtry
+       call assert_equal(expected[depth][u][1], ps)
+     endfor
+   endfor
+ endfunc
+ 
+ " Locked variables and :unlet or list / dict functions
+ 
+ " No :unlet after lock on dict:
+ func Test_dict_lock_unlet()
+   unlet! d
+   let d = {'a': 99, 'b': 100}
+   lockvar 1 d
+   call assert_fails('unlet d.a', 'E741')
+ endfunc
+ 
+ " unlet after lock on dict item
+ func Test_dict_item_lock_unlet()
+   unlet! d
+   let d = {'a': 99, 'b': 100}
+   lockvar d.a
+   unlet d.a
+   call assert_equal({'b' : 100}, d)
+ endfunc
+ 
+ " filter() after lock on dict item
+ func Test_dict_lock_filter()
+   unlet! d
+   let d = {'a': 99, 'b': 100}
+   lockvar d.a
+   call filter(d, 'v:key != "a"')
+   call assert_equal({'b' : 100}, d)
+ endfunc
+ 
+ " map() after lock on dict
+ func Test_dict_lock_map()
+   unlet! d
+   let d = {'a': 99, 'b': 100}
+   lockvar 1 d
+   call map(d, 'v:val + 200')
+   call assert_equal({'a' : 299, 'b' : 300}, d)
+ endfunc
+ 
+ " No extend() after lock on dict item
+ func Test_dict_lock_extend()
+   unlet! d
+   let d = {'a': 99, 'b': 100}
+   lockvar d.a
+   call assert_fails("call extend(d, {'a' : 123})", 'E741')
+   call assert_equal({'a': 99, 'b': 100}, d)
+ endfunc
+ 
+ " No remove() of write-protected scope-level variable
+ func! Tfunc(this_is_a_long_parameter_name)
+   call assert_fails("call remove(a:, 'this_is_a_long_parameter_name')", 'E795')
+ endfun
+ func Test_dict_scope_var_remove()
+   call Tfunc('testval')
+ endfunc
+ 
+ " No extend() of write-protected scope-level variable
+ func! Tfunc(this_is_a_long_parameter_name)
+   call assert_fails("call extend(a:, {'this_is_a_long_parameter_name': 1234})", 'E742')
+ endfunc
+ func Test_dict_scope_var_extend()
+   call Tfunc('testval')
+ endfunc
+ 
+ " No :unlet of variable in locked scope
+ func Test_lock_var_unlet()
+   let b:testvar = 123
+   lockvar 1 b:
+   call assert_fails('unlet b:testvar', 'E741:')
+   unlockvar 1 b:
+   unlet! b:testvar
+ endfunc
+ 
+ " No :let += of locked list variable
+ func Test_let_lock_list()
+   let l = ['a', 'b', 3]
+   lockvar 1 l
+   call assert_fails("let l += ['x']", 'E741:')
+   call assert_equal(['a', 'b', 3], l)
+ 
+   unlet l
+   let l = [1, 2, 3, 4]
+   lockvar! l
+   call assert_equal([1, 2, 3, 4], l)
+   unlockvar l[1]
+   call assert_fails('unlet l[0:1]', 'E741:')
+   call assert_equal([1, 2, 3, 4], l)
+   call assert_fails('unlet l[1:2]', 'E741:')
+   call assert_equal([1, 2, 3, 4], l)
+   unlockvar l[1]
+   call assert_fails('let l[0:1] = [0, 1]', 'E741:')
+   call assert_equal([1, 2, 3, 4], l)
+   call assert_fails('let l[1:2] = [0, 1]', 'E741:')
+   call assert_equal([1, 2, 3, 4], l)
+   unlet l
+ endfunc
+ 
+ " lockvar/islocked() triggering script autoloading
+ func Test_lockvar_script_autoload()
+   let old_rtp = &rtp
+   set rtp+=./sautest
+   lockvar g:footest#x
+   unlockvar g:footest#x
+   call assert_equal(-1, islocked('g:footest#x'))
+   call assert_equal(0, exists('g:footest#x'))
+   call assert_equal(1, g:footest#x)
+   let &rtp = old_rtp
+ endfunc
+ 
+ " a:000 function argument test
+ func s:arg_list_test(...)
+   call assert_fails('let a:000 = [1, 2]', 'E46:')
+   call assert_fails('let a:000[0] = 9', 'E742:')
+   call assert_fails('let a:000[2] = [9, 10]', 'E742:')
+   call assert_fails('let a:000[3] = {9 : 10}', 'E742:')
+ 
+   " now the tests that should pass
+   let a:000[2][1] = 9
+   call extend(a:000[2], [5, 6])
+   let a:000[3][5] = 8
+   let a:000[3]['a'] = 12
+   call assert_equal([1, 2, [3, 9, 5, 6], {'a': 12, '5': 8}], a:000)
+ endfunc
+ 
+ func Test_func_arg_list()
+   call s:arg_list_test(1, 2, [3, 4], {5: 6})
+ endfunc
+ 
+ " Tests for reverse(), sort(), uniq()
+ func Test_reverse_sort_uniq()
+   let l = ['-0', 'A11', 2, 2, 'xaaa', 4, 'foo', 'foo6', 'foo', [0, 1, 2], 'x8', [0, 1, 2], 1.5]
+   call assert_equal(['-0', 'A11', 2, 'xaaa', 4, 'foo', 'foo6', 'foo', [0, 1, 2], 'x8', [0, 1, 2], 1.5], uniq(copy(l)))
+   call assert_equal([1.5, [0, 1, 2], 'x8', [0, 1, 2], 'foo', 'foo6', 'foo', 4, 'xaaa', 2, 2, 'A11', '-0'], reverse(l))
+   call assert_equal([1.5, [0, 1, 2], 'x8', [0, 1, 2], 'foo', 'foo6', 'foo', 4, 'xaaa', 2, 2, 'A11', '-0'], reverse(reverse(l)))
+   call assert_equal(['-0', 'A11', 'foo', 'foo', 'foo6', 'x8', 'xaaa', 1.5, 2, 2, 4, [0, 1, 2], [0, 1, 2]], sort(l))
+   call assert_equal([[0, 1, 2], [0, 1, 2], 4, 2, 2, 1.5, 'xaaa', 'x8', 'foo6', 'foo', 'foo', 'A11', '-0'], reverse(sort(l)))
+   call assert_equal(['-0', 'A11', 'foo', 'foo', 'foo6', 'x8', 'xaaa', 1.5, 2, 2, 4, [0, 1, 2], [0, 1, 2]], sort(reverse(sort(l))))
+   call assert_equal(['-0', 'A11', 'foo', 'foo6', 'x8', 'xaaa', 1.5, 2, 4, [0, 1, 2]], uniq(sort(l)))
+ 
+   let l=[7, 9, 'one', 18, 12, 22, 'two', 10.0e-16, -1, 'three', 0xff, 0.22, 'four']
+   call assert_equal([-1, 'one', 'two', 'three', 'four', 1.0e-15, 0.22, 7, 9, 12, 18, 22, 255], sort(copy(l), 'n'))
+ 
+   let l=[7, 9, 18, 12, 22, 10.0e-16, -1, 0xff, 0, -0, 0.22, 'bar', 'BAR', 'Bar', 'Foo', 'FOO', 'foo', 'FOOBAR', {}, []]
+   call assert_equal(['bar', 'BAR', 'Bar', 'Foo', 'FOO', 'foo', 'FOOBAR', -1, 0, 0, 0.22, 1.0e-15, 12, 18, 22, 255, 7, 9, [], {}], sort(copy(l), 1))
+   call assert_equal(['bar', 'BAR', 'Bar', 'Foo', 'FOO', 'foo', 'FOOBAR', -1, 0, 0, 0.22, 1.0e-15, 12, 18, 22, 255, 7, 9, [], {}], sort(copy(l), 'i'))
+   call assert_equal(['BAR', 'Bar', 'FOO', 'FOOBAR', 'Foo', 'bar', 'foo', -1, 0, 0, 0.22, 1.0e-15, 12, 18, 22, 255, 7, 9, [], {}], sort(copy(l)))
+ endfunc
+ 
+ " splitting a string to a List
+ func Test_str_split()
+   call assert_equal(['aa', 'bb'], split('  aa  bb '))
+   call assert_equal(['aa', 'bb'], split('  aa  bb  ', '\W\+', 0))
+   call assert_equal(['', 'aa', 'bb', ''], split('  aa  bb  ', '\W\+', 1))
+   call assert_equal(['', '', 'aa', '', 'bb', '', ''], split('  aa  bb  ', '\W', 1))
+   call assert_equal(['aa', '', 'bb'], split(':aa::bb:', ':', 0))
+   call assert_equal(['', 'aa', '', 'bb', ''], split(':aa::bb:', ':', 1))
+   call assert_equal(['aa', '', 'bb', 'cc', ''], split('aa,,bb, cc,', ',\s*', 1))
+   call assert_equal(['a', 'b', 'c'], split('abc', '\zs'))
+   call assert_equal(['', 'a', '', 'b', '', 'c', ''], split('abc', '\zs', 1))
+ endfunc
+ 
+ " compare recursively linked list and dict
+ func Test_listdict_compare()
+   let l = [1, 2, 3, 4]
+   let d = {'1': 1, '2': l, '3': 3}
+   let l[1] = d
+   call assert_true(l == l)
+   call assert_true(d == d)
+   call assert_false(l != deepcopy(l))
+   call assert_false(d != deepcopy(d))
+ endfunc
+ 
+   " compare complex recursively linked list and dict
+ func Test_listdict_compare_complex()
+   let l = []
+   call add(l, l)
+   let dict4 = {"l": l}
+   call add(dict4.l, dict4)
+   let lcopy = deepcopy(l)
+   let dict4copy = deepcopy(dict4)
+   call assert_true(l == lcopy)
+   call assert_true(dict4 == dict4copy)
+ endfunc
+ 
+ func Test_listdict_extend()
+   " Pass the same List to extend()
+   let l = [1, 2, 3, 4, 5]
+   call extend(l, l)
+   call assert_equal([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], l)
+ 
+   " Pass the same Dict to extend()
+   let d = { 'a': {'b': 'B'}}
+   call extend(d, d)
+   call assert_equal({'a': {'b': 'B'}}, d)
+ 
+   " Pass the same Dict to extend() with "error"
+   call assert_fails("call extend(d, d, 'error')", 'E737:')
+   call assert_equal({'a': {'b': 'B'}}, d)
+ endfunc
*** ../vim-8.0.1270/src/testdir/test_normal.vim	2017-11-02 15:59:53.132217481 +0100
--- src/testdir/test_normal.vim	2017-11-05 20:53:03.834998887 +0100
***************
*** 2396,2398 ****
--- 2396,2440 ----
    call assert_equal('', getline(1))
    bwipe!
  endfunc
+ 
+ " Test for the gr (virtual replace) command
+ " Test for the bug fixed by 7.4.387
+ func Test_gr_command()
+   enew!
+   let save_cpo = &cpo
+   call append(0, ['First line', 'Second line', 'Third line'])
+   exe "normal i\<C-G>u"
+   call cursor(2, 1)
+   set cpo-=X
+   normal 4gro
+   call assert_equal('oooond line', getline(2))
+   undo
+   set cpo+=X
+   normal 4gro
+   call assert_equal('ooooecond line', getline(2))
+   let &cpo = save_cpo
+   enew!
+ endfunc
+ 
+ " When splitting a window the changelist position is wrong.
+ " Test the changelist position after splitting a window.
+ " Test for the bug fixed by 7.4.386
+ func Test_changelist()
+   let save_ul = &ul
+   enew!
+   call append('$', ['1', '2'])
+   exe "normal i\<C-G>u"
+   exe "normal Gkylpa\<C-G>u"
+   set ul=100
+   exe "normal Gylpa\<C-G>u"
+   set ul=100
+   normal gg
+   vsplit
+   normal g;
+   call assert_equal([3, 2], [line('.'), col('.')])
+   normal g;
+   call assert_equal([2, 2], [line('.'), col('.')])
+   call assert_fails('normal g;', 'E662:')
+   %bwipe!
+   let &ul = save_ul
+ endfunc
*** ../vim-8.0.1270/src/testdir/test_search.vim	2017-11-04 18:48:39.174316914 +0100
--- src/testdir/test_search.vim	2017-11-05 20:53:03.834998887 +0100
***************
*** 697,699 ****
--- 697,714 ----
  func Test_search_undefined_behaviour2()
    call search("\%UC0000000")
  endfunc
+ 
+ " Test for search('multi-byte char', 'bce')
+ func Test_search_multibyte()
+   if !has('multi_byte')
+     return
+   endif
+   let save_enc = &encoding
+   set encoding=utf8
+   enew!
+   call append('$', 'ï¼¡')
+   call cursor(2, 1)
+   call assert_equal(2, search('ï¼¡', 'bce', line('.')))
+   enew!
+   let &encoding = save_enc
+ endfunc
*** ../vim-8.0.1270/src/testdir/test_search_mbyte.in	2015-07-10 14:33:38.000000000 +0200
--- src/testdir/test_search_mbyte.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,15 ****
- Test for search('multi-byte char', 'bce')
- 
- STARTTEST
- :source small.vim
- :source mbyte.vim
- :set encoding=utf-8
- :/^Test bce:/+1
- :$put =search('ï¼¡', 'bce', line('.'))
- :1;/^Results:/,$wq! test.out
- ENDTEST
- 
- Results:
- 
- Test bce:
- ï¼¡
--- 0 ----
*** ../vim-8.0.1270/src/version.c	2017-11-05 18:22:56.608624599 +0100
--- src/version.c	2017-11-05 20:58:11.809248724 +0100
***************
*** 763,764 ****
--- 763,766 ----
  {   /* Add new patch number below this line */
+ /**/
+     1271,
  /**/

-- 
NEIL INNES PLAYED: THE FIRST SELF-DESTRUCTIVE MONK, ROBIN'S LEAST FAVORITE
                   MINSTREL, THE PAGE CRUSHED BY A RABBIT, THE OWNER OF A DUCK
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
