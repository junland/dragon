To: vim_dev@googlegroups.com
Subject: Patch 8.0.0794
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0794
Problem:    The script to check translations fails if there is more than one
            NL in one line.
Solution:   Count the number of NL characters.  Make count() accept a string.
Files:      src/po/check.vim, src/evalfunc.c, runtime/doc/eval.txt,
            src/testdir/test_functions.vim


*** ../vim-8.0.0793/src/po/check.vim	2017-07-19 14:34:37.829053506 +0200
--- src/po/check.vim	2017-07-28 16:24:04.051329077 +0200
***************
*** 114,127 ****
  func! CountNl(first, last)
    let nl = 0
    for lnum in range(a:first, a:last)
!     if getline(lnum) =~ '\\n'
!       let nl += 1
!     endif
    endfor
    return nl
  endfunc
  
! " Check that the \n at the end of the msid line is also present in the msgstr
  " line.  Skip over the header.
  /^"MIME-Version:
  while 1
--- 114,125 ----
  func! CountNl(first, last)
    let nl = 0
    for lnum in range(a:first, a:last)
!     let nl += count(getline(lnum), "\n")
    endfor
    return nl
  endfunc
  
! " Check that the \n at the end of the msgid line is also present in the msgstr
  " line.  Skip over the header.
  /^"MIME-Version:
  while 1
***************
*** 138,144 ****
    let transcount = CountNl(strlnum, end - 1)
    " Allow for a few more or less line breaks when there are 2 or more
    if origcount != transcount && (origcount <= 2 || transcount <= 2)
!     echomsg 'Mismatching "\\n" in line ' . line('.')
      if error == 0
        let error = lnum
      endif
--- 136,142 ----
    let transcount = CountNl(strlnum, end - 1)
    " Allow for a few more or less line breaks when there are 2 or more
    if origcount != transcount && (origcount <= 2 || transcount <= 2)
!     echomsg 'Mismatching "\n" in line ' . line('.')
      if error == 0
        let error = lnum
      endif
*** ../vim-8.0.0793/src/evalfunc.c	2017-07-17 23:20:18.339903503 +0200
--- src/evalfunc.c	2017-07-28 16:38:12.585254452 +0200
***************
*** 2314,2321 ****
  {
      long	n = 0;
      int		ic = FALSE;
  
!     if (argvars[0].v_type == VAR_LIST)
      {
  	listitem_T	*li;
  	list_T		*l;
--- 2314,2358 ----
  {
      long	n = 0;
      int		ic = FALSE;
+     int		error = FALSE;
  
!     if (argvars[2].v_type != VAR_UNKNOWN)
! 	ic = (int)get_tv_number_chk(&argvars[2], &error);
! 
!     if (argvars[0].v_type == VAR_STRING)
!     {
! 	char_u *expr = get_tv_string_chk(&argvars[1]);
! 	char_u *p = argvars[0].vval.v_string;
! 	char_u *next;
! 
! 	if (!error && expr != NULL && p != NULL)
! 	{
! 	    if (ic)
! 	    {
! 		size_t len = STRLEN(expr);
! 
! 		while (*p != NUL)
! 		{
! 		    if (MB_STRNICMP(p, expr, len) == 0)
! 		    {
! 			++n;
! 			p += len;
! 		    }
! 		    else
! 			MB_PTR_ADV(p);
! 		}
! 	    }
! 	    else
! 		while ((next = (char_u *)strstr((char *)p, (char *)expr))
! 								       != NULL)
! 		{
! 		    ++n;
! 		    p = next + STRLEN(expr);
! 		}
! 	}
! 
!     }
!     else if (argvars[0].v_type == VAR_LIST)
      {
  	listitem_T	*li;
  	list_T		*l;
***************
*** 2326,2334 ****
  	    li = l->lv_first;
  	    if (argvars[2].v_type != VAR_UNKNOWN)
  	    {
- 		int error = FALSE;
- 
- 		ic = (int)get_tv_number_chk(&argvars[2], &error);
  		if (argvars[3].v_type != VAR_UNKNOWN)
  		{
  		    idx = (long)get_tv_number_chk(&argvars[3], &error);
--- 2363,2368 ----
***************
*** 2356,2366 ****
  
  	if ((d = argvars[0].vval.v_dict) != NULL)
  	{
- 	    int error = FALSE;
- 
  	    if (argvars[2].v_type != VAR_UNKNOWN)
  	    {
- 		ic = (int)get_tv_number_chk(&argvars[2], &error);
  		if (argvars[3].v_type != VAR_UNKNOWN)
  		    EMSG(_(e_invarg));
  	    }
--- 2390,2397 ----
*** ../vim-8.0.0793/runtime/doc/eval.txt	2017-07-08 22:37:02.023229159 +0200
--- runtime/doc/eval.txt	2017-07-28 16:15:39.971030985 +0200
***************
*** 3249,3259 ****
  		
  count({comp}, {expr} [, {ic} [, {start}]])			*count()*
  		Return the number of times an item with value {expr} appears
! 		in |List| or |Dictionary| {comp}.
  		If {start} is given then start with the item with this index.
  		{start} can only be used with a |List|.
  		When {ic} is given and it's |TRUE| then case is ignored.
  
  
  							*cscope_connection()*
  cscope_connection([{num} , {dbpath} [, {prepend}]])
--- 3255,3270 ----
  		
  count({comp}, {expr} [, {ic} [, {start}]])			*count()*
  		Return the number of times an item with value {expr} appears
! 		in |String|, |List| or |Dictionary| {comp}.
! 
  		If {start} is given then start with the item with this index.
  		{start} can only be used with a |List|.
+ 
  		When {ic} is given and it's |TRUE| then case is ignored.
  
+ 		When {comp} is a string then the number of not overlapping
+ 		occurences of {expr} is returned.
+ 
  
  							*cscope_connection()*
  cscope_connection([{num} , {dbpath} [, {prepend}]])
*** ../vim-8.0.0793/src/testdir/test_functions.vim	2017-06-05 18:46:20.497845949 +0200
--- src/testdir/test_functions.vim	2017-07-28 16:26:29.690268473 +0200
***************
*** 635,641 ****
    call assert_equal(0, count(d, 'c', 1))
  
    call assert_fails('call count(d, "a", 0, 1)', 'E474:')
!   call assert_fails('call count("a", "a")', 'E712:')
  endfunc
  
  func Test_changenr()
--- 635,647 ----
    call assert_equal(0, count(d, 'c', 1))
  
    call assert_fails('call count(d, "a", 0, 1)', 'E474:')
! 
!   call assert_equal(0, count("foo", "bar"))
!   call assert_equal(1, count("foo", "oo"))
!   call assert_equal(2, count("foo", "o"))
!   call assert_equal(0, count("foo", "O"))
!   call assert_equal(2, count("foo", "O", 1))
!   call assert_equal(2, count("fooooo", "oo"))
  endfunc
  
  func Test_changenr()
*** ../vim-8.0.0793/src/version.c	2017-07-28 15:55:28.576158675 +0200
--- src/version.c	2017-07-28 16:10:00.981551326 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     794,
  /**/

-- 
FIRST HEAD:  Oh! quick! get the sword out I want to cut his head off.
THIRD HEAD:  Oh, cut your own head off.
SECOND HEAD: Yes - do us all a favour.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
