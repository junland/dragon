To: vim_dev@googlegroups.com
Subject: Patch 8.0.0676
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0676
Problem:    Crash when closing the quickfix window in a FileType autocommand
            that triggers when the quickfix window is opened.
Solution:   Save the new value before triggering the OptionSet autocommand.
            Add the "starting" flag to test_override() to make the text work.
Files:      src/evalfunc.c, src/option.c, runtime/doc/eval.txt


*** ../vim-8.0.0675/src/evalfunc.c	2017-06-25 13:40:09.179635950 +0200
--- src/evalfunc.c	2017-06-25 20:55:28.865778794 +0200
***************
*** 12398,12403 ****
--- 12398,12404 ----
  {
      char_u *name = (char_u *)"";
      int     val;
+     static int save_starting = -1;
  
      if (argvars[0].v_type != VAR_STRING
  	    || (argvars[1].v_type) != VAR_NUMBER)
***************
*** 12411,12420 ****
--- 12412,12440 ----
  	    disable_redraw_for_testing = val;
  	else if (STRCMP(name, (char_u *)"char_avail") == 0)
  	    disable_char_avail_for_testing = val;
+ 	else if (STRCMP(name, (char_u *)"starting") == 0)
+ 	{
+ 	    if (val)
+ 	    {
+ 		if (save_starting < 0)
+ 		    save_starting = starting;
+ 		starting = 0;
+ 	    }
+ 	    else
+ 	    {
+ 		starting = save_starting;
+ 		save_starting = -1;
+ 	    }
+ 	}
  	else if (STRCMP(name, (char_u *)"ALL") == 0)
  	{
  	    disable_char_avail_for_testing = FALSE;
  	    disable_redraw_for_testing = FALSE;
+ 	    if (save_starting >= 0)
+ 	    {
+ 		starting = save_starting;
+ 		save_starting = -1;
+ 	    }
  	}
  	else
  	    EMSG2(_(e_invarg2), name);
*** ../vim-8.0.0675/src/option.c	2017-06-22 14:16:09.796934490 +0200
--- src/option.c	2017-06-25 20:39:57.713100593 +0200
***************
*** 4294,4299 ****
--- 4294,4325 ----
  }
  #endif
  
+ #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
+     static void
+ trigger_optionsset_string(
+ 	int	opt_idx,
+ 	int	opt_flags,
+ 	char_u *oldval,
+ 	char_u *newval)
+ {
+     if (oldval != NULL && newval != NULL)
+     {
+ 	char_u buf_type[7];
+ 
+ 	sprintf((char *)buf_type, "%s",
+ 	    (opt_flags & OPT_LOCAL) ? "local" : "global");
+ 	set_vim_var_string(VV_OPTION_OLD, oldval, -1);
+ 	set_vim_var_string(VV_OPTION_NEW, newval, -1);
+ 	set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);
+ 	apply_autocmds(EVENT_OPTIONSET,
+ 		       (char_u *)options[opt_idx].fullname, NULL, FALSE, NULL);
+ 	reset_v_option_vars();
+     }
+     vim_free(oldval);
+     vim_free(newval);
+ }
+ #endif
+ 
  /*
   * Parse 'arg' for option settings.
   *
***************
*** 4763,4768 ****
--- 4789,4795 ----
  			char_u	    *origval = NULL;
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  			char_u	    *saved_origval = NULL;
+ 			char_u	    *saved_newval = NULL;
  #endif
  			unsigned    newlen;
  			int	    comma;
***************
*** 5114,5127 ****
  # ifdef FEAT_CRYPT
  				&& options[opt_idx].indir != PV_KEY
  # endif
! 							   && origval != NULL)
  			    /* origval may be freed by
  			     * did_set_string_option(), make a copy. */
  			    saved_origval = vim_strsave(origval);
  #endif
  
  			/* Handle side effects, and set the global value for
! 			 * ":set" on local options. */
  			errmsg = did_set_string_option(opt_idx, (char_u **)varp,
  				new_value_alloced, oldval, errbuf, opt_flags);
  
--- 5141,5161 ----
  # ifdef FEAT_CRYPT
  				&& options[opt_idx].indir != PV_KEY
  # endif
! 					  && origval != NULL && newval != NULL)
! 			{
  			    /* origval may be freed by
  			     * did_set_string_option(), make a copy. */
  			    saved_origval = vim_strsave(origval);
+ 			    /* newval (and varp) may become invalid if the
+ 			     * buffer is closed by autocommands. */
+ 			    saved_newval = vim_strsave(newval);
+ 			}
  #endif
  
  			/* Handle side effects, and set the global value for
! 			 * ":set" on local options. Note: when setting 'syntax'
! 			 * or 'filetype' autocommands may be triggered that can
! 			 * cause havoc. */
  			errmsg = did_set_string_option(opt_idx, (char_u **)varp,
  				new_value_alloced, oldval, errbuf, opt_flags);
  
***************
*** 5130,5157 ****
  			{
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  			    vim_free(saved_origval);
  #endif
  			    goto skip;
  			}
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
! 			if (saved_origval != NULL)
! 			{
! 			    char_u buf_type[7];
! 
! 			    sprintf((char *)buf_type, "%s",
! 				(opt_flags & OPT_LOCAL) ? "local" : "global");
! 			    set_vim_var_string(VV_OPTION_NEW,
! 							*(char_u **)varp, -1);
! 			    set_vim_var_string(VV_OPTION_OLD, saved_origval, -1);
! 			    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);
! 			    apply_autocmds(EVENT_OPTIONSET,
! 					  (char_u *)options[opt_idx].fullname,
! 				NULL, FALSE, NULL);
! 			    reset_v_option_vars();
! 			    vim_free(saved_origval);
! 			}
  #endif
- 
  		    }
  		    else	    /* key code option */
  		    {
--- 5164,5177 ----
  			{
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
  			    vim_free(saved_origval);
+ 			    vim_free(saved_newval);
  #endif
  			    goto skip;
  			}
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
! 			trigger_optionsset_string(opt_idx, opt_flags,
! 						  saved_origval, saved_newval);
  #endif
  		    }
  		    else	    /* key code option */
  		    {
***************
*** 5922,5927 ****
--- 5942,5948 ----
      char_u	*oldval;
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
      char_u	*saved_oldval = NULL;
+     char_u	*saved_newval = NULL;
  #endif
      char_u	*r = NULL;
  
***************
*** 5945,5970 ****
  		&& options[opt_idx].indir != PV_KEY
  # endif
  		)
  	    saved_oldval = vim_strsave(oldval);
  #endif
  	if ((r = did_set_string_option(opt_idx, varp, TRUE, oldval, NULL,
  							   opt_flags)) == NULL)
  	    did_set_option(opt_idx, opt_flags, TRUE);
  
- 	/* call autocommand after handling side effects */
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
! 	if (saved_oldval != NULL)
! 	{
! 	    char_u buf_type[7];
! 	    sprintf((char *)buf_type, "%s",
! 		(opt_flags & OPT_LOCAL) ? "local" : "global");
! 	    set_vim_var_string(VV_OPTION_NEW, *varp, -1);
! 	    set_vim_var_string(VV_OPTION_OLD, saved_oldval, -1);
! 	    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);
! 	    apply_autocmds(EVENT_OPTIONSET, (char_u *)options[opt_idx].fullname, NULL, FALSE, NULL);
! 	    reset_v_option_vars();
! 	    vim_free(saved_oldval);
! 	}
  #endif
      }
      return r;
--- 5966,5984 ----
  		&& options[opt_idx].indir != PV_KEY
  # endif
  		)
+ 	{
  	    saved_oldval = vim_strsave(oldval);
+ 	    saved_newval = vim_strsave(s);
+ 	}
  #endif
  	if ((r = did_set_string_option(opt_idx, varp, TRUE, oldval, NULL,
  							   opt_flags)) == NULL)
  	    did_set_option(opt_idx, opt_flags, TRUE);
  
  #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
! 	/* call autocommand after handling side effects */
! 	trigger_optionsset_string(opt_idx, opt_flags,
! 						   saved_oldval, saved_newval);
  #endif
      }
      return r;
*** ../vim-8.0.0675/runtime/doc/eval.txt	2017-06-24 22:29:02.041532903 +0200
--- runtime/doc/eval.txt	2017-06-25 20:12:24.686165527 +0200
***************
*** 7934,7941 ****
--- 7942,7960 ----
  		name	     effect when {val} is non-zero ~
  		redraw       disable the redrawing() function
  		char_avail   disable the char_avail() function
+ 		starting     reset the "starting" variable, see below
  		ALL	     clear all overrides ({val} is not used)
  
+ 		"starting" is to be used when a test should behave like
+ 		startup was done.  Since the tests are run by sourcing a
+ 		script the "starting" variable is non-zero. This is usually a
+ 		good thing (tests run faster), but sometimes changes behavior
+ 		in a way that the test doesn't work properly.
+ 		When using: >
+ 			call test_override('starting', 1)
+ < 		The value of "starting" is saved.  It is restored by: >
+ 			call test_override('starting', 0)
+ 
  test_settime({expr})					*test_settime()*
  		Set the time Vim uses internally.  Currently only used for
  		timestamps in the history, as they are used in viminfo, and
*** ../vim-8.0.0675/src/version.c	2017-06-25 18:03:34.007553654 +0200
--- src/version.c	2017-06-25 20:45:50.014326379 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     676,
  /**/

-- 
From "know your smileys":
 :-)	Funny
 |-)	Funny Oriental
 (-:	Funny Australian

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
