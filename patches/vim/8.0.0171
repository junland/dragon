To: vim_dev@googlegroups.com
Subject: Patch 8.0.0171
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0171
Problem:    JS style JSON does not support single quotes.
Solution:   Allow for single quotes. (Yasuhiro Matsumoto, closes #1371)
Files:      src/json.c, src/testdir/test_json.vim, src/json_test.c,
            runtime/doc/eval.txt


*** ../vim-8.0.0170/src/json.c	2017-01-10 22:57:27.126951746 +0100
--- src/json.c	2017-01-11 21:38:33.585878110 +0100
***************
*** 378,384 ****
  }
  
      static int
! json_decode_string(js_read_T *reader, typval_T *res)
  {
      garray_T    ga;
      int		len;
--- 378,384 ----
  }
  
      static int
! json_decode_string(js_read_T *reader, typval_T *res, int quote)
  {
      garray_T    ga;
      int		len;
***************
*** 389,396 ****
      if (res != NULL)
  	ga_init2(&ga, 1, 200);
  
!     p = reader->js_buf + reader->js_used + 1; /* skip over " */
!     while (*p != '"')
      {
  	/* The JSON is always expected to be utf-8, thus use utf functions
  	 * here. The string is converted below if needed. */
--- 389,396 ----
      if (res != NULL)
  	ga_init2(&ga, 1, 200);
  
!     p = reader->js_buf + reader->js_used + 1; /* skip over " or ' */
!     while (*p != quote)
      {
  	/* The JSON is always expected to be utf-8, thus use utf functions
  	 * here. The string is converted below if needed. */
***************
*** 504,510 ****
      }
  
      reader->js_used = (int)(p - reader->js_buf);
!     if (*p == '"')
      {
  	++reader->js_used;
  	if (res != NULL)
--- 504,510 ----
      }
  
      reader->js_used = (int)(p - reader->js_buf);
!     if (*p == quote)
      {
  	++reader->js_used;
  	if (res != NULL)
***************
*** 620,626 ****
  
  	if (top_item != NULL && top_item->jd_type == JSON_OBJECT_KEY
  		&& (options & JSON_JS)
! 		&& reader->js_buf[reader->js_used] != '"')
  	{
  	    char_u *key;
  
--- 620,627 ----
  
  	if (top_item != NULL && top_item->jd_type == JSON_OBJECT_KEY
  		&& (options & JSON_JS)
! 		&& reader->js_buf[reader->js_used] != '"'
! 		&& reader->js_buf[reader->js_used] != '\'')
  	{
  	    char_u *key;
  
***************
*** 690,696 ****
  		    continue;
  
  		case '"': /* string */
! 		    retval = json_decode_string(reader, cur_item);
  		    break;
  
  		case ',': /* comma: empty item */
--- 691,707 ----
  		    continue;
  
  		case '"': /* string */
! 		    retval = json_decode_string(reader, cur_item, *p);
! 		    break;
! 
! 		case '\'':
! 		    if (options & JSON_JS)
! 			retval = json_decode_string(reader, cur_item, *p);
! 		    else
! 		    {
! 			EMSG(_(e_invarg));
! 			retval = FAIL;
! 		    }
  		    break;
  
  		case ',': /* comma: empty item */
*** ../vim-8.0.0170/src/testdir/test_json.vim	2017-01-10 15:15:32.882134134 +0100
--- src/testdir/test_json.vim	2017-01-11 21:41:57.036343938 +0100
***************
*** 145,150 ****
--- 145,152 ----
    call assert_equal("", json_decode('""'))
  
    call assert_equal({'n': 1}, json_decode('{"n":1,}'))
+   call assert_fails("call json_decode(\"{'n':'1',}\")", 'E474:')
+   call assert_fails("call json_decode(\"'n'\")", 'E474:')
  
    call assert_fails('call json_decode("\"")', "E474:")
    call assert_fails('call json_decode("blah")', "E474:")
***************
*** 255,262 ****
--- 257,267 ----
    call assert_equal(v:none, js_decode(''))
    call assert_equal(type(v:none), type(js_decode('')))
    call assert_equal("", js_decode('""'))
+   call assert_equal("", js_decode("''"))
  
+   call assert_equal('n', js_decode("'n'"))
    call assert_equal({'n': 1}, js_decode('{"n":1,}'))
+   call assert_equal({'n': '1'}, js_decode("{'n':'1',}"))
  
    call assert_fails('call js_decode("\"")', "E474:")
    call assert_fails('call js_decode("blah")', "E474:")
*** ../vim-8.0.0170/src/json_test.c	2016-08-29 22:42:20.000000000 +0200
--- src/json_test.c	2017-01-11 21:45:07.614908800 +0100
***************
*** 181,187 ****
      reader.js_buf = (char_u *)" \"foo";
      reader.js_end = reader.js_buf + STRLEN(reader.js_buf);
      reader.js_cookie =        " \"foobar\"  ";
!     assert(json_decode_string(&reader, NULL) == OK);
  }
  #endif
  
--- 181,187 ----
      reader.js_buf = (char_u *)" \"foo";
      reader.js_end = reader.js_buf + STRLEN(reader.js_buf);
      reader.js_cookie =        " \"foobar\"  ";
!     assert(json_decode_string(&reader, NULL, '"') == OK);
  }
  #endif
  
*** ../vim-8.0.0170/runtime/doc/eval.txt	2017-01-08 13:25:47.622339813 +0100
--- runtime/doc/eval.txt	2017-01-11 21:42:55.763901507 +0100
***************
*** 5223,5228 ****
--- 5229,5235 ----
  js_decode({string})					*js_decode()*
  		This is similar to |json_decode()| with these differences:
  		- Object key names do not have to be in quotes.
+ 		- Strings can be in single quotes.
  		- Empty items in an array (between two commas) are allowed and
  		  result in v:none items.
  
*** ../vim-8.0.0170/src/version.c	2017-01-10 22:57:27.126951746 +0100
--- src/version.c	2017-01-11 21:37:21.842419713 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     171,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
248. You sign your letters with your e-mail address instead of your name.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
