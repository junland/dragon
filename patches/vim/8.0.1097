To: vim_dev@googlegroups.com
Subject: Patch 8.0.1097
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1097 (after 8.0.1096)
Problem:    Background color wrong if job changes background color.
Solution:   Get the background color from vterm.
Files:      src/terminal.c, src/screen.c

*** ../vim-8.0.1096/src/terminal.c	2017-09-11 22:00:46.952401314 +0200
--- src/terminal.c	2017-09-11 23:02:28.410296783 +0200
***************
*** 85,90 ****
--- 85,91 ----
  typedef struct sb_line_S {
      int		sb_cols;	/* can differ per line */
      cellattr_T	*sb_cells;	/* allocated */
+     cellattr_T	sb_fill_attr;	/* for short line */
  } sb_line_T;
  
  /* typedef term_T in structs.h */
***************
*** 943,948 ****
--- 944,971 ----
      }
  }
  
+     static void
+ cell2cellattr(const VTermScreenCell *cell, cellattr_T *attr)
+ {
+     attr->width = cell->width;
+     attr->attrs = cell->attrs;
+     attr->fg = cell->fg;
+     attr->bg = cell->bg;
+ }
+ 
+     static int
+ equal_celattr(cellattr_T *a, cellattr_T *b)
+ {
+     /* Comparing the colors should be sufficient. */
+     return a->fg.red == b->fg.red
+ 	&& a->fg.green == b->fg.green
+ 	&& a->fg.blue == b->fg.blue
+ 	&& a->bg.red == b->bg.red
+ 	&& a->bg.green == b->bg.green
+ 	&& a->bg.blue == b->bg.blue;
+ }
+ 
+ 
  /*
   * Add the current lines of the terminal to scrollback and to the buffer.
   * Called after the job has ended and when switching to Terminal-Normal mode.
***************
*** 955,975 ****
      int		    lines_skipped = 0;
      VTermPos	    pos;
      VTermScreenCell cell;
      cellattr_T	    *p;
      VTermScreen	    *screen;
  
      if (term->tl_vterm == NULL)
  	return;
      screen = vterm_obtain_screen(term->tl_vterm);
      for (pos.row = 0; pos.row < term->tl_rows; ++pos.row)
      {
  	len = 0;
  	for (pos.col = 0; pos.col < term->tl_cols; ++pos.col)
  	    if (vterm_screen_get_cell(screen, pos, &cell) != 0
  						       && cell.chars[0] != NUL)
  		len = pos.col + 1;
  
! 	if (len == 0)
  	    ++lines_skipped;
  	else
  	{
--- 978,1007 ----
      int		    lines_skipped = 0;
      VTermPos	    pos;
      VTermScreenCell cell;
+     cellattr_T	    fill_attr, new_fill_attr;
      cellattr_T	    *p;
      VTermScreen	    *screen;
  
      if (term->tl_vterm == NULL)
  	return;
      screen = vterm_obtain_screen(term->tl_vterm);
+     fill_attr = new_fill_attr = term->tl_default_color;
+ 
      for (pos.row = 0; pos.row < term->tl_rows; ++pos.row)
      {
  	len = 0;
  	for (pos.col = 0; pos.col < term->tl_cols; ++pos.col)
  	    if (vterm_screen_get_cell(screen, pos, &cell) != 0
  						       && cell.chars[0] != NUL)
+ 	    {
  		len = pos.col + 1;
+ 		new_fill_attr = term->tl_default_color;
+ 	    }
+ 	    else
+ 		/* Assume the last attr is the filler attr. */
+ 		cell2cellattr(&cell, &new_fill_attr);
  
! 	if (len == 0 && equal_celattr(&new_fill_attr, &fill_attr))
  	    ++lines_skipped;
  	else
  	{
***************
*** 984,997 ****
  
  		    line->sb_cols = 0;
  		    line->sb_cells = NULL;
  		    ++term->tl_scrollback.ga_len;
  
  		    add_scrollback_line_to_buffer(term, (char_u *)"", 0);
  		}
  	    }
  
! 	    p = (cellattr_T *)alloc((int)sizeof(cellattr_T) * len);
! 	    if (p != NULL && ga_grow(&term->tl_scrollback, 1) == OK)
  	    {
  		garray_T    ga;
  		int	    width;
--- 1016,1034 ----
  
  		    line->sb_cols = 0;
  		    line->sb_cells = NULL;
+ 		    line->sb_fill_attr = fill_attr;
  		    ++term->tl_scrollback.ga_len;
  
  		    add_scrollback_line_to_buffer(term, (char_u *)"", 0);
  		}
  	    }
  
! 	    if (len == 0)
! 		p = NULL;
! 	    else
! 		p = (cellattr_T *)alloc((int)sizeof(cellattr_T) * len);
! 	    if ((p != NULL || len == 0)
! 				     && ga_grow(&term->tl_scrollback, 1) == OK)
  	    {
  		garray_T    ga;
  		int	    width;
***************
*** 1013,1022 ****
  		    {
  			width = cell.width;
  
! 			p[pos.col].width = cell.width;
! 			p[pos.col].attrs = cell.attrs;
! 			p[pos.col].fg = cell.fg;
! 			p[pos.col].bg = cell.bg;
  
  			if (ga_grow(&ga, MB_MAXBYTES) == OK)
  			{
--- 1050,1056 ----
  		    {
  			width = cell.width;
  
! 			cell2cellattr(&cell, &p[pos.col]);
  
  			if (ga_grow(&ga, MB_MAXBYTES) == OK)
  			{
***************
*** 1031,1036 ****
--- 1065,1072 ----
  		}
  		line->sb_cols = len;
  		line->sb_cells = p;
+ 		line->sb_fill_attr = new_fill_attr;
+ 		fill_attr = new_fill_attr;
  		++term->tl_scrollback.ga_len;
  
  		if (ga_grow(&ga, 1) == FAIL)
***************
*** 1047,1052 ****
--- 1083,1092 ----
  	}
      }
  
+     /* Obtain the current background color. */
+     vterm_state_get_default_colors(vterm_obtain_state(term->tl_vterm),
+ 		       &term->tl_default_color.fg, &term->tl_default_color.bg);
+ 
      FOR_ALL_WINDOWS(wp)
      {
  	if (wp->w_buffer == term->tl_buffer)
***************
*** 2003,2013 ****
--- 2043,2056 ----
  	int		col;
  	sb_line_T	*line;
  	garray_T	ga;
+ 	cellattr_T	fill_attr = term->tl_default_color;
  
  	/* do not store empty cells at the end */
  	for (i = 0; i < cols; ++i)
  	    if (cells[i].chars[0] != 0)
  		len = i + 1;
+ 	    else
+ 		cell2cellattr(&cells[i], &fill_attr);
  
  	ga_init2(&ga, 1, 100);
  	if (len > 0)
***************
*** 2024,2033 ****
  		for (i = 0; (c = cells[col].chars[i]) > 0 || i == 0; ++i)
  		    ga.ga_len += utf_char2bytes(c == NUL ? ' ' : c,
  					     (char_u *)ga.ga_data + ga.ga_len);
! 		p[col].width = cells[col].width;
! 		p[col].attrs = cells[col].attrs;
! 		p[col].fg = cells[col].fg;
! 		p[col].bg = cells[col].bg;
  	    }
  	}
  	if (ga_grow(&ga, 1) == FAIL)
--- 2067,2073 ----
  		for (i = 0; (c = cells[col].chars[i]) > 0 || i == 0; ++i)
  		    ga.ga_len += utf_char2bytes(c == NUL ? ' ' : c,
  					     (char_u *)ga.ga_data + ga.ga_len);
! 		cell2cellattr(&cells[col], &p[col]);
  	    }
  	}
  	if (ga_grow(&ga, 1) == FAIL)
***************
*** 2043,2048 ****
--- 2083,2089 ----
  						  + term->tl_scrollback.ga_len;
  	line->sb_cols = len;
  	line->sb_cells = p;
+ 	line->sb_fill_attr = fill_attr;
  	++term->tl_scrollback.ga_len;
  	++term->tl_scrollback_scrolled;
      }
***************
*** 2319,2325 ****
  
  /*
   * Get the screen attribute for a position in the buffer.
!  * Use a zero "lnum" to get the default background color.
   */
      int
  term_get_attr(buf_T *buf, linenr_T lnum, int col)
--- 2360,2366 ----
  
  /*
   * Get the screen attribute for a position in the buffer.
!  * Use a negative "col" to get the filler background color.
   */
      int
  term_get_attr(buf_T *buf, linenr_T lnum, int col)
***************
*** 2328,2340 ****
      sb_line_T	*line;
      cellattr_T	*cellattr;
  
!     if (lnum == 0 || lnum > term->tl_scrollback.ga_len)
  	cellattr = &term->tl_default_color;
      else
      {
  	line = (sb_line_T *)term->tl_scrollback.ga_data + lnum - 1;
! 	if (col >= line->sb_cols)
! 	    cellattr = &term->tl_default_color;
  	else
  	    cellattr = line->sb_cells + col;
      }
--- 2369,2381 ----
      sb_line_T	*line;
      cellattr_T	*cellattr;
  
!     if (lnum > term->tl_scrollback.ga_len)
  	cellattr = &term->tl_default_color;
      else
      {
  	line = (sb_line_T *)term->tl_scrollback.ga_data + lnum - 1;
! 	if (col < 0 || col >= line->sb_cols)
! 	    cellattr = &line->sb_fill_attr;
  	else
  	    cellattr = line->sb_cells + col;
      }
*** ../vim-8.0.1096/src/screen.c	2017-09-11 22:00:46.952401314 +0200
--- src/screen.c	2017-09-11 22:42:18.017569465 +0200
***************
*** 3257,3263 ****
      {
  	extra_check = TRUE;
  	get_term_attr = TRUE;
! 	term_attr = term_get_attr(wp->w_buffer, 0, 0);
      }
  #endif
  
--- 3257,3263 ----
      {
  	extra_check = TRUE;
  	get_term_attr = TRUE;
! 	term_attr = term_get_attr(wp->w_buffer, lnum, -1);
      }
  #endif
  
*** ../vim-8.0.1096/src/version.c	2017-09-11 22:00:46.952401314 +0200
--- src/version.c	2017-09-11 22:08:42.021592743 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     1097,
  /**/

-- 
A meeting is an event at which the minutes are kept and the hours are lost.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
