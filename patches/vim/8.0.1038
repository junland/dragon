To: vim_dev@googlegroups.com
Subject: Patch 8.0.1038
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1038
Problem:    Strike-through text not supported.
Solution:   Add support for the "strikethrough" attribute. (Christian
            Brabandt, Ken Takata)
Files:      runtime/doc/eval.txt, runtime/doc/options.txt,
            runtime/doc/syntax.txt, runtime/doc/term.txt, src/evalfunc.c,
            src/gui.c, src/gui.h, src/gui_gtk_x11.c, src/gui_mac.c,
            src/gui_w32.c, src/gui_x11.c, src/option.c, src/screen.c,
            src/syntax.c, src/term.c, src/term.h, src/terminal.c, src/vim.h


*** ../vim-8.0.1037/runtime/doc/eval.txt	2017-09-02 16:28:32.998776571 +0200
--- runtime/doc/eval.txt	2017-09-02 18:12:41.173778444 +0200
***************
*** 7721,7726 ****
--- 7723,7729 ----
  		"standout"	"1" if standout
  		"underline"	"1" if underlined
  		"undercurl"	"1" if undercurled
+ 		"strike"	"1" if strikethrough
  
  		Example (echoes the color of the syntax item under the
  		cursor): >
*** ../vim-8.0.1037/runtime/doc/options.txt	2017-08-30 22:00:16.366112653 +0200
--- runtime/doc/options.txt	2017-09-02 18:12:41.173778444 +0200
***************
*** 4021,4026 ****
--- 4117,4123 ----
  		s	standout	(termcap entry "so" and "se")
  		u	underline	(termcap entry "us" and "ue")
  		c	undercurl	(termcap entry "Cs" and "Ce")
+ 		t	strikethrough	(termcap entry "Ts" and "Te")
  		n	no highlighting
  		-	no highlighting
  		:	use a highlight group
*** ../vim-8.0.1037/runtime/doc/syntax.txt	2017-08-12 15:12:26.531991936 +0200
--- runtime/doc/syntax.txt	2017-09-02 18:12:41.177778418 +0200
***************
*** 4660,4672 ****
  
  					*bold* *underline* *undercurl*
  					*inverse* *italic* *standout*
! 					*nocombine*
  term={attr-list}			*attr-list* *highlight-term* *E418*
  	attr-list is a comma separated list (without spaces) of the
  	following items (in any order):
  		bold
  		underline
  		undercurl	not always available
  		reverse
  		inverse		same as reverse
  		italic
--- 4699,4712 ----
  
  					*bold* *underline* *undercurl*
  					*inverse* *italic* *standout*
! 					*nocombine* *strikethrough*
  term={attr-list}			*attr-list* *highlight-term* *E418*
  	attr-list is a comma separated list (without spaces) of the
  	following items (in any order):
  		bold
  		underline
  		undercurl	not always available
+ 		strikethrough	not always available
  		reverse
  		inverse		same as reverse
  		italic
***************
*** 4677,4684 ****
  	Note that "bold" can be used here and by using a bold font.  They
  	have the same effect.
  	"undercurl" is a curly underline.  When "undercurl" is not possible
! 	then "underline" is used.  In general "undercurl" is only available in
! 	the GUI.  The color is set with |highlight-guisp|.
  
  start={term-list}				*highlight-start* *E422*
  stop={term-list}				*term-list* *highlight-stop*
--- 4717,4724 ----
  	Note that "bold" can be used here and by using a bold font.  They
  	have the same effect.
  	"undercurl" is a curly underline.  When "undercurl" is not possible
! 	then "underline" is used.  In general "undercurl" and "strikethrough"
! 	is only available in the GUI.  The color is set with |highlight-guisp|.
  
  start={term-list}				*highlight-start* *E422*
  stop={term-list}				*term-list* *highlight-stop*
***************
*** 4785,4794 ****
  	Example: >
  		:highlight Normal ctermfg=grey ctermbg=darkblue
  <	When setting the "ctermbg" color for the Normal group, the
! 	'background' option will be adjusted automatically.  This causes the
! 	highlight groups that depend on 'background' to change!  This means
! 	you should set the colors for Normal first, before setting other
! 	colors.
  	When a colorscheme is being used, changing 'background' causes it to
  	be reloaded, which may reset all colors (including Normal).  First
  	delete the "g:colors_name" variable when you don't want this.
--- 4825,4835 ----
  	Example: >
  		:highlight Normal ctermfg=grey ctermbg=darkblue
  <	When setting the "ctermbg" color for the Normal group, the
! 	'background' option will be adjusted automatically, under the
! 	condition that the color is recognized and 'background' was not set
! 	explicitly.  This causes the highlight groups that depend on
! 	'background' to change!  This means you should set the colors for
! 	Normal first, before setting other colors.
  	When a colorscheme is being used, changing 'background' causes it to
  	be reloaded, which may reset all colors (including Normal).  First
  	delete the "g:colors_name" variable when you don't want this.
***************
*** 4842,4848 ****
  guibg={color-name}					*highlight-guibg*
  guisp={color-name}					*highlight-guisp*
  	These give the foreground (guifg), background (guibg) and special
! 	(guisp) color to use in the GUI.  "guisp" is used for undercurl.
  	There are a few special names:
  		NONE		no color (transparent)
  		bg		use normal background color
--- 4883,4890 ----
  guibg={color-name}					*highlight-guibg*
  guisp={color-name}					*highlight-guisp*
  	These give the foreground (guifg), background (guibg) and special
! 	(guisp) color to use in the GUI.  "guisp" is used for undercurl and
! 	strikethrough.
  	There are a few special names:
  		NONE		no color (transparent)
  		bg		use normal background color
*** ../vim-8.0.1037/runtime/doc/term.txt	2017-02-02 22:20:49.279397163 +0100
--- runtime/doc/term.txt	2017-09-02 18:12:41.177778418 +0200
***************
*** 252,258 ****
  that the flag is not set.  't_CS' works like this too, but it isn't a termcap
  flag.
  
! OUTPUT CODES
  	option	meaning	~
  
  	t_AB	set background color (ANSI)			*t_AB* *'t_AB'*
--- 252,258 ----
  that the flag is not set.  't_CS' works like this too, but it isn't a termcap
  flag.
  
! OUTPUT CODES						*terminal-output-codes*
  	option	meaning	~
  
  	t_AB	set background color (ANSI)			*t_AB* *'t_AB'*
***************
*** 295,307 ****
  	t_ts	set window title start (to status line)		*t_ts* *'t_ts'*
  	t_ue	underline end					*t_ue* *'t_ue'*
  	t_us	underline mode					*t_us* *'t_us'*
- 	t_Ce	undercurl end					*t_Ce* *'t_Ce'*
- 	t_Cs	undercurl mode					*t_Cs* *'t_Cs'*
  	t_ut	clearing uses the current background color	*t_ut* *'t_ut'*
  	t_vb	visual bell					*t_vb* *'t_vb'*
  	t_ve	cursor visible					*t_ve* *'t_ve'*
  	t_vi	cursor invisible				*t_vi* *'t_vi'*
! 	t_vs	cursor very visible				*t_vs* *'t_vs'*
  								*t_xs* *'t_xs'*
  	t_xs	if non-empty, standout not erased by overwriting (hpterm)
  								*t_xn* *'t_xn'*
--- 295,305 ----
  	t_ts	set window title start (to status line)		*t_ts* *'t_ts'*
  	t_ue	underline end					*t_ue* *'t_ue'*
  	t_us	underline mode					*t_us* *'t_us'*
  	t_ut	clearing uses the current background color	*t_ut* *'t_ut'*
  	t_vb	visual bell					*t_vb* *'t_vb'*
  	t_ve	cursor visible					*t_ve* *'t_ve'*
  	t_vi	cursor invisible				*t_vi* *'t_vi'*
! 	t_vs	cursor very visible (blink)			*t_vs* *'t_vs'*
  								*t_xs* *'t_xs'*
  	t_xs	if non-empty, standout not erased by overwriting (hpterm)
  								*t_xn* *'t_xn'*
***************
*** 311,320 ****
  	t_ZR	italics end					*t_ZR* *'t_ZR'*
  
  Added by Vim (there are no standard codes for these):
  	t_IS	set icon text start				*t_IS* *'t_IS'*
  	t_IE	set icon text end				*t_IE* *'t_IE'*
  	t_WP	set window position (Y, X) in pixels		*t_WP* *'t_WP'*
! 	t_WS	set window size (height, width) in characters	*t_WS* *'t_WS'*
  	t_SI	start insert mode (bar cursor shape)		*t_SI* *'t_SI'*
  	t_SR	start replace mode (underline cursor shape)	*t_SR* *'t_SR'*
  	t_EI	end insert or replace mode (block cursor shape)	*t_EI* *'t_EI'*
--- 309,324 ----
  	t_ZR	italics end					*t_ZR* *'t_ZR'*
  
  Added by Vim (there are no standard codes for these):
+ 	t_Ce	undercurl end					*t_Ce* *'t_Ce'*
+ 	t_Cs	undercurl mode					*t_Cs* *'t_Cs'*
+ 	t_Te	strikethrough end				*t_Te* *'t_Te'*
+ 	t_Ts	strikethrough mode				*t_Ts* *'t_Ts'*
  	t_IS	set icon text start				*t_IS* *'t_IS'*
  	t_IE	set icon text end				*t_IE* *'t_IE'*
  	t_WP	set window position (Y, X) in pixels		*t_WP* *'t_WP'*
! 	t_GP	get window position (Y, X) in pixels		*t_GP* *'t_GP'*
! 	t_WS	set window size (height, width in cells)	*t_WS* *'t_WS'*
! 	t_VS	cursor normally visible (no blink)		*t_VS* *'t_VS'*
  	t_SI	start insert mode (bar cursor shape)		*t_SI* *'t_SI'*
  	t_SR	start replace mode (underline cursor shape)	*t_SR* *'t_SR'*
  	t_EI	end insert or replace mode (block cursor shape)	*t_EI* *'t_EI'*
***************
*** 332,339 ****
  		|xterm-bracketed-paste|
  	t_BD	disable bracketed paste mode			*t_BD* *'t_BD'*
  		|xterm-bracketed-paste|
  
! KEY CODES
  Note: Use the <> form if possible
  
  	option	name		meaning	~
--- 336,366 ----
  		|xterm-bracketed-paste|
  	t_BD	disable bracketed paste mode			*t_BD* *'t_BD'*
  		|xterm-bracketed-paste|
+ 	t_SC	set cursor color start				*t_SC* *'t_SC'*
+ 	t_EC	set cursor color end				*t_EC* *'t_EC'*
+ 	t_SH	set cursor shape				*t_SH* *'t_SH'*
+ 	t_RC	request terminal cursor blinking		*t_RC* *'t_RC'*
+ 	t_RS	request terminal cursor style			*t_RS* *'t_RS'*
+ 
+ Some codes have a start, middle and end part.  The start and end are defined
+ by the termcap option, the middle part is text.
+ 	set title text:     t_ts {title text} t_fs
+ 	set icon text:      t_IS {icon text} t_IE
+ 	set cursor color:   t_SC  {color name}  t_EC
+ 
+ t_SH must take one argument:
+ 	0, 1 or none  	blinking block cursor
+ 	2	      	block cursor
+ 	3		blinking underline cursor
+ 	4		underline cursor
+ 	5		blinking vertical bar cursor
+ 	6		vertical bar cursor
+ 
+ t_RS is sent only if the response to t_RV has been received.  It is not used
+ on Mac OS when Terminal.app could be recognized from the termresponse.
+ 
  
! KEY CODES						*terminal-key-codes*
  Note: Use the <> form if possible
  
  	option	name		meaning	~
***************
*** 424,431 ****
  	t_KK	<k8>		keypad 8		 *<k8>*	*t_KK* *'t_KK'*
  	t_KL	<k9>		keypad 9		 *<k9>*	*t_KL* *'t_KL'*
  		<Mouse>		leader of mouse code		*<Mouse>*
! 	t_PS	start of bracketed paste |xterm-bracketed-paste|  *t_PS* 't_PS'
! 	t_PE	end of bracketed paste |xterm-bracketed-paste|    *t_PE* 't_PE'
  
  Note about t_so and t_mr: When the termcap entry "so" is not present the
  entry for "mr" is used.  And vice versa.  The same is done for "se" and "me".
--- 451,459 ----
  	t_KK	<k8>		keypad 8		 *<k8>*	*t_KK* *'t_KK'*
  	t_KL	<k9>		keypad 9		 *<k9>*	*t_KL* *'t_KL'*
  		<Mouse>		leader of mouse code		*<Mouse>*
! 								*t_PS* *'t_PS'*
! 	t_PS	start of bracketed paste |xterm-bracketed-paste|
! 	t_PE	end of bracketed paste |xterm-bracketed-paste|  *t_PE* *'t_PE'*
  
  Note about t_so and t_mr: When the termcap entry "so" is not present the
  entry for "mr" is used.  And vice versa.  The same is done for "se" and "me".
*** ../vim-8.0.1037/src/evalfunc.c	2017-08-27 15:23:37.512977267 +0200
--- src/evalfunc.c	2017-09-02 18:12:41.177778418 +0200
***************
*** 11843,11848 ****
--- 11843,11852 ----
  	case 's':
  		if (TOLOWER_ASC(what[1]) == 'p')	/* sp[#] */
  		    p = highlight_color(id, what, modec);
+ 							/* strikeout */
+ 		else if (TOLOWER_ASC(what[1]) == 't' &&
+ 			TOLOWER_ASC(what[2]) == 'r')
+ 		    p = highlight_has_attr(id, HL_STRIKETHROUGH, modec);
  		else					/* standout */
  		    p = highlight_has_attr(id, HL_STANDOUT, modec);
  		break;
*** ../vim-8.0.1037/src/gui.c	2017-08-16 22:45:57.681684043 +0200
--- src/gui.c	2017-09-02 18:12:41.181778393 +0200
***************
*** 2396,2401 ****
--- 2396,2402 ----
      /* Do we underline the text? */
      if (hl_mask_todo & HL_UNDERLINE)
  	draw_flags |= DRAW_UNDERL;
+ 
  #else
      /* Do we underline the text? */
      if ((hl_mask_todo & HL_UNDERLINE) || (hl_mask_todo & HL_ITALIC))
***************
*** 2405,2410 ****
--- 2406,2415 ----
      if (hl_mask_todo & HL_UNDERCURL)
  	draw_flags |= DRAW_UNDERC;
  
+     /* Do we strikethrough the text? */
+     if (hl_mask_todo & HL_STRIKETHROUGH)
+ 	draw_flags |= DRAW_STRIKE;
+ 
      /* Do we draw transparently? */
      if (flags & GUI_MON_TRS_CURSOR)
  	draw_flags |= DRAW_TRANSP;
*** ../vim-8.0.1037/src/gui.h	2016-09-09 22:00:25.000000000 +0200
--- src/gui.h	2017-09-02 18:12:41.181778393 +0200
***************
*** 142,147 ****
--- 142,148 ----
  # define DRAW_ITALIC		0x10	/* draw italic text */
  #endif
  #define DRAW_CURSOR		0x20	/* drawing block cursor (win32) */
+ #define DRAW_STRIKE		0x40	/* strikethrough */
  
  /* For our own tearoff menu item */
  #define TEAR_STRING		"-->Detach"
*** ../vim-8.0.1037/src/gui_gtk_x11.c	2017-08-27 14:50:43.233759875 +0200
--- src/gui_gtk_x11.c	2017-09-02 18:12:41.181778393 +0200
***************
*** 5908,5913 ****
--- 5908,5934 ----
  #endif
      }
  
+     /* Draw a strikethrough line */
+     if (flags & DRAW_STRIKE)
+     {
+ #if GTK_CHECK_VERSION(3,0,0)
+ 	cairo_set_line_width(cr, 1.0);
+ 	cairo_set_line_cap(cr, CAIRO_LINE_CAP_BUTT);
+ 	cairo_set_source_rgba(cr,
+ 		gui.spcolor->red, gui.spcolor->green, gui.spcolor->blue,
+ 		gui.spcolor->alpha);
+ 	cairo_move_to(cr, FILL_X(col), y + 1 - gui.char_height/2 + 0.5);
+ 	cairo_line_to(cr, FILL_X(col + cells), y + 1 - gui.char_height/2 + 0.5);
+ 	cairo_stroke(cr);
+ #else
+ 	gdk_gc_set_foreground(gui.text_gc, gui.spcolor);
+ 	gdk_draw_line(gui.drawarea->window, gui.text_gc,
+ 		      FILL_X(col), y + 1 - gui.char_height/2,
+ 		      FILL_X(col + cells), y + 1 - gui.char_height/2);
+ 	gdk_gc_set_foreground(gui.text_gc, gui.fgcolor);
+ #endif
+     }
+ 
      /* Underline: draw a line at the bottom of the character cell. */
      if (flags & DRAW_UNDERL)
      {
***************
*** 5916,5931 ****
  	if (p_linespace > 1)
  	    y -= p_linespace - 1;
  #if GTK_CHECK_VERSION(3,0,0)
! 	{
! 	    cairo_set_line_width(cr, 1.0);
! 	    cairo_set_line_cap(cr, CAIRO_LINE_CAP_BUTT);
! 	    cairo_set_source_rgba(cr,
! 		    gui.fgcolor->red, gui.fgcolor->green, gui.fgcolor->blue,
! 		    gui.fgcolor->alpha);
! 	    cairo_move_to(cr, FILL_X(col), y + 0.5);
! 	    cairo_line_to(cr, FILL_X(col + cells), y + 0.5);
! 	    cairo_stroke(cr);
! 	}
  #else
  	gdk_draw_line(gui.drawarea->window, gui.text_gc,
  		      FILL_X(col), y,
--- 5937,5950 ----
  	if (p_linespace > 1)
  	    y -= p_linespace - 1;
  #if GTK_CHECK_VERSION(3,0,0)
! 	cairo_set_line_width(cr, 1.0);
! 	cairo_set_line_cap(cr, CAIRO_LINE_CAP_BUTT);
! 	cairo_set_source_rgba(cr,
! 		gui.fgcolor->red, gui.fgcolor->green, gui.fgcolor->blue,
! 		gui.fgcolor->alpha);
! 	cairo_move_to(cr, FILL_X(col), y + 0.5);
! 	cairo_line_to(cr, FILL_X(col + cells), y + 0.5);
! 	cairo_stroke(cr);
  #else
  	gdk_draw_line(gui.drawarea->window, gui.text_gc,
  		      FILL_X(col), y,
*** ../vim-8.0.1037/src/gui_mac.c	2017-07-23 16:45:05.673761155 +0200
--- src/gui_mac.c	2017-09-02 18:12:41.181778393 +0200
***************
*** 3899,3904 ****
--- 3899,3909 ----
  	    MoveTo(FILL_X(col), FILL_Y(row + 1) - 1);
  	    LineTo(FILL_X(col + len) - 1, FILL_Y(row + 1) - 1);
  	}
+ 	if (flags & DRAW_STRIKE)
+ 	{
+ 	    MoveTo(FILL_X(col), FILL_Y(row + 1) - gui.char_height/2);
+ 	    LineTo(FILL_X(col + len) - 1, FILL_Y(row + 1) - gui.char_height/2);
+ 	}
      }
  
      if (flags & DRAW_UNDERC)
*** ../vim-8.0.1037/src/gui_w32.c	2017-08-13 15:37:53.289473878 +0200
--- src/gui_w32.c	2017-09-02 18:12:41.181778393 +0200
***************
*** 6427,6432 ****
--- 6427,6444 ----
  	DeleteObject(SelectObject(s_hdc, old_pen));
      }
  
+     /* Strikethrough */
+     if (flags & DRAW_STRIKE)
+     {
+ 	hpen = CreatePen(PS_SOLID, 1, gui.currSpColor);
+ 	old_pen = SelectObject(s_hdc, hpen);
+ 	y = FILL_Y(row + 1) - gui.char_height/2;
+ 	MoveToEx(s_hdc, FILL_X(col), y, NULL);
+ 	/* Note: LineTo() excludes the last pixel in the line. */
+ 	LineTo(s_hdc, FILL_X(col + len), y);
+ 	DeleteObject(SelectObject(s_hdc, old_pen));
+     }
+ 
      /* Undercurl */
      if (flags & DRAW_UNDERC)
      {
*** ../vim-8.0.1037/src/gui_x11.c	2017-08-27 17:38:23.744775277 +0200
--- src/gui_x11.c	2017-09-02 18:12:41.181778393 +0200
***************
*** 2542,2547 ****
--- 2542,2557 ----
  		y, FILL_X(col + cells) - 1, y);
      }
  
+     if (flags & DRAW_STRIKE)
+     {
+ 	int	y = FILL_Y(row + 1) - gui.char_height/2;
+ 
+ 	XSetForeground(gui.dpy, gui.text_gc, prev_sp_color);
+ 	XDrawLine(gui.dpy, gui.wid, gui.text_gc, FILL_X(col),
+ 		y, FILL_X(col + cells) - 1, y);
+ 	XSetForeground(gui.dpy, gui.text_gc, prev_fg_color);
+     }
+ 
  #ifdef FEAT_XFONTSET
      if (current_fontset != NULL)
  	XSetClipMask(gui.dpy, gui.text_gc, None);
*** ../vim-8.0.1037/src/option.c	2017-08-30 22:00:16.374112596 +0200
--- src/option.c	2017-09-02 18:12:41.185778366 +0200
***************
*** 3216,3223 ****
--- 3216,3225 ----
      p_term("t_so", T_SO)
      p_term("t_SR", T_CSR)
      p_term("t_sr", T_SR)
+     p_term("t_Te", T_STE)
      p_term("t_te", T_TE)
      p_term("t_ti", T_TI)
+     p_term("t_Ts", T_STS)
      p_term("t_ts", T_TS)
      p_term("t_u7", T_U7)
      p_term("t_ue", T_UE)
*** ../vim-8.0.1037/src/screen.c	2017-08-30 22:00:16.374112596 +0200
--- src/screen.c	2017-09-02 18:12:41.185778366 +0200
***************
*** 235,241 ****
      else
  #endif
  	/* Use attributes that is very unlikely to appear in text. */
! 	screen_attr = HL_BOLD | HL_UNDERLINE | HL_INVERSE;
  }
  
  /*
--- 235,241 ----
      else
  #endif
  	/* Use attributes that is very unlikely to appear in text. */
! 	screen_attr = HL_BOLD | HL_UNDERLINE | HL_INVERSE | HL_STRIKETHROUGH;
  }
  
  /*
***************
*** 8086,8091 ****
--- 8086,8093 ----
  		out_str(T_CZH);
  	    if ((attr & HL_INVERSE) && T_MR != NULL)	/* inverse (reverse) */
  		out_str(T_MR);
+ 	    if ((attr & HL_STRIKETHROUGH) && T_STS != NULL)	/* strike */
+ 		out_str(T_STS);
  
  	    /*
  	     * Output the color or start string after bold etc., in case the
***************
*** 8210,8215 ****
--- 8212,8224 ----
  		else
  		    out_str(T_CZR);
  	    }
+ 	    if (screen_attr & HL_STRIKETHROUGH)
+ 	    {
+ 		if (STRCMP(T_STE, T_ME) == 0)
+ 		    do_ME = TRUE;
+ 		else
+ 		    out_str(T_STE);
+ 	    }
  	    if (do_ME || (screen_attr & (HL_BOLD | HL_INVERSE)))
  		out_str(T_ME);
  
*** ../vim-8.0.1037/src/syntax.c	2017-08-19 21:35:30.946569153 +0200
--- src/syntax.c	2017-09-02 18:12:41.185778366 +0200
***************
*** 86,94 ****
   */
  static char *(hl_name_table[]) =
      {"bold", "standout", "underline", "undercurl",
! 			  "italic", "reverse", "inverse", "nocombine", "NONE"};
  static int hl_attr_table[] =
!     {HL_BOLD, HL_STANDOUT, HL_UNDERLINE, HL_UNDERCURL, HL_ITALIC, HL_INVERSE, HL_INVERSE, HL_NOCOMBINE, 0};
  #define ATTR_COMBINE(attr_a, attr_b) ((((attr_b) & HL_NOCOMBINE) ? attr_b : (attr_a)) | (attr_b))
  
  static int get_attr_entry(garray_T *table, attrentry_T *aep);
--- 86,94 ----
   */
  static char *(hl_name_table[]) =
      {"bold", "standout", "underline", "undercurl",
!       "italic", "reverse", "inverse", "nocombine", "strikethrough", "NONE"};
  static int hl_attr_table[] =
!     {HL_BOLD, HL_STANDOUT, HL_UNDERLINE, HL_UNDERCURL, HL_ITALIC, HL_INVERSE, HL_INVERSE, HL_NOCOMBINE, HL_STRIKETHROUGH, 0};
  #define ATTR_COMBINE(attr_a, attr_b) ((((attr_b) & HL_NOCOMBINE) ? attr_b : (attr_a)) | (attr_b))
  
  static int get_attr_entry(garray_T *table, attrentry_T *aep);
***************
*** 9951,9956 ****
--- 9951,9958 ----
  				break;
  		    case 'c':	attr |= HL_UNDERCURL;
  				break;
+ 		    case 't':	attr |= HL_STRIKETHROUGH;
+ 				break;
  		    case ':':	++p;		    /* highlight group name */
  				if (attr || *p == NUL)	 /* no combinations */
  				    return FAIL;
*** ../vim-8.0.1037/src/term.c	2017-09-01 20:23:58.756539582 +0200
--- src/term.c	2017-09-02 18:12:41.185778366 +0200
***************
*** 217,222 ****
--- 217,224 ----
      {(int)KS_US,	IF_EB("\033|8h", ESC_STR "|8h")},   /* HL_UNDERLINE */
      {(int)KS_UCE,	IF_EB("\033|8C", ESC_STR "|8C")},   /* HL_UNDERCURL */
      {(int)KS_UCS,	IF_EB("\033|8c", ESC_STR "|8c")},   /* HL_UNDERCURL */
+     {(int)KS_STE,	IF_EB("\033|4C", ESC_STR "|4C")},   /* HL_STRIKETHROUGH */
+     {(int)KS_STS,	IF_EB("\033|4c", ESC_STR "|4c")},   /* HL_STRIKETHROUGH */
      {(int)KS_CZR,	IF_EB("\033|4H", ESC_STR "|4H")},   /* HL_ITALIC */
      {(int)KS_CZH,	IF_EB("\033|4h", ESC_STR "|4h")},   /* HL_ITALIC */
      {(int)KS_VB,	IF_EB("\033|f", ESC_STR "|f")},
***************
*** 831,836 ****
--- 833,840 ----
      {(int)KS_MD,	IF_EB("\033[1m", ESC_STR "[1m")},
      {(int)KS_UE,	IF_EB("\033[m", ESC_STR "[m")},
      {(int)KS_US,	IF_EB("\033[4m", ESC_STR "[4m")},
+     {(int)KS_STE,	IF_EB("\033[29m", ESC_STR "[29m")},
+     {(int)KS_STS,	IF_EB("\033[9m", ESC_STR "[9m")},
      {(int)KS_MS,	"y"},
      {(int)KS_UT,	"y"},
      {(int)KS_LE,	"\b"},
***************
*** 1151,1156 ****
--- 1155,1162 ----
      {(int)KS_US,	"[US]"},
      {(int)KS_UCE,	"[UCE]"},
      {(int)KS_UCS,	"[UCS]"},
+     {(int)KS_STE,	"[STE]"},
+     {(int)KS_STS,	"[STS]"},
      {(int)KS_MS,	"[MS]"},
      {(int)KS_UT,	"[UT]"},
      {(int)KS_XN,	"[XN]"},
***************
*** 1595,1600 ****
--- 1601,1607 ----
  				{KS_MD, "md"}, {KS_SE, "se"}, {KS_SO, "so"},
  				{KS_CZH,"ZH"}, {KS_CZR,"ZR"}, {KS_UE, "ue"},
  				{KS_US, "us"}, {KS_UCE, "Ce"}, {KS_UCS, "Cs"},
+ 				{KS_STE,"Te"}, {KS_STS,"Ts"},
  				{KS_CM, "cm"}, {KS_SR, "sr"},
  				{KS_CRI,"RI"}, {KS_VB, "vb"}, {KS_KS, "ks"},
  				{KS_KE, "ke"}, {KS_TI, "ti"}, {KS_TE, "te"},
*** ../vim-8.0.1037/src/term.h	2017-08-28 22:43:00.774266657 +0200
--- src/term.h	2017-09-02 18:12:41.185778366 +0200
***************
*** 55,60 ****
--- 55,62 ----
      KS_US,	/* underscore (underline) mode */
      KS_UCE,	/* exit undercurl mode */
      KS_UCS,	/* undercurl mode */
+     KS_STE,	/* exit strikethrough mode */
+     KS_STS,	/* strikethrough mode */
      KS_MS,	/* save to move cur in reverse mode */
      KS_CM,	/* cursor motion */
      KS_SR,	/* scroll reverse (backward) */
***************
*** 149,154 ****
--- 151,158 ----
  #define T_US	(TERM_STR(KS_US))	/* underscore (underline) mode */
  #define T_UCE	(TERM_STR(KS_UCE))	/* exit undercurl mode */
  #define T_UCS	(TERM_STR(KS_UCS))	/* undercurl mode */
+ #define T_STE	(TERM_STR(KS_STE))	/* exit strikethrough mode */
+ #define T_STS	(TERM_STR(KS_STS))	/* strikethrough mode */
  #define T_MS	(TERM_STR(KS_MS))	/* save to move cur in reverse mode */
  #define T_CM	(TERM_STR(KS_CM))	/* cursor motion */
  #define T_SR	(TERM_STR(KS_SR))	/* scroll reverse (backward) */
*** ../vim-8.0.1037/src/terminal.c	2017-09-02 17:18:31.226946592 +0200
--- src/terminal.c	2017-09-02 18:12:41.185778366 +0200
***************
*** 1735,1741 ****
      if (cellattrs.italic)
  	attr |= HL_ITALIC;
      if (cellattrs.strike)
! 	attr |= HL_STANDOUT;
      if (cellattrs.reverse)
  	attr |= HL_INVERSE;
  
--- 1735,1741 ----
      if (cellattrs.italic)
  	attr |= HL_ITALIC;
      if (cellattrs.strike)
! 	attr |= HL_STRIKETHROUGH;
      if (cellattrs.reverse)
  	attr |= HL_INVERSE;
  
***************
*** 2451,2457 ****
  	{"bold",      HL_BOLD},
  	{"italic",    HL_ITALIC},
  	{"underline", HL_UNDERLINE},
! 	{"strike",    HL_STANDOUT},
  	{"reverse",   HL_INVERSE},
      };
  
--- 2451,2457 ----
  	{"bold",      HL_BOLD},
  	{"italic",    HL_ITALIC},
  	{"underline", HL_UNDERLINE},
! 	{"strike",    HL_STRIKETHROUGH},
  	{"reverse",   HL_INVERSE},
      };
  
*** ../vim-8.0.1037/src/vim.h	2017-08-30 14:53:02.807426564 +0200
--- src/vim.h	2017-09-02 18:12:41.189778341 +0200
***************
*** 681,687 ****
  #define HL_UNDERCURL		0x10
  #define HL_STANDOUT		0x20
  #define HL_NOCOMBINE		0x40
! #define HL_ALL			0x7f
  
  /* special attribute addition: Put message in history */
  #define MSG_HIST		0x1000
--- 681,688 ----
  #define HL_UNDERCURL		0x10
  #define HL_STANDOUT		0x20
  #define HL_NOCOMBINE		0x40
! #define HL_STRIKETHROUGH	0x80
! #define HL_ALL			0xff
  
  /* special attribute addition: Put message in history */
  #define MSG_HIST		0x1000
*** ../vim-8.0.1037/src/version.c	2017-09-02 18:01:46.422018216 +0200
--- src/version.c	2017-09-02 18:13:51.077329898 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     1038,
  /**/

-- 
Never go to the toilet in a paperless office.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
