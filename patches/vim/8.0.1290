To: vim_dev@googlegroups.com
Subject: Patch 8.0.1290
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1290
Problem:    seq_cur of undotree() wrong after undo.
Solution:   Get the actual sequence number instead of decrementing the current
            one. (Ozaki Kiichi, closes #2319)
Files:      src/undo.c, src/testdir/test_undo.vim


*** ../vim-8.0.1289/src/undo.c	2017-10-28 21:08:38.995456898 +0200
--- src/undo.c	2017-11-11 23:26:55.685922304 +0100
***************
*** 2863,2871 ****
      /* Remember where we are for "g-" and ":earlier 10s". */
      curbuf->b_u_seq_cur = curhead->uh_seq;
      if (undo)
  	/* We are below the previous undo.  However, to make ":earlier 1s"
  	 * work we compute this as being just above the just undone change. */
! 	--curbuf->b_u_seq_cur;
  
      /* Remember where we are for ":earlier 1f" and ":later 1f". */
      if (curhead->uh_save_nr != 0)
--- 2863,2876 ----
      /* Remember where we are for "g-" and ":earlier 10s". */
      curbuf->b_u_seq_cur = curhead->uh_seq;
      if (undo)
+     {
  	/* We are below the previous undo.  However, to make ":earlier 1s"
  	 * work we compute this as being just above the just undone change. */
! 	if (curhead->uh_next.ptr != NULL)
! 	    curbuf->b_u_seq_cur = curhead->uh_next.ptr->uh_seq;
! 	else
! 	    curbuf->b_u_seq_cur = 0;
!     }
  
      /* Remember where we are for ":earlier 1f" and ":later 1f". */
      if (curhead->uh_save_nr != 0)
*** ../vim-8.0.1289/src/testdir/test_undo.vim	2017-11-04 22:36:47.331496337 +0100
--- src/testdir/test_undo.vim	2017-11-11 23:29:25.407647114 +0100
***************
*** 4,25 ****
  " Also tests :earlier and :later.
  
  func Test_undotree()
!   exe "normal Aabc\<Esc>"
    set ul=100
!   exe "normal Adef\<Esc>"
    set ul=100
    undo
    let d = undotree()
!   call assert_true(d.seq_last > 0)
!   call assert_true(d.seq_cur > 0)
!   call assert_true(d.seq_cur < d.seq_last)
!   call assert_true(len(d.entries) > 0)
!   " TODO: check more members of d
  
    w! Xtest
!   call assert_equal(d.save_last + 1, undotree().save_last)
    call delete('Xtest')
!   bwipe Xtest
  endfunc
  
  func FillBuffer()
--- 4,85 ----
  " Also tests :earlier and :later.
  
  func Test_undotree()
!   new
! 
!   normal! Aabc
!   set ul=100
!   let d = undotree()
!   call assert_equal(1, d.seq_last)
!   call assert_equal(1, d.seq_cur)
!   call assert_equal(0, d.save_last)
!   call assert_equal(0, d.save_cur)
!   call assert_equal(1, len(d.entries))
!   call assert_equal(1, d.entries[0].newhead)
!   call assert_equal(1, d.entries[0].seq)
!   call assert_true(d.entries[0].time <= d.time_cur)
! 
!   normal! Adef
!   set ul=100
!   let d = undotree()
!   call assert_equal(2, d.seq_last)
!   call assert_equal(2, d.seq_cur)
!   call assert_equal(0, d.save_last)
!   call assert_equal(0, d.save_cur)
!   call assert_equal(2, len(d.entries))
!   call assert_equal(1, d.entries[0].seq)
!   call assert_equal(1, d.entries[1].newhead)
!   call assert_equal(2, d.entries[1].seq)
!   call assert_true(d.entries[1].time <= d.time_cur)
! 
!   undo
    set ul=100
!   let d = undotree()
!   call assert_equal(2, d.seq_last)
!   call assert_equal(1, d.seq_cur)
!   call assert_equal(0, d.save_last)
!   call assert_equal(0, d.save_cur)
!   call assert_equal(2, len(d.entries))
!   call assert_equal(1, d.entries[0].seq)
!   call assert_equal(1, d.entries[1].curhead)
!   call assert_equal(1, d.entries[1].newhead)
!   call assert_equal(2, d.entries[1].seq)
!   call assert_true(d.entries[1].time == d.time_cur)
! 
!   normal! Aghi
    set ul=100
+   let d = undotree()
+   call assert_equal(3, d.seq_last)
+   call assert_equal(3, d.seq_cur)
+   call assert_equal(0, d.save_last)
+   call assert_equal(0, d.save_cur)
+   call assert_equal(2, len(d.entries))
+   call assert_equal(1, d.entries[0].seq)
+   call assert_equal(2, d.entries[1].alt[0].seq)
+   call assert_equal(1, d.entries[1].newhead)
+   call assert_equal(3, d.entries[1].seq)
+   call assert_true(d.entries[1].time <= d.time_cur)
+ 
    undo
+   set ul=100
    let d = undotree()
!   call assert_equal(3, d.seq_last)
!   call assert_equal(1, d.seq_cur)
!   call assert_equal(0, d.save_last)
!   call assert_equal(0, d.save_cur)
!   call assert_equal(2, len(d.entries))
!   call assert_equal(1, d.entries[0].seq)
!   call assert_equal(2, d.entries[1].alt[0].seq)
!   call assert_equal(1, d.entries[1].curhead)
!   call assert_equal(1, d.entries[1].newhead)
!   call assert_equal(3, d.entries[1].seq)
!   call assert_true(d.entries[1].time == d.time_cur)
  
    w! Xtest
!   let d = undotree()
!   call assert_equal(1, d.save_cur)
!   call assert_equal(1, d.save_last)
    call delete('Xtest')
!   bwipe! Xtest
  endfunc
  
  func FillBuffer()
*** ../vim-8.0.1289/src/version.c	2017-11-11 18:16:44.097617863 +0100
--- src/version.c	2017-11-11 23:31:02.802169099 +0100
***************
*** 763,764 ****
--- 763,766 ----
  {   /* Add new patch number below this line */
+ /**/
+     1290,
  /**/

-- 
Any resemblance between the above views and those of my employer, my terminal,
or the view out my window are purely coincidental.  Any resemblance between
the above and my own views is non-deterministic.  The question of the
existence of views in the absence of anyone to hold them is left as an
exercise for the reader.  The question of the existence of the reader is left
as an exercise for the second god coefficient.  (A discussion of
non-orthogonal, non-integral polytheism is beyond the scope of this article.)
						(Ralph Jennings)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
