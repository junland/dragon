To: vim_dev@googlegroups.com
Subject: Patch 8.0.1016
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1016
Problem:    Gnome terminal echoes t_RC.
Solution:   Detect Gnome terminal by the version string.  Add v: variables for
            all the term responses.
Files:      src/term.c, src/eval.c, src/vim.h, runtime/doc/eval.txt


*** ../vim-8.0.1015/src/term.c	2017-08-28 23:00:51.867825962 +0200
--- src/term.c	2017-08-30 14:02:28.640044862 +0200
***************
*** 1369,1377 ****
  static char_u	termleader[256 + 1];	    /* for check_termcode() */
  #ifdef FEAT_TERMRESPONSE
  static int	check_for_codes = FALSE;    /* check for key code response */
! # ifdef MACOS
! static int	is_terminal_app = FALSE;    /* recognized Terminal.app */
! # endif
  #endif
  
      static struct builtin_term *
--- 1369,1375 ----
  static char_u	termleader[256 + 1];	    /* for check_termcode() */
  #ifdef FEAT_TERMRESPONSE
  static int	check_for_codes = FALSE;    /* check for key code response */
! static int	is_not_xterm = FALSE;	    /* recognized not-really-xterm */
  #endif
  
      static struct builtin_term *
***************
*** 3506,3518 ****
  /*
   * Similar to requesting the version string: Request the terminal background
   * color when it is the right moment.
-  * Also request the cursor shape, if possible.
   */
      void
  may_req_bg_color(void)
  {
-     int	    did_one = FALSE;
- 
      if (can_get_termresponse() && starting == 0)
      {
  	/* Only request background if t_RB is set and 'background' wasn't
--- 3504,3513 ----
***************
*** 3524,3543 ****
  	    LOG_TR("Sending BG request");
  	    out_str(T_RBG);
  	    rbg_status = STATUS_SENT;
- 	    did_one = TRUE;
- 	}
- 
- 	/* Only request cursor blinking mode if t_RC is set. */
- 	if (rbm_status == STATUS_GET && *T_CRC != NUL)
- 	{
- 	    LOG_TR("Sending BC request");
- 	    out_str(T_CRC);
- 	    rbm_status = STATUS_SENT;
- 	    did_one = TRUE;
- 	}
  
- 	if (did_one)
- 	{
  	    /* check for the characters now, otherwise they might be eaten by
  	     * get_keystroke() */
  	    out_flush();
--- 3519,3525 ----
***************
*** 4505,4510 ****
--- 4487,4495 ----
  		    key_name[0] = (int)KS_EXTRA;
  		    key_name[1] = (int)KE_IGNORE;
  		    slen = i + 1;
+ # ifdef FEAT_EVAL
+ 		    set_vim_var_string(VV_TERMU7RESP, tp, slen);
+ # endif
  		}
  		else
  #endif
***************
*** 4530,4535 ****
--- 4515,4522 ----
  
  		    if (tp[1 + (tp[0] != CSI)] == '>' && semicols == 2)
  		    {
+ 			int need_flush = FALSE;
+ 
  			/* Only set 'ttymouse' automatically if it was not set
  			 * by the user already. */
  			if (!option_was_set((char_u *)"ttym"))
***************
*** 4566,4600 ****
  				may_adjust_color_count(256);
  			}
  
  #  ifdef MACOS
  			/* Mac Terminal.app sends 1;95;0 */
  			if (col == 95
  				&& STRNCMP(tp + extra - 2, "1;95;0c", 7) == 0)
! 			{
! 			    /* Terminal.app sets $TERM to "xterm-256colors",
! 			     * but it's not fully xterm compatible. */
! 			    is_terminal_app = TRUE;
! 			}
  #  endif
  
  			/* Only request the cursor style if t_SH and t_RS are
  			 * set. Not for Terminal.app, it can't handle t_RS, it
  			 * echoes the characters to the screen. */
  			if (rcs_status == STATUS_GET
! #  ifdef MACOS
! 				&& !is_terminal_app
! #  endif
  				&& *T_CSH != NUL
  				&& *T_CRS != NUL)
  			{
  			    LOG_TR("Sending cursor style request");
  			    out_str(T_CRS);
  			    rcs_status = STATUS_SENT;
! 			    out_flush();
  			}
  		    }
  # ifdef FEAT_EVAL
! 		    set_vim_var_string(VV_TERMRESPONSE, tp, i + 1);
  # endif
  # ifdef FEAT_AUTOCMD
  		    apply_autocmds(EVENT_TERMRESPONSE,
--- 4553,4605 ----
  				may_adjust_color_count(256);
  			}
  
+ 			/* Detect terminals that set $TERM to something like
+ 			 * "xterm-256colors"  but are not fully xterm
+ 			 * compatible. */
  #  ifdef MACOS
  			/* Mac Terminal.app sends 1;95;0 */
  			if (col == 95
  				&& STRNCMP(tp + extra - 2, "1;95;0c", 7) == 0)
! 			    is_not_xterm = TRUE;
  #  endif
+ 			/* Gnome Terminal.app sends 1;4402;0, assuming any
+ 			 * version number over 4000 is not an xterm. */
+ 			if (col >= 4000)
+ 			    is_not_xterm = TRUE;
  
  			/* Only request the cursor style if t_SH and t_RS are
  			 * set. Not for Terminal.app, it can't handle t_RS, it
  			 * echoes the characters to the screen. */
  			if (rcs_status == STATUS_GET
! 				&& !is_not_xterm
  				&& *T_CSH != NUL
  				&& *T_CRS != NUL)
  			{
  			    LOG_TR("Sending cursor style request");
  			    out_str(T_CRS);
  			    rcs_status = STATUS_SENT;
! 			    need_flush = TRUE;
  			}
+ 
+ 			/* Only request the cursor blink mode if t_RC set. Not
+ 			 * for Gnome terminal, it can't handle t_RC, it
+ 			 * echoes the characters to the screen. */
+ 			if (rbm_status == STATUS_GET
+ 				&& !is_not_xterm
+ 				&& *T_CRC != NUL)
+ 			{
+ 			    LOG_TR("Sending cursor blink mode request");
+ 			    out_str(T_CRC);
+ 			    rbm_status = STATUS_SENT;
+ 			    need_flush = TRUE;
+ 			}
+ 
+ 			if (need_flush)
+ 			    out_flush();
  		    }
+ 		    slen = i + 1;
  # ifdef FEAT_EVAL
! 		    set_vim_var_string(VV_TERMRESPONSE, tp, slen);
  # endif
  # ifdef FEAT_AUTOCMD
  		    apply_autocmds(EVENT_TERMRESPONSE,
***************
*** 4602,4608 ****
  # endif
  		    key_name[0] = (int)KS_EXTRA;
  		    key_name[1] = (int)KE_IGNORE;
- 		    slen = i + 1;
  		}
  
  		/* Check blinking cursor from xterm:
--- 4607,4612 ----
***************
*** 4626,4631 ****
--- 4630,4638 ----
  		    key_name[0] = (int)KS_EXTRA;
  		    key_name[1] = (int)KE_IGNORE;
  		    slen = i + 1;
+ # ifdef FEAT_EVAL
+ 		    set_vim_var_string(VV_TERMBLINKRESP, tp, slen);
+ # endif
  		}
  
  		/*
***************
*** 4714,4719 ****
--- 4721,4729 ----
  			    /* Sometimes the 0x07 is followed by 0x18, unclear
  			     * when this happens. */
  			    ++slen;
+ # ifdef FEAT_EVAL
+ 			set_vim_var_string(VV_TERMRGBRESP, tp, slen);
+ # endif
  			break;
  		    }
  		if (i == len)
***************
*** 4788,4793 ****
--- 4798,4806 ----
  			key_name[0] = (int)KS_EXTRA;
  			key_name[1] = (int)KE_IGNORE;
  			slen = i + 1 + (tp[i] == ESC);
+ # ifdef FEAT_EVAL
+ 			set_vim_var_string(VV_TERMSTYLERESP, tp, slen);
+ # endif
  		    }
  		}
  
*** ../vim-8.0.1015/src/eval.c	2017-08-05 16:33:52.526755704 +0200
--- src/eval.c	2017-08-30 14:01:35.564406136 +0200
***************
*** 187,192 ****
--- 187,196 ----
      {VV_NAME("t_none",		 VAR_NUMBER), VV_RO},
      {VV_NAME("t_job",		 VAR_NUMBER), VV_RO},
      {VV_NAME("t_channel",	 VAR_NUMBER), VV_RO},
+     {VV_NAME("termrgbresp",	 VAR_STRING), VV_RO},
+     {VV_NAME("termu7resp",	 VAR_STRING), VV_RO},
+     {VV_NAME("termstyleresp",	VAR_STRING), VV_RO},
+     {VV_NAME("termblinkresp",	VAR_STRING), VV_RO},
  };
  
  /* shorthand */
*** ../vim-8.0.1015/src/vim.h	2017-08-14 22:35:04.672303073 +0200
--- src/vim.h	2017-08-30 14:01:12.084565984 +0200
***************
*** 2012,2018 ****
  #define VV_TYPE_NONE	78
  #define VV_TYPE_JOB	79
  #define VV_TYPE_CHANNEL	80
! #define VV_LEN		81	/* number of v: vars */
  
  /* used for v_number in VAR_SPECIAL */
  #define VVAL_FALSE	0L
--- 2012,2022 ----
  #define VV_TYPE_NONE	78
  #define VV_TYPE_JOB	79
  #define VV_TYPE_CHANNEL	80
! #define VV_TERMRGBRESP	81
! #define VV_TERMU7RESP	82
! #define VV_TERMSTYLERESP 83
! #define VV_TERMBLINKRESP 84
! #define VV_LEN		85	/* number of v: vars */
  
  /* used for v_number in VAR_SPECIAL */
  #define VVAL_FALSE	0L
*** ../vim-8.0.1015/runtime/doc/eval.txt	2017-08-27 15:23:37.512977267 +0200
--- runtime/doc/eval.txt	2017-08-30 14:17:57.945751933 +0200
***************
*** 1902,1907 ****
--- 1902,1927 ----
  		always 95 or bigger).  Pc is always zero.
  		{only when compiled with |+termresponse| feature}
  
+ 						*v:termblinkresp*
+ v:termblinkresp	The escape sequence returned by the terminal for the |t_RC|
+ 		termcap entry.  This is used to find out whether the terminal
+ 		cursor is blinking. This is used by |term_getcursor()|.
+ 
+ 						*v:termstyleresp*
+ v:termstyleresp	The escape sequence returned by the terminal for the |t_RS|
+ 		termcap entry.  This is used to find out what the shape of the
+ 		cursor is.  This is used by |term_getcursor()|.
+ 
+ 						*v:termrgbresp*
+ v:termrgbresp	The escape sequence returned by the terminal for the |t_RB|
+ 		termcap entry.  This is used to find out what the terminal
+ 		background color is, see 'background'.
+ 
+ 						*v:termu7resp*
+ v:termu7resp	The escape sequence returned by the terminal for the |t_u7|
+ 		termcap entry.  This is used to find out what the terminal
+ 		does with ambiguous width characters, see 'ambiwidth'.
+ 
  					*v:testing* *testing-variable*
  v:testing	Must be set before using `test_garbagecollect_now()`.
  		Also, when set certain error messages won't be shown for 2
*** ../vim-8.0.1015/src/version.c	2017-08-30 13:31:45.968512934 +0200
--- src/version.c	2017-08-30 14:50:49.264334406 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     1016,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
32. You don't know what sex three of your closest friends are, because they
    have neutral nicknames and you never bothered to ask.
  normal GA<CR><Esc>

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
