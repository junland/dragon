To: vim_dev@googlegroups.com
Subject: Patch 8.0.1040
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1040
Problem:    Cannot use another error format in getqflist().
Solution:   Add the "efm" argument to getqflist(). (Yegappan Lakshmanan)
Files:      runtime/doc/eval.txt, src/quickfix.c,
            src/testdir/test_quickfix.vim


*** ../vim-8.0.1039/runtime/doc/eval.txt	2017-09-02 19:45:00.045425435 +0200
--- runtime/doc/eval.txt	2017-09-02 19:48:14.360135746 +0200
***************
*** 4635,4650 ****
  		returns only the items listed in {what} as a dictionary. The
  		following string items are supported in {what}:
  			context	get the context stored with |setqflist()|
  			id	get information for the quickfix list with
  				|quickfix-ID|; zero means the id for the
! 				current list or the list specifed by 'nr'
  			items	quickfix list entries
  			lines	use 'errorformat' to extract items from a list
  				of lines and return the resulting entries.
  				Only a |List| type is accepted.  The current
  				quickfix list is not modified.
  			nr	get information for this quickfix list; zero
! 				means the current quickfix list and '$' means
  				the last quickfix list
  			title	get the list title
  			winid	get the |window-ID| (if opened)
--- 4635,4653 ----
  		returns only the items listed in {what} as a dictionary. The
  		following string items are supported in {what}:
  			context	get the context stored with |setqflist()|
+ 			efm	errorformat to use when parsing "lines". If
+ 				not present, then the 'erroformat' option
+ 				value is used.
  			id	get information for the quickfix list with
  				|quickfix-ID|; zero means the id for the
! 				current list or the list specifed by "nr"
  			items	quickfix list entries
  			lines	use 'errorformat' to extract items from a list
  				of lines and return the resulting entries.
  				Only a |List| type is accepted.  The current
  				quickfix list is not modified.
  			nr	get information for this quickfix list; zero
! 				means the current quickfix list and "$" means
  				the last quickfix list
  			title	get the list title
  			winid	get the |window-ID| (if opened)
***************
*** 7084,7096 ****
  		is created. The new quickfix list is added after the current
  		quickfix list in the stack and all the following lists are
  		freed. To add a new quickfix list at the end of the stack,
! 		set "nr" in {what} to '$'.
  
  		If the optional {what} dictionary argument is supplied, then
  		only the items listed in {what} are set. The first {list}
  		argument is ignored.  The following items can be specified in
  		{what}:
  		    context	any Vim type can be stored as a context
  		    id		quickfix list identifier |quickfix-ID|
  		    items	list of quickfix entries. Same as the {list}
  				argument.
--- 7090,7105 ----
  		is created. The new quickfix list is added after the current
  		quickfix list in the stack and all the following lists are
  		freed. To add a new quickfix list at the end of the stack,
! 		set "nr" in {what} to "$".
  
  		If the optional {what} dictionary argument is supplied, then
  		only the items listed in {what} are set. The first {list}
  		argument is ignored.  The following items can be specified in
  		{what}:
  		    context	any Vim type can be stored as a context
+ 		    efm		errorformat to use when parsing text from
+ 				"lines". If this is not present, then the
+ 				'errorformat' option value is used.
  		    id		quickfix list identifier |quickfix-ID|
  		    items	list of quickfix entries. Same as the {list}
  				argument.
***************
*** 7098,7104 ****
  				add the resulting entries to the quickfix list
  				{nr} or {id}.  Only a |List| value is supported.
  		    nr		list number in the quickfix stack; zero
! 				means the current quickfix list and '$' means
  				the last quickfix list
  		    title	quickfix list title text
  		Unsupported keys in {what} are ignored.
--- 7107,7113 ----
  				add the resulting entries to the quickfix list
  				{nr} or {id}.  Only a |List| value is supported.
  		    nr		list number in the quickfix stack; zero
! 				means the current quickfix list and "$" means
  				the last quickfix list
  		    title	quickfix list title text
  		Unsupported keys in {what} are ignored.
***************
*** 7106,7112 ****
  		is modified. When creating a new quickfix list, "nr" can be
  		set to a value one greater than the quickfix stack size.
  		When modifying a quickfix list, to guarantee that the correct
! 		list is modified, 'id' should be used instead of 'nr' to
  		specify the list.
  
  		Examples: >
--- 7115,7121 ----
  		is modified. When creating a new quickfix list, "nr" can be
  		set to a value one greater than the quickfix stack size.
  		When modifying a quickfix list, to guarantee that the correct
! 		list is modified, "id" should be used instead of "nr" to
  		specify the list.
  
  		Examples: >
*** ../vim-8.0.1039/src/quickfix.c	2017-09-01 18:33:57.748660771 +0200
--- src/quickfix.c	2017-09-02 19:48:14.360135746 +0200
***************
*** 4643,4658 ****
   * Parse text from 'di' and return the quickfix list items
   */
      static int
! qf_get_list_from_lines(dictitem_T *di, dict_T *retdict)
  {
      int		status = FAIL;
      qf_info_T	*qi;
  
      /* Only a List value is supported */
      if (di->di_tv.v_type == VAR_LIST && di->di_tv.vval.v_list != NULL)
      {
! 	list_T	*l = list_alloc();
  
  	if (l == NULL)
  	    return FAIL;
  
--- 4643,4671 ----
   * Parse text from 'di' and return the quickfix list items
   */
      static int
! qf_get_list_from_lines(dict_T *what, dictitem_T *di, dict_T *retdict)
  {
      int		status = FAIL;
      qf_info_T	*qi;
+     char_u	*errorformat = p_efm;
+     dictitem_T	*efm_di;
+     list_T	*l;
  
      /* Only a List value is supported */
      if (di->di_tv.v_type == VAR_LIST && di->di_tv.vval.v_list != NULL)
      {
! 	/* If errorformat is supplied then use it, otherwise use the 'efm'
! 	 * option setting
! 	 */
! 	if ((efm_di = dict_find(what, (char_u *)"efm", -1)) != NULL)
! 	{
! 	    if (efm_di->di_tv.v_type != VAR_STRING ||
! 		    efm_di->di_tv.vval.v_string == NULL)
! 		return FAIL;
! 	    errorformat = efm_di->di_tv.vval.v_string;
! 	}
  
+ 	l = list_alloc();
  	if (l == NULL)
  	    return FAIL;
  
***************
*** 4662,4668 ****
  	    vim_memset(qi, 0, (size_t)(sizeof(qf_info_T)));
  	    qi->qf_refcount++;
  
! 	    if (qf_init_ext(qi, 0, NULL, NULL, &di->di_tv, p_efm,
  			TRUE, (linenr_T)0, (linenr_T)0, NULL, NULL) > 0)
  	    {
  		(void)get_errorlist(qi, NULL, 0, l);
--- 4675,4681 ----
  	    vim_memset(qi, 0, (size_t)(sizeof(qf_info_T)));
  	    qi->qf_refcount++;
  
! 	    if (qf_init_ext(qi, 0, NULL, NULL, &di->di_tv, errorformat,
  			TRUE, (linenr_T)0, (linenr_T)0, NULL, NULL) > 0)
  	    {
  		(void)get_errorlist(qi, NULL, 0, l);
***************
*** 4692,4698 ****
      int		flags = QF_GETLIST_NONE;
  
      if ((di = dict_find(what, (char_u *)"lines", -1)) != NULL)
! 	return qf_get_list_from_lines(di, retdict);
  
      if (wp != NULL)
  	qi = GET_LOC_LIST(wp);
--- 4705,4711 ----
      int		flags = QF_GETLIST_NONE;
  
      if ((di = dict_find(what, (char_u *)"lines", -1)) != NULL)
! 	return qf_get_list_from_lines(what, di, retdict);
  
      if (wp != NULL)
  	qi = GET_LOC_LIST(wp);
***************
*** 4962,4967 ****
--- 4975,4981 ----
      int		retval = FAIL;
      int		qf_idx;
      int		newlist = FALSE;
+     char_u	*errorformat = p_efm;
  
      if (action == ' ' || qi->qf_curlist == qi->qf_listcount)
  	newlist = TRUE;
***************
*** 5039,5044 ****
--- 5053,5059 ----
  	    retval = OK;
  	}
      }
+ 
      if ((di = dict_find(what, (char_u *)"items", -1)) != NULL)
      {
  	if (di->di_tv.v_type == VAR_LIST)
***************
*** 5051,5056 ****
--- 5066,5078 ----
  	}
      }
  
+     if ((di = dict_find(what, (char_u *)"efm", -1)) != NULL)
+     {
+ 	if (di->di_tv.v_type != VAR_STRING || di->di_tv.vval.v_string == NULL)
+ 	    return FAIL;
+ 	errorformat = di->di_tv.vval.v_string;
+     }
+ 
      if ((di = dict_find(what, (char_u *)"lines", -1)) != NULL)
      {
  	/* Only a List value is supported */
***************
*** 5058,5064 ****
  	{
  	    if (action == 'r')
  		qf_free_items(qi, qf_idx);
! 	    if (qf_init_ext(qi, qf_idx, NULL, NULL, &di->di_tv, p_efm,
  			FALSE, (linenr_T)0, (linenr_T)0, NULL, NULL) > 0)
  		retval = OK;
  	}
--- 5080,5086 ----
  	{
  	    if (action == 'r')
  		qf_free_items(qi, qf_idx);
! 	    if (qf_init_ext(qi, qf_idx, NULL, NULL, &di->di_tv, errorformat,
  			FALSE, (linenr_T)0, (linenr_T)0, NULL, NULL) > 0)
  		retval = OK;
  	}
*** ../vim-8.0.1039/src/testdir/test_quickfix.vim	2017-09-01 18:33:57.752660744 +0200
--- src/testdir/test_quickfix.vim	2017-09-02 19:48:14.364135720 +0200
***************
*** 2321,2326 ****
--- 2321,2337 ----
    call g:Xsetlist([], 'a', {'nr' : 2, 'lines' : ["File2:25:Line25"]})
    call assert_equal('Line15', g:Xgetlist({'nr':1, 'items':1}).items[1].text)
    call assert_equal('Line25', g:Xgetlist({'nr':2, 'items':1}).items[1].text)
+ 
+   " Adding entries using a custom efm
+   set efm&
+   call g:Xsetlist([], ' ', {'efm' : '%f#%l#%m',
+ 				\ 'lines' : ["F1#10#L10", "F2#20#L20"]})
+   call assert_equal(20, g:Xgetlist({'items':1}).items[1].lnum)
+   call g:Xsetlist([], 'a', {'efm' : '%f#%l#%m', 'lines' : ["F3:30:L30"]})
+   call assert_equal('F3:30:L30', g:Xgetlist({'items':1}).items[2].text)
+   call assert_equal(20, g:Xgetlist({'items':1}).items[1].lnum)
+   call assert_equal(-1, g:Xsetlist([], 'a', {'efm' : [],
+ 				\ 'lines' : ['F1:10:L10']}))
  endfunc
  
  func Test_setexpr()
***************
*** 2537,2542 ****
--- 2548,2564 ----
    call assert_equal([], g:Xgetlist({'lines' : []}).items)
    call assert_equal([], g:Xgetlist({'lines' : [10, 20]}).items)
  
+   " Parse text using a custom efm
+   set efm&
+   let l = g:Xgetlist({'lines':['File3#30#Line30'], 'efm' : '%f#%l#%m'}).items
+   call assert_equal('Line30', l[0].text)
+   let l = g:Xgetlist({'lines':['File3:30:Line30'], 'efm' : '%f-%l-%m'}).items
+   call assert_equal('File3:30:Line30', l[0].text)
+   let l = g:Xgetlist({'lines':['File3:30:Line30'], 'efm' : [1,2]})
+   call assert_equal({}, l)
+   call assert_fails("call g:Xgetlist({'lines':['abc'], 'efm':'%2'})", 'E376:')
+   call assert_fails("call g:Xgetlist({'lines':['abc'], 'efm':''})", 'E378:')
+ 
    " Make sure that the quickfix stack is not modified
    call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)
  endfunc
*** ../vim-8.0.1039/src/version.c	2017-09-02 19:45:00.049425409 +0200
--- src/version.c	2017-09-02 19:48:52.047885559 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     1040,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
53. To find out what time it is, you send yourself an e-mail and check the
    "Date:" field.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
