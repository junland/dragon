To: vim_dev@googlegroups.com
Subject: Patch 8.0.1108
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1108
Problem:    Cannot specify mappings for the terminal window.
Solution:   Add the :tmap command and associated code.  (Jacob Askeland,
            closes #2073)
Files:      runtime/doc/map.txt, runtime/doc/terminal.txt, src/ex_cmdidxs.h,
            src/ex_cmds.h, src/ex_docmd.c, src/getchar.c, src/gui.c,
            src/terminal.c, src/testdir/test_terminal.vim, src/vim.h,
            src/proto/terminal.pro, src/main.c, src/evalfunc.c


*** ../vim-8.0.1107/runtime/doc/map.txt	2017-09-10 17:34:30.378823252 +0200
--- runtime/doc/map.txt	2017-09-14 19:17:45.919711882 +0200
***************
*** 55,60 ****
--- 55,61 ----
  :im[ap]	{lhs} {rhs}		|mapmode-i|		*:im* *:imap*
  :lm[ap]	{lhs} {rhs}		|mapmode-l|		*:lm* *:lmap*
  :cm[ap]	{lhs} {rhs}		|mapmode-c|		*:cm* *:cmap*
+ :tm[ap]	{lhs} {rhs}		|mapmode-t|		*:tm* *:tmap*
  			Map the key sequence {lhs} to {rhs} for the modes
  			where the map command applies.  The result, including
  			{rhs}, is then further scanned for mappings.  This
***************
*** 71,76 ****
--- 72,78 ----
  :ino[remap] {lhs} {rhs}		|mapmode-i|	*:ino* *:inoremap*
  :ln[oremap] {lhs} {rhs}		|mapmode-l|	*:ln*  *:lnoremap*
  :cno[remap] {lhs} {rhs}		|mapmode-c|	*:cno* *:cnoremap*
+ :tno[remap] {lhs} {rhs}		|mapmode-t|	*:tno* *:tnoremap*
  			Map the key sequence {lhs} to {rhs} for the modes
  			where the map command applies.  Disallow mapping of
  			{rhs}, to avoid nested and recursive mappings.  Often
***************
*** 87,92 ****
--- 89,95 ----
  :iu[nmap] {lhs}			|mapmode-i|		*:iu*   *:iunmap*
  :lu[nmap] {lhs}			|mapmode-l|		*:lu*   *:lunmap*
  :cu[nmap] {lhs}			|mapmode-c|		*:cu*   *:cunmap*
+ :tu[nmap] {lhs}			|mapmode-t|		*:tu*   *:tunmap*
  			Remove the mapping of {lhs} for the modes where the
  			map command applies.  The mapping may remain defined
  			for other modes where it applies.
***************
*** 105,110 ****
--- 108,114 ----
  :imapc[lear]			|mapmode-i|		*:imapc*  *:imapclear*
  :lmapc[lear]			|mapmode-l|		*:lmapc*  *:lmapclear*
  :cmapc[lear]			|mapmode-c|		*:cmapc*  *:cmapclear*
+ :tmapc[lear]			|mapmode-t|		*:tmapc*  *:tmapclear*
  			Remove ALL mappings for the modes where the map
  			command applies.  {not in Vi}
  			Use the <buffer> argument to remove buffer-local
***************
*** 121,126 ****
--- 125,131 ----
  :im[ap]				|mapmode-i|
  :lm[ap]				|mapmode-l|
  :cm[ap]				|mapmode-c|
+ :tm[ap]				|mapmode-t|
  			List all key mappings for the modes where the map
  			command applies.  Note that ":map" and ":map!" are
  			used most often, because they include the other modes.
***************
*** 135,140 ****
--- 140,146 ----
  :im[ap] {lhs}			|mapmode-i|		*:imap_l*
  :lm[ap] {lhs}			|mapmode-l|		*:lmap_l*
  :cm[ap] {lhs}			|mapmode-c|		*:cmap_l*
+ :tm[ap] {lhs}			|mapmode-t|		*:tmap_l*
  			List the key mappings for the key sequences starting
  			with {lhs} in the modes where the map command applies.
  			{not in Vi}
***************
*** 318,323 ****
--- 324,330 ----
  :imap  :inoremap :iunmap    Insert
  :lmap  :lnoremap :lunmap    Insert, Command-line, Lang-Arg
  :cmap  :cnoremap :cunmap    Command-line
+ :tmap  :tnoremap :tunmap    Terminal-Job
  
  
      COMMANDS				      MODES ~
***************
*** 358,363 ****
--- 365,374 ----
  several modes.  In Vim you can use the ":nmap", ":vmap", ":omap", ":cmap" and
  ":imap" commands to enter mappings for each mode separately.
  
+ 							*mapmode-t*
+ The terminal mappings are used in a terminal window, when typing keys for the
+ job running in the terminal.  See |terminal-typing|.
+ 
  							*omap-info*
  Operator-pending mappings can be used to define a movement command that can be
  used with any operator.  Simple example: ":omap { w" makes "y{" work like "yw"
***************
*** 418,423 ****
--- 429,435 ----
  	i	Insert
  	l	":lmap" mappings for Insert, Command-line and Lang-Arg
  	c	Command-line
+         t       Terminal-Job
  
  Just before the {rhs} a special character can appear:
  	*	indicates that it is not remappable
*** ../vim-8.0.1107/runtime/doc/terminal.txt	2017-09-14 16:10:33.790060072 +0200
--- runtime/doc/terminal.txt	2017-09-14 19:19:45.027009873 +0200
***************
*** 1,4 ****
! *terminal.txt*	For Vim version 8.0.  Last change: 2017 Sep 13
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
--- 1,4 ----
! *terminal.txt*	For Vim version 8.0.  Last change: 2017 Sep 14
  
  
  		  VIM REFERENCE MANUAL	  by Bram Moolenaar
***************
*** 38,44 ****
  
  
  Typing ~
! 
  When the keyboard focus is in the terminal window, typed keys will be sent to
  the job.  This uses a pty when possible.  You can click outside of the
  terminal window to move keyboard focus elsewhere.
--- 38,44 ----
  
  
  Typing ~
! 							*terminal-typing*
  When the keyboard focus is in the terminal window, typed keys will be sent to
  the job.  This uses a pty when possible.  You can click outside of the
  terminal window to move keyboard focus elsewhere.
***************
*** 79,84 ****
--- 79,88 ----
  would end it.  Other commands may ignore the SIGINT or handle the CTRL-C
  themselves (like Vim does).
  
+ To change the keys you type use terminal mode mappings, see |:tmap|.
+ These are defined like any mapping, but apply only when typing keys that are
+ sent to the job running in the terminal.
+ 
  
  Size and color ~
  
***************
*** 221,226 ****
--- 225,234 ----
  Use CTRL-W N (or 'termkey' N) to switch to Terminal-Normal mode.  Now the
  contents of the terminal window is under control of Vim, the job output is
  suspended.  CTRL-\ CTRL-N does the same.
+ 
+ Terminal-Job mode is where |tmap| mappings are applied. Keys sent by
+ |term_sendkeys()| are not subject to tmap, but keys from |feedkeys()| are.
+ 
  							*E946*
  In Terminal-Normal mode you can move the cursor around with the usual Vim
  commands, Visually mark text, yank text, etc.  But you cannot change the
***************
*** 301,307 ****
  
  Functions ~
  
! term_sendkeys()		send keystrokes to a terminal
  term_wait()		wait for screen to be updated
  term_scrape()		inspect terminal screen
  
--- 309,315 ----
  
  Functions ~
  
! term_sendkeys()		send keystrokes to a terminal (not subject to tmap)
  term_wait()		wait for screen to be updated
  term_scrape()		inspect terminal screen
  
*** ../vim-8.0.1107/src/ex_cmdidxs.h	2017-07-07 11:53:29.507876589 +0200
--- src/ex_cmdidxs.h	2017-09-14 19:13:05.233366870 +0200
***************
*** 25,36 ****
    /* r */ 351,
    /* s */ 370,
    /* t */ 437,
!   /* u */ 473,
!   /* v */ 484,
!   /* w */ 502,
!   /* x */ 517,
!   /* y */ 526,
!   /* z */ 527
  };
  
  /*
--- 25,36 ----
    /* r */ 351,
    /* s */ 370,
    /* t */ 437,
!   /* u */ 477,
!   /* v */ 488,
!   /* w */ 506,
!   /* x */ 521,
!   /* y */ 530,
!   /* z */ 531
  };
  
  /*
***************
*** 60,66 ****
    /* q */ {  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    /* r */ {  0,  0,  0,  0,  0,  0,  0,  0, 11,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 13, 18,  0,  0,  0,  0 },
    /* s */ {  2,  6, 15,  0, 18, 22,  0, 24, 25,  0,  0, 28, 30, 34, 38, 40,  0, 48,  0, 49,  0, 61, 62,  0, 63,  0 },
!   /* t */ {  2,  0, 19,  0, 22, 24,  0, 25,  0, 26,  0, 27, 28, 29, 30, 31,  0, 32, 34,  0, 35,  0,  0,  0,  0,  0 },
    /* u */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    /* v */ {  0,  0,  0,  0,  1,  0,  0,  0,  4,  0,  0,  0,  9, 12,  0,  0,  0,  0, 15,  0, 16,  0,  0,  0,  0,  0 },
    /* w */ {  2,  0,  0,  0,  0,  0,  0,  3,  4,  0,  0,  0,  0,  8,  0,  9, 10,  0, 12,  0, 13, 14,  0,  0,  0,  0 },
--- 60,66 ----
    /* q */ {  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    /* r */ {  0,  0,  0,  0,  0,  0,  0,  0, 11,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 13, 18,  0,  0,  0,  0 },
    /* s */ {  2,  6, 15,  0, 18, 22,  0, 24, 25,  0,  0, 28, 30, 34, 38, 40,  0, 48,  0, 49,  0, 61, 62,  0, 63,  0 },
!   /* t */ {  2,  0, 19,  0, 22, 24,  0, 25,  0, 26,  0, 27, 28, 31, 33, 34,  0, 35, 37,  0, 38,  0,  0,  0,  0,  0 },
    /* u */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },
    /* v */ {  0,  0,  0,  0,  1,  0,  0,  0,  4,  0,  0,  0,  9, 12,  0,  0,  0,  0, 15,  0, 16,  0,  0,  0,  0,  0 },
    /* w */ {  2,  0,  0,  0,  0,  0,  0,  3,  4,  0,  0,  0,  0,  8,  0,  9, 10,  0, 12,  0, 13, 14,  0,  0,  0,  0 },
***************
*** 69,72 ****
    /* z */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }
  };
  
! static const int command_count = 540;
--- 69,72 ----
    /* z */ {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }
  };
  
! static const int command_count = 544;
*** ../vim-8.0.1107/src/ex_cmds.h	2017-08-20 18:09:09.763276757 +0200
--- src/ex_cmds.h	2017-09-14 19:13:05.237366846 +0200
***************
*** 1484,1490 ****
  			NEEDARG|EXTRA|TRLBAR|NOTRLCOM|CMDWIN,
  			ADDR_LINES),
  EX(CMD_terminal,	"terminal",	ex_terminal,
! 			RANGE|BANG|FILES|TRLBAR|CMDWIN,
  			ADDR_LINES),
  EX(CMD_tfirst,		"tfirst",	ex_tag,
  			RANGE|NOTADR|BANG|TRLBAR|ZEROR,
--- 1484,1490 ----
  			NEEDARG|EXTRA|TRLBAR|NOTRLCOM|CMDWIN,
  			ADDR_LINES),
  EX(CMD_terminal,	"terminal",	ex_terminal,
! 			RANGE|BANG|FILES|CMDWIN,
  			ADDR_LINES),
  EX(CMD_tfirst,		"tfirst",	ex_tag,
  			RANGE|NOTADR|BANG|TRLBAR|ZEROR,
***************
*** 1498,1509 ****
--- 1498,1518 ----
  EX(CMD_tlast,		"tlast",	ex_tag,
  			BANG|TRLBAR,
  			ADDR_LINES),
+ EX(CMD_tmap,		"tmap",		ex_map,
+ 			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN,
+ 			ADDR_LINES),
+ EX(CMD_tmapclear,	"tmapclear",	ex_mapclear,
+ 			EXTRA|TRLBAR|CMDWIN,
+ 			ADDR_LINES),
  EX(CMD_tmenu,		"tmenu",	ex_menu,
  			RANGE|NOTADR|ZEROR|EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN,
  			ADDR_LINES),
  EX(CMD_tnext,		"tnext",	ex_tag,
  			RANGE|NOTADR|BANG|TRLBAR|ZEROR,
  			ADDR_LINES),
+ EX(CMD_tnoremap,	"tnoremap",	ex_map,
+ 			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN,
+ 			ADDR_LINES),
  EX(CMD_topleft,		"topleft",	ex_wrongmodifier,
  			NEEDARG|EXTRA|NOTRLCOM,
  			ADDR_LINES),
***************
*** 1519,1524 ****
--- 1528,1536 ----
  EX(CMD_tselect,		"tselect",	ex_tag,
  			BANG|TRLBAR|WORD1,
  			ADDR_LINES),
+ EX(CMD_tunmap,		"tunmap",	ex_unmap,
+ 			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN,
+ 			ADDR_LINES),
  EX(CMD_tunmenu,		"tunmenu",	ex_menu,
  			EXTRA|TRLBAR|NOTRLCOM|USECTRLV|CMDWIN,
  			ADDR_LINES),
*** ../vim-8.0.1107/src/ex_docmd.c	2017-09-10 18:16:16.503727710 +0200
--- src/ex_docmd.c	2017-09-14 19:13:05.237366846 +0200
***************
*** 4209,4214 ****
--- 4209,4215 ----
  	case CMD_cmap:	    case CMD_cnoremap:
  	case CMD_lmap:	    case CMD_lnoremap:
  	case CMD_smap:	    case CMD_snoremap:
+ 	case CMD_tmap:	    case CMD_tnoremap:
  	case CMD_xmap:	    case CMD_xnoremap:
  	    return set_context_in_map_cmd(xp, cmd, arg, forceit,
  						     FALSE, FALSE, ea.cmdidx);
***************
*** 4220,4225 ****
--- 4221,4227 ----
  	case CMD_cunmap:
  	case CMD_lunmap:
  	case CMD_sunmap:
+ 	case CMD_tunmap:
  	case CMD_xunmap:
  	    return set_context_in_map_cmd(xp, cmd, arg, forceit,
  						      FALSE, TRUE, ea.cmdidx);
***************
*** 4231,4236 ****
--- 4233,4239 ----
  	case CMD_cmapclear:
  	case CMD_lmapclear:
  	case CMD_smapclear:
+ 	case CMD_tmapclear:
  	case CMD_xmapclear:
  	    xp->xp_context = EXPAND_MAPCLEAR;
  	    xp->xp_pattern = arg;
*** ../vim-8.0.1107/src/getchar.c	2017-09-05 22:20:42.620382894 +0200
--- src/getchar.c	2017-09-14 19:13:05.241366823 +0200
***************
*** 59,65 ****
   * Returns a value between 0 and 255, index in maphash.
   * Put Normal/Visual mode mappings mostly separately from Insert/Cmdline mode.
   */
! #define MAP_HASH(mode, c1) (((mode) & (NORMAL + VISUAL + SELECTMODE + OP_PENDING)) ? (c1) : ((c1) ^ 0x80))
  
  /*
   * Each mapping is put in one of the 256 hash lists, to speed up finding it.
--- 59,65 ----
   * Returns a value between 0 and 255, index in maphash.
   * Put Normal/Visual mode mappings mostly separately from Insert/Cmdline mode.
   */
! #define MAP_HASH(mode, c1) (((mode) & (NORMAL + VISUAL + SELECTMODE + OP_PENDING + TERMINAL)) ? (c1) : ((c1) ^ 0x80))
  
  /*
   * Each mapping is put in one of the 256 hash lists, to speed up finding it.
***************
*** 3188,3193 ****
--- 3188,3194 ----
   * for :xmap  mode is VISUAL
   * for :smap  mode is SELECTMODE
   * for :omap  mode is OP_PENDING
+  * for :tmap  mode is TERMINAL
   *
   * for :abbr  mode is INSERT + CMDLINE
   * for :iabbr mode is INSERT
***************
*** 3832,3837 ****
--- 3833,3840 ----
  	mode = SELECTMODE;			/* :smap */
      else if (modec == 'o')
  	mode = OP_PENDING;			/* :omap */
+     else if (modec == 't')
+ 	mode = TERMINAL;			/* :tmap */
      else
      {
  	--p;
***************
*** 4892,4897 ****
--- 4895,4903 ----
  		    case LANGMAP:
  			c1 = 'l';
  			break;
+ 		    case TERMINAL:
+ 			c1 = 't';
+ 			break;
  		    default:
  			IEMSG(_("E228: makemap: Illegal mode"));
  			return FAIL;
*** ../vim-8.0.1107/src/gui.c	2017-09-02 18:33:52.445554521 +0200
--- src/gui.c	2017-09-14 19:50:05.704264496 +0200
***************
*** 1101,1107 ****
  	 * When in a terminal window use the shape/color specified there.
  	 */
  #ifdef FEAT_TERMINAL
! 	if (use_terminal_cursor())
  	    shape = term_get_cursor_shape(&shape_fg, &shape_bg);
  	else
  #endif
--- 1101,1107 ----
  	 * When in a terminal window use the shape/color specified there.
  	 */
  #ifdef FEAT_TERMINAL
! 	if (terminal_is_active())
  	    shape = term_get_cursor_shape(&shape_fg, &shape_bg);
  	else
  #endif
*** ../vim-8.0.1107/src/terminal.c	2017-09-14 15:55:09.039518495 +0200
--- src/terminal.c	2017-09-14 20:02:57.527647152 +0200
***************
*** 38,47 ****
   * in tl_scrollback are no longer used.
   *
   * TODO:
!  * - patch to add tmap, jakalope (Jacob Askeland) #2073
   * - Redirecting output does not work on MS-Windows, Test_terminal_redir_file()
   *   is disabled.
-  * - test_terminal_no_cmd hangs (Christian)
   * - implement term_setsize()
   * - add test for giving error for invalid 'termsize' value.
   * - support minimal size when 'termsize' is "rows*cols".
--- 38,46 ----
   * in tl_scrollback are no longer used.
   *
   * TODO:
!  * - test_terminal_no_cmd hangs (Christian)
   * - Redirecting output does not work on MS-Windows, Test_terminal_redir_file()
   *   is disabled.
   * - implement term_setsize()
   * - add test for giving error for invalid 'termsize' value.
   * - support minimal size when 'termsize' is "rows*cols".
***************
*** 56,62 ****
   *   mouse in the Terminal window for copy/paste.
   * - when 'encoding' is not utf-8, or the job is using another encoding, setup
   *   conversions.
!  * - In the GUI use a terminal emulator for :!cmd.
   * - Copy text in the vterm to the Vim buffer once in a while, so that
   *   completion works.
   * - add an optional limit for the scrollback size.  When reaching it remove
--- 55,63 ----
   *   mouse in the Terminal window for copy/paste.
   * - when 'encoding' is not utf-8, or the job is using another encoding, setup
   *   conversions.
!  * - In the GUI use a terminal emulator for :!cmd.  Make the height the same as
!  *   the window and position it higher up when it gets filled, so it looks like
!  *   the text scrolls up.
   * - Copy text in the vterm to the Vim buffer once in a while, so that
   *   completion works.
   * - add an optional limit for the scrollback size.  When reaching it remove
***************
*** 1201,1223 ****
   * Get a key from the user without mapping.
   * Note: while waiting a terminal may be closed and freed if the channel is
   * closed and ++close was used.
!  * TODO: use terminal mode mappings.
   */
      static int
  term_vgetc()
  {
      int c;
  
!     ++no_mapping;
!     ++allow_keys;
      got_int = FALSE;
  #ifdef WIN3264
      ctrl_break_was_pressed = FALSE;
  #endif
      c = vgetc();
      got_int = FALSE;
!     --no_mapping;
!     --allow_keys;
      return c;
  }
  
--- 1202,1223 ----
   * Get a key from the user without mapping.
   * Note: while waiting a terminal may be closed and freed if the channel is
   * closed and ++close was used.
!  * Uses terminal mode mappings.
   */
      static int
  term_vgetc()
  {
      int c;
+     int save_State = State;
  
!     State = TERMINAL;
      got_int = FALSE;
  #ifdef WIN3264
      ctrl_break_was_pressed = FALSE;
  #endif
      c = vgetc();
      got_int = FALSE;
!     State = save_State;
      return c;
  }
  
***************
*** 1406,1412 ****
   * Return TRUE when the cursor of the terminal should be displayed.
   */
      int
! use_terminal_cursor()
  {
      return in_terminal_loop != NULL;
  }
--- 1406,1412 ----
   * Return TRUE when the cursor of the terminal should be displayed.
   */
      int
! terminal_is_active()
  {
      return in_terminal_loop != NULL;
  }
***************
*** 1496,1508 ****
  
  /*
   * Wait for input and send it to the job.
   * Return when the start of a CTRL-W command is typed or anything else that
   * should be handled as a Normal mode command.
   * Returns OK if a typed character is to be handled in Normal mode, FAIL if
   * the terminal was closed.
   */
      int
! terminal_loop(void)
  {
      int		c;
      int		termkey = 0;
--- 1496,1510 ----
  
  /*
   * Wait for input and send it to the job.
+  * When "blocking" is TRUE wait for a character to be typed.  Otherwise return
+  * when there is no more typahead.
   * Return when the start of a CTRL-W command is typed or anything else that
   * should be handled as a Normal mode command.
   * Returns OK if a typed character is to be handled in Normal mode, FAIL if
   * the terminal was closed.
   */
      int
! terminal_loop(int blocking)
  {
      int		c;
      int		termkey = 0;
***************
*** 1539,1545 ****
      }
  #endif
  
!     for (;;)
      {
  	/* TODO: skip screen update when handling a sequence of keys. */
  	/* Repeat redrawing in case a message is received while redrawing. */
--- 1541,1547 ----
      }
  #endif
  
!     while (blocking || vpeekc() != NUL)
      {
  	/* TODO: skip screen update when handling a sequence of keys. */
  	/* Repeat redrawing in case a message is received while redrawing. */
***************
*** 1561,1567 ****
  	if (ctrl_break_was_pressed)
  	    mch_signal_job(curbuf->b_term->tl_job, (char_u *)"kill");
  #endif
! 
  	if (c == (termkey == 0 ? Ctrl_W : termkey) || c == Ctrl_BSL)
  	{
  	    int	    prev_c = c;
--- 1563,1569 ----
  	if (ctrl_break_was_pressed)
  	    mch_signal_job(curbuf->b_term->tl_job, (char_u *)"kill");
  #endif
! 	/* Was either CTRL-W (termkey) or CTRL-\ pressed? */
  	if (c == (termkey == 0 ? Ctrl_W : termkey) || c == Ctrl_BSL)
  	{
  	    int	    prev_c = c;
*** ../vim-8.0.1107/src/testdir/test_terminal.vim	2017-09-11 20:45:19.791234493 +0200
--- src/testdir/test_terminal.vim	2017-09-14 20:29:48.370065315 +0200
***************
*** 620,622 ****
--- 620,659 ----
      call delete('Xfile')
    endif
  endfunc
+ 
+ func TerminalTmap(remap)
+   let buf = Run_shell_in_terminal({})
+   call assert_equal('t', mode())
+ 
+   if a:remap
+     tmap 123 456
+   else
+     tnoremap 123 456
+   endif
+   tmap 456 abcde
+   call assert_equal('456', maparg('123', 't'))
+   call assert_equal('abcde', maparg('456', 't'))
+   call feedkeys("123", 'tx')
+   call term_wait(buf)
+   let lnum = term_getcursor(buf)[0]
+   if a:remap
+     call assert_match('abcde', term_getline(buf, lnum))
+   else
+     call assert_match('456', term_getline(buf, lnum))
+   endif
+ 
+   call term_sendkeys(buf, "\r")
+   call Stop_shell_in_terminal(buf)
+   call term_wait(buf)
+ 
+   tunmap 123
+   tunmap 456
+   call assert_equal('', maparg('123', 't'))
+   close
+   unlet g:job
+ endfunc
+ 
+ func Test_terminal_tmap()
+   call TerminalTmap(1)
+   call TerminalTmap(0)
+ endfunc
*** ../vim-8.0.1107/src/vim.h	2017-09-02 20:40:31.895328987 +0200
--- src/vim.h	2017-09-14 19:13:05.245366799 +0200
***************
*** 716,724 ****
  #define SHOWMATCH	(0x700 + INSERT) /* show matching paren */
  #define CONFIRM		0x800	/* ":confirm" prompt */
  #define SELECTMODE	0x1000	/* Select mode, only for mappings */
  
! #define MAP_ALL_MODES	(0x3f | SELECTMODE)	/* all mode bits used for
! 						 * mapping */
  
  /* directions */
  #define FORWARD			1
--- 716,725 ----
  #define SHOWMATCH	(0x700 + INSERT) /* show matching paren */
  #define CONFIRM		0x800	/* ":confirm" prompt */
  #define SELECTMODE	0x1000	/* Select mode, only for mappings */
+ #define TERMINAL        0x2000  /* Terminal mode */
  
! /* all mode bits used for mapping */
! #define MAP_ALL_MODES	(0x3f | SELECTMODE | TERMINAL)
  
  /* directions */
  #define FORWARD			1
*** ../vim-8.0.1107/src/proto/terminal.pro	2017-09-08 20:46:55.902059559 +0200
--- src/proto/terminal.pro	2017-09-14 20:03:03.127613721 +0200
***************
*** 7,16 ****
  int term_in_normal_mode(void);
  void term_enter_job_mode(void);
  int send_keys_to_term(term_T *term, int c, int typed);
! int use_terminal_cursor(void);
  cursorentry_T *term_get_cursor_shape(guicolor_T *fg, guicolor_T *bg);
  int term_use_loop(void);
! int terminal_loop(void);
  void term_job_ended(job_T *job);
  void term_channel_closed(channel_T *ch);
  int term_update_window(win_T *wp);
--- 7,16 ----
  int term_in_normal_mode(void);
  void term_enter_job_mode(void);
  int send_keys_to_term(term_T *term, int c, int typed);
! int terminal_is_active(void);
  cursorentry_T *term_get_cursor_shape(guicolor_T *fg, guicolor_T *bg);
  int term_use_loop(void);
! int terminal_loop(int blocking);
  void term_job_ended(job_T *job);
  void term_channel_closed(channel_T *ch);
  int term_update_window(win_T *wp);
*** ../vim-8.0.1107/src/main.c	2017-08-17 17:20:58.207273018 +0200
--- src/main.c	2017-09-14 20:03:15.247541360 +0200
***************
*** 1363,1369 ****
  		/* If terminal_loop() returns OK we got a key that is handled
  		 * in Normal model.  With FAIL we first need to position the
  		 * cursor and the screen needs to be redrawn. */
! 		if (terminal_loop() == OK)
  		    normal_cmd(&oa, TRUE);
  	    }
  	    else
--- 1363,1369 ----
  		/* If terminal_loop() returns OK we got a key that is handled
  		 * in Normal model.  With FAIL we first need to position the
  		 * cursor and the screen needs to be redrawn. */
! 		if (terminal_loop(TRUE) == OK)
  		    normal_cmd(&oa, TRUE);
  	    }
  	    else
*** ../vim-8.0.1107/src/evalfunc.c	2017-09-11 19:30:58.589288855 +0200
--- src/evalfunc.c	2017-09-14 20:24:07.136088256 +0200
***************
*** 3259,3269 ****
  		/* Avoid a 1 second delay when the keys start Insert mode. */
  		msg_scroll = FALSE;
  
! 		if (!dangerous)
! 		    ++ex_normal_busy;
! 		exec_normal(TRUE);
! 		if (!dangerous)
! 		    --ex_normal_busy;
  		msg_scroll |= save_msg_scroll;
  	    }
  	}
--- 3259,3276 ----
  		/* Avoid a 1 second delay when the keys start Insert mode. */
  		msg_scroll = FALSE;
  
! #ifdef FEAT_TERMINAL
! 		if (term_use_loop())
! 		    terminal_loop(FALSE);
! 		else
! #endif
! 		{
! 		    if (!dangerous)
! 			++ex_normal_busy;
! 		    exec_normal(TRUE);
! 		    if (!dangerous)
! 			--ex_normal_busy;
! 		}
  		msg_scroll |= save_msg_scroll;
  	    }
  	}
*** ../vim-8.0.1107/src/version.c	2017-09-14 16:10:33.790060072 +0200
--- src/version.c	2017-09-14 19:14:41.660798206 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     1108,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
124. You begin conversations with, "Who is your internet service provider?"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
