To: vim_dev@googlegroups.com
Subject: Patch 8.0.1006
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.1006
Problem:    Cannot parse text with 'erroformat' without changing a quickfix
            list.
Solution:   Add the "text" argument to getqflist(). (Yegappan Lakshmanan)
Files:      runtime/doc/eval.txt, src/evalfunc.c, src/proto/quickfix.pro,
            src/quickfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.1005/runtime/doc/eval.txt	2017-08-13 18:14:42.806655953 +0200
--- runtime/doc/eval.txt	2017-08-27 15:08:16.874948765 +0200
***************
*** 4616,4621 ****
--- 4616,4626 ----
  			nr	get information for this quickfix list; zero
  				means the current quickfix list and '$' means
  				the last quickfix list
+ 			text	use 'errorformat' to extract items from the
+ 				text and return the resulting entries. The
+ 				value can be a string with one line or a list
+ 				with multiple lines. The current quickfix list
+ 				is not modified.
  			title	get the list title
  			winid	get the |window-ID| (if opened)
  			all	all of the above quickfix properties
***************
*** 4624,4629 ****
--- 4629,4637 ----
  		To get the number of lists in the quickfix stack, set 'nr' to
  		'$' in {what}. The 'nr' value in the returned dictionary
  		contains the quickfix stack size.
+ 		When 'text' is specified, all the other items are ignored. The
+ 		returned dictionary contains the entry 'items' with the list
+ 		of entries.
  		In case of error processing {what}, an empty dictionary is
  		returned.
  
*** ../vim-8.0.1005/src/evalfunc.c	2017-08-27 13:50:58.084678712 +0200
--- src/evalfunc.c	2017-08-27 15:08:16.878948739 +0200
***************
*** 4810,4816 ****
      {
  	if (rettv_list_alloc(rettv) == OK)
  	    if (is_qf || wp != NULL)
! 		(void)get_errorlist(wp, -1, rettv->vval.v_list);
      }
      else
      {
--- 4810,4816 ----
      {
  	if (rettv_list_alloc(rettv) == OK)
  	    if (is_qf || wp != NULL)
! 		(void)get_errorlist(NULL, wp, -1, rettv->vval.v_list);
      }
      else
      {
*** ../vim-8.0.1005/src/proto/quickfix.pro	2017-07-25 23:31:06.886518504 +0200
--- src/proto/quickfix.pro	2017-08-27 15:08:16.878948739 +0200
***************
*** 21,27 ****
  void ex_cnext(exarg_T *eap);
  void ex_cfile(exarg_T *eap);
  void ex_vimgrep(exarg_T *eap);
! int get_errorlist(win_T *wp, int qf_idx, list_T *list);
  int get_errorlist_properties(win_T *wp, dict_T *what, dict_T *retdict);
  int set_errorlist(win_T *wp, list_T *list, int action, char_u *title, dict_T *what);
  int set_ref_in_quickfix(int copyID);
--- 21,27 ----
  void ex_cnext(exarg_T *eap);
  void ex_cfile(exarg_T *eap);
  void ex_vimgrep(exarg_T *eap);
! int get_errorlist(qf_info_T *qi, win_T *wp, int qf_idx, list_T *list);
  int get_errorlist_properties(win_T *wp, dict_T *what, dict_T *retdict);
  int set_errorlist(win_T *wp, list_T *list, int action, char_u *title, dict_T *what);
  int set_ref_in_quickfix(int copyID);
*** ../vim-8.0.1005/src/quickfix.c	2017-08-17 16:55:08.637414759 +0200
--- src/quickfix.c	2017-08-27 15:12:32.689291362 +0200
***************
*** 2762,2768 ****
      {
  	qfp = qfl->qf_start;
  	qfpnext = qfp->qf_next;
! 	if (qfl->qf_title != NULL && !stop)
  	{
  	    vim_free(qfp->qf_text);
  	    stop = (qfp == qfpnext);
--- 2762,2768 ----
      {
  	qfp = qfl->qf_start;
  	qfpnext = qfp->qf_next;
! 	if (!stop)
  	{
  	    vim_free(qfp->qf_text);
  	    stop = (qfp == qfpnext);
***************
*** 4556,4575 ****
   * If qf_idx is -1, use the current list. Otherwise, use the specified list.
   */
      int
! get_errorlist(win_T *wp, int qf_idx, list_T *list)
  {
!     qf_info_T	*qi = &ql_info;
      dict_T	*dict;
      char_u	buf[2];
      qfline_T	*qfp;
      int		i;
      int		bufnum;
  
!     if (wp != NULL)
      {
! 	qi = GET_LOC_LIST(wp);
! 	if (qi == NULL)
! 	    return FAIL;
      }
  
      if (qf_idx == -1)
--- 4556,4579 ----
   * If qf_idx is -1, use the current list. Otherwise, use the specified list.
   */
      int
! get_errorlist(qf_info_T *qi_arg, win_T *wp, int qf_idx, list_T *list)
  {
!     qf_info_T	*qi = qi_arg;
      dict_T	*dict;
      char_u	buf[2];
      qfline_T	*qfp;
      int		i;
      int		bufnum;
  
!     if (qi == NULL)
      {
! 	qi = &ql_info;
! 	if (wp != NULL)
! 	{
! 	    qi = GET_LOC_LIST(wp);
! 	    if (qi == NULL)
! 		return FAIL;
! 	}
      }
  
      if (qf_idx == -1)
***************
*** 4628,4633 ****
--- 4632,4676 ----
  };
  
  /*
+  * Parse text from 'di' and return the quickfix list items
+  */
+     static int
+ qf_get_list_from_text(dictitem_T *di, dict_T *retdict)
+ {
+     int		status = FAIL;
+     qf_info_T	*qi;
+ 
+     /* Only string and list values are supported */
+     if ((di->di_tv.v_type == VAR_STRING && di->di_tv.vval.v_string != NULL)
+ 	    || (di->di_tv.v_type == VAR_LIST
+ 		&& di->di_tv.vval.v_list != NULL))
+     {
+ 	qi = (qf_info_T *)alloc((unsigned)sizeof(qf_info_T));
+ 	if (qi != NULL)
+ 	{
+ 	    vim_memset(qi, 0, (size_t)(sizeof(qf_info_T)));
+ 	    qi->qf_refcount++;
+ 
+ 	    if (qf_init_ext(qi, 0, NULL, NULL, &di->di_tv, p_efm,
+ 			TRUE, (linenr_T)0, (linenr_T)0, NULL, NULL) > 0)
+ 	    {
+ 		list_T	*l = list_alloc();
+ 		if (l != NULL)
+ 		{
+ 		    (void)get_errorlist(qi, NULL, 0, l);
+ 		    dict_add_list(retdict, "items", l);
+ 		    status = OK;
+ 		}
+ 		qf_free(qi, 0);
+ 	    }
+ 	    free(qi);
+ 	}
+     }
+ 
+     return status;
+ }
+ 
+ /*
   * Return quickfix/location list details (title) as a
   * dictionary. 'what' contains the details to return. If 'list_idx' is -1,
   * then current list is used. Otherwise the specified list is used.
***************
*** 4641,4646 ****
--- 4684,4692 ----
      dictitem_T	*di;
      int		flags = QF_GETLIST_NONE;
  
+     if ((di = dict_find(what, (char_u *)"text", -1)) != NULL)
+ 	return qf_get_list_from_text(di, retdict);
+ 
      if (wp != NULL)
      {
  	qi = GET_LOC_LIST(wp);
***************
*** 4726,4732 ****
  	list_T	*l = list_alloc();
  	if (l != NULL)
  	{
! 	    (void)get_errorlist(wp, qf_idx, l);
  	    dict_add_list(retdict, "items", l);
  	}
  	else
--- 4772,4778 ----
  	list_T	*l = list_alloc();
  	if (l != NULL)
  	{
! 	    (void)get_errorlist(qi, NULL, qf_idx, l);
  	    dict_add_list(retdict, "items", l);
  	}
  	else
*** ../vim-8.0.1005/src/testdir/test_quickfix.vim	2017-08-13 13:41:57.176413216 +0200
--- src/testdir/test_quickfix.vim	2017-08-27 15:08:16.882948713 +0200
***************
*** 2519,2521 ****
--- 2519,2547 ----
    call XaddQf_tests('c')
    call XaddQf_tests('l')
  endfunc
+ 
+ " Test for getting the quickfix list items from some text without modifying
+ " the quickfix stack
+ func XgetListFromText(cchar)
+   call s:setup_commands(a:cchar)
+   call g:Xsetlist([], 'f')
+ 
+   let l = g:Xgetlist({'text' : "File1:10:Line10"}).items
+   call assert_equal(1, len(l))
+   call assert_equal('Line10', l[0].text)
+ 
+   let l = g:Xgetlist({'text' : ["File2:20:Line20", "File2:30:Line30"]}).items
+   call assert_equal(2, len(l))
+   call assert_equal(30, l[1].lnum)
+ 
+   call assert_equal({}, g:Xgetlist({'text' : 10}))
+   call assert_equal({}, g:Xgetlist({'text' : []}))
+ 
+   " Make sure that the quickfix stack is not modified
+   call assert_equal(0, g:Xgetlist({'nr' : '$'}).nr)
+ endfunc
+ 
+ func Test_get_list_from_text()
+   call XgetListFromText('c')
+   call XgetListFromText('l')
+ endfunc
*** ../vim-8.0.1005/src/version.c	2017-08-27 14:50:43.233759875 +0200
--- src/version.c	2017-08-27 15:22:47.841298042 +0200
***************
*** 771,772 ****
--- 771,774 ----
  {   /* Add new patch number below this line */
+ /**/
+     1006,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
11. Specify that your drive-through order is "to go".

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
