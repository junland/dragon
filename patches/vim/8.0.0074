To: vim_dev@googlegroups.com
Subject: Patch 8.0.0074
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0074
Problem:    Cannot make Vim fail on an internal error.
Solution:   Add IEMSG() and IEMSG2(). (Domenique Pelle)  Avoid reporting an
            internal error without mentioning where.
Files:      src/globals.h, src/blowfish.c, src/dict.c, src/edit.c, src/eval.c,
            src/evalfunc.c, src/ex_eval.c, src/getchar.c, src/gui_beval.c,
            src/gui_w32.c, src/hangulin.c, src/hashtab.c, src/if_cscope.c,
            src/json.c, src/memfile.c, src/memline.c, src/message.c,
            src/misc2.c, src/option.c, src/quickfix.c, src/regexp.c,
            src/spell.c, src/undo.c, src/userfunc.c, src/vim.h, src/window.c,
            src/proto/misc2.pro, src/proto/message.pro, src/Makefile


*** ../vim-8.0.0073/src/globals.h	2016-11-06 15:25:37.689627497 +0100
--- src/globals.h	2016-11-10 18:19:43.448260941 +0100
***************
*** 1440,1445 ****
--- 1440,1446 ----
  EXTERN char_u e_fontwidth[]	INIT(= N_("E236: Font \"%s\" is not fixed-width"));
  #endif
  EXTERN char_u e_internal[]	INIT(= N_("E473: Internal error"));
+ EXTERN char_u e_intern2[]	INIT(= N_("E685: Internal error: %s"));
  EXTERN char_u e_interr[]	INIT(= N_("Interrupted"));
  EXTERN char_u e_invaddr[]	INIT(= N_("E14: Invalid address"));
  EXTERN char_u e_invarg[]	INIT(= N_("E474: Invalid argument"));
***************
*** 1589,1595 ****
  EXTERN char_u e_guarded[]	INIT(= N_("E463: Region is guarded, cannot modify"));
  EXTERN char_u e_nbreadonly[]	INIT(= N_("E744: NetBeans does not allow changes in read-only files"));
  #endif
- EXTERN char_u e_intern2[]	INIT(= N_("E685: Internal error: %s"));
  EXTERN char_u e_maxmempat[]	INIT(= N_("E363: pattern uses more memory than 'maxmempattern'"));
  EXTERN char_u e_emptybuf[]	INIT(= N_("E749: empty buffer"));
  EXTERN char_u e_nobufnr[]	INIT(= N_("E86: Buffer %ld does not exist"));
--- 1590,1595 ----
*** ../vim-8.0.0073/src/blowfish.c	2016-08-29 22:42:20.000000000 +0200
--- src/blowfish.c	2016-11-10 18:24:37.542411483 +0100
***************
*** 426,432 ****
      keylen = (int)STRLEN(key) / 2;
      if (keylen == 0)
      {
! 	EMSG(_("E831: bf_key_init() called with empty password"));
  	return;
      }
      for (i = 0; i < keylen; i++)
--- 426,432 ----
      keylen = (int)STRLEN(key) / 2;
      if (keylen == 0)
      {
! 	IEMSG(_("E831: bf_key_init() called with empty password"));
  	return;
      }
      for (i = 0; i < keylen; i++)
*** ../vim-8.0.0073/src/dict.c	2016-08-29 22:42:20.000000000 +0200
--- src/dict.c	2016-11-10 18:30:42.356117872 +0100
***************
*** 214,220 ****
  
      hi = hash_find(&dict->dv_hashtab, item->di_key);
      if (HASHITEM_EMPTY(hi))
! 	EMSG2(_(e_intern2), "dictitem_remove()");
      else
  	hash_remove(&dict->dv_hashtab, hi);
      dictitem_free(item);
--- 214,220 ----
  
      hi = hash_find(&dict->dv_hashtab, item->di_key);
      if (HASHITEM_EMPTY(hi))
! 	internal_error("dictitem_remove()");
      else
  	hash_remove(&dict->dv_hashtab, hi);
      dictitem_free(item);
*** ../vim-8.0.0073/src/edit.c	2016-10-18 13:06:33.377547323 +0200
--- src/edit.c	2016-11-10 19:21:36.688859519 +0100
***************
*** 2299,2305 ****
  	case CTRL_X_EVAL:
  	    return (c == Ctrl_P || c == Ctrl_N);
      }
!     EMSG(_(e_internal));
      return FALSE;
  }
  
--- 2299,2305 ----
  	case CTRL_X_EVAL:
  	    return (c == Ctrl_P || c == Ctrl_N);
      }
!     internal_error("vim_is_ctrl_x_key()");
      return FALSE;
  }
  
***************
*** 5431,5437 ****
  	}
  	else
  	{
! 	    EMSG2(_(e_intern2), "ins_complete()");
  	    return FAIL;
  	}
  
--- 5431,5437 ----
  	}
  	else
  	{
! 	    internal_error("ins_complete()");
  	    return FAIL;
  	}
  
*** ../vim-8.0.0073/src/eval.c	2016-10-09 17:27:56.863388510 +0200
--- src/eval.c	2016-11-10 18:31:29.847819176 +0100
***************
*** 839,845 ****
      {
  	hi = hash_find(&vimvarht, vimvars[idx].vv_di.di_key);
  	if (HASHITEM_EMPTY(hi))
! 	    EMSG2(_(e_intern2), "restore_vimvar()");
  	else
  	    hash_remove(&vimvarht, hi);
      }
--- 839,845 ----
      {
  	hi = hash_find(&vimvarht, vimvars[idx].vv_di.di_key);
  	if (HASHITEM_EMPTY(hi))
! 	    internal_error("restore_vimvar()");
  	else
  	    hash_remove(&vimvarht, hi);
      }
***************
*** 1308,1314 ****
  	}
  	else if (*arg != ',' && *arg != ']')
  	{
! 	    EMSG2(_(e_intern2), "ex_let_vars()");
  	    return FAIL;
  	}
      }
--- 1308,1314 ----
  	}
  	else if (*arg != ',' && *arg != ']')
  	{
! 	    internal_error("ex_let_vars()");
  	    return FAIL;
  	}
      }
***************
*** 2830,2836 ****
  	    }
  	    if (d == NULL)
  	    {
! 		EMSG2(_(e_intern2), "do_unlet()");
  		return FAIL;
  	    }
  	}
--- 2830,2836 ----
  	    }
  	    if (d == NULL)
  	    {
! 		internal_error("do_unlet()");
  		return FAIL;
  	    }
  	}
***************
*** 5678,5684 ****
  	case VVAL_NONE:  return "v:none";
  	case VVAL_NULL:  return "v:null";
      }
!     EMSG2(_(e_intern2), "get_var_special_name()");
      return "42";
  }
  
--- 5678,5684 ----
  	case VVAL_NONE:  return "v:none";
  	case VVAL_NULL:  return "v:null";
      }
!     internal_error("get_var_special_name()");
      return "42";
  }
  
***************
*** 7152,7158 ****
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "get_tv_number(UNKNOWN)");
  	    break;
      }
      if (denote == NULL)		/* useful for values that must be unsigned */
--- 7152,7158 ----
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    internal_error("get_tv_number(UNKNOWN)");
  	    break;
      }
      if (denote == NULL)		/* useful for values that must be unsigned */
***************
*** 7199,7205 ****
  	    break;
  # endif
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "get_tv_float(UNKNOWN)");
  	    break;
      }
      return 0;
--- 7199,7205 ----
  	    break;
  # endif
  	case VAR_UNKNOWN:
! 	    internal_error("get_tv_float(UNKNOWN)");
  	    break;
      }
      return 0;
***************
*** 7733,7739 ****
  		return;
  	    }
  	    else if (v->di_tv.v_type != tv->v_type)
! 		EMSG2(_(e_intern2), "set_var()");
  	}
  
  	clear_tv(&v->di_tv);
--- 7733,7739 ----
  		return;
  	    }
  	    else if (v->di_tv.v_type != tv->v_type)
! 		internal_error("set_var()");
  	}
  
  	clear_tv(&v->di_tv);
***************
*** 7962,7968 ****
  	    }
  	    break;
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "copy_tv(UNKNOWN)");
  	    break;
      }
  }
--- 7962,7968 ----
  	    }
  	    break;
  	case VAR_UNKNOWN:
! 	    internal_error("copy_tv(UNKNOWN)");
  	    break;
      }
  }
***************
*** 8036,8042 ****
  		ret = FAIL;
  	    break;
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "item_copy(UNKNOWN)");
  	    ret = FAIL;
      }
      --recurse;
--- 8036,8042 ----
  		ret = FAIL;
  	    break;
  	case VAR_UNKNOWN:
! 	    internal_error("item_copy(UNKNOWN)");
  	    ret = FAIL;
      }
      --recurse;
*** ../vim-8.0.0073/src/evalfunc.c	2016-10-15 17:06:42.090912729 +0200
--- src/evalfunc.c	2016-11-10 18:31:36.215779091 +0100
***************
*** 2644,2650 ****
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "f_empty(UNKNOWN)");
  	    n = TRUE;
  	    break;
      }
--- 2644,2650 ----
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    internal_error("f_empty(UNKNOWN)");
  	    n = TRUE;
  	    break;
      }
***************
*** 12695,12701 ****
  	case VAR_JOB:     n = VAR_TYPE_JOB; break;
  	case VAR_CHANNEL: n = VAR_TYPE_CHANNEL; break;
  	case VAR_UNKNOWN:
! 	     EMSG2(_(e_intern2), "f_type(UNKNOWN)");
  	     n = -1;
  	     break;
      }
--- 12695,12701 ----
  	case VAR_JOB:     n = VAR_TYPE_JOB; break;
  	case VAR_CHANNEL: n = VAR_TYPE_CHANNEL; break;
  	case VAR_UNKNOWN:
! 	     internal_error("f_type(UNKNOWN)");
  	     n = -1;
  	     break;
      }
*** ../vim-8.0.0073/src/ex_eval.c	2016-08-29 22:42:20.000000000 +0200
--- src/ex_eval.c	2016-11-10 19:26:49.226873434 +0100
***************
*** 595,601 ****
  
      if (excp == NULL)
      {
! 	EMSG(_(e_internal));
  	return;
      }
  
--- 595,601 ----
  
      if (excp == NULL)
      {
! 	internal_error("discard_exception()");
  	return;
      }
  
***************
*** 700,706 ****
  finish_exception(except_T *excp)
  {
      if (excp != caught_stack)
! 	EMSG(_(e_internal));
      caught_stack = caught_stack->caught;
      if (caught_stack != NULL)
      {
--- 700,706 ----
  finish_exception(except_T *excp)
  {
      if (excp != caught_stack)
! 	internal_error("finish_exception()");
      caught_stack = caught_stack->caught;
      if (caught_stack != NULL)
      {
***************
*** 1603,1609 ****
  	     * ":break", ":return", ":finish", error, interrupt, or another
  	     * exception. */
  	    if (cstack->cs_exception[cstack->cs_idx] != current_exception)
! 		EMSG(_(e_internal));
  	}
  	else
  	{
--- 1603,1609 ----
  	     * ":break", ":return", ":finish", error, interrupt, or another
  	     * exception. */
  	    if (cstack->cs_exception[cstack->cs_idx] != current_exception)
! 		internal_error("ex_catch()");
  	}
  	else
  	{
***************
*** 1737,1743 ****
  		 * exception will be discarded. */
  		if (did_throw && cstack->cs_exception[cstack->cs_idx]
  							 != current_exception)
! 		    EMSG(_(e_internal));
  	    }
  
  	    /*
--- 1737,1743 ----
  		 * exception will be discarded. */
  		if (did_throw && cstack->cs_exception[cstack->cs_idx]
  							 != current_exception)
! 		    internal_error("ex_finally()");
  	    }
  
  	    /*
*** ../vim-8.0.0073/src/getchar.c	2016-08-29 22:42:20.000000000 +0200
--- src/getchar.c	2016-11-10 18:31:44.727725510 +0100
***************
*** 250,256 ****
      }
      else if (buf->bh_curr == NULL)	/* buffer has already been read */
      {
! 	EMSG(_("E222: Add to read buffer"));
  	return;
      }
      else if (buf->bh_index != 0)
--- 250,256 ----
      }
      else if (buf->bh_curr == NULL)	/* buffer has already been read */
      {
! 	IEMSG(_("E222: Add to read buffer"));
  	return;
      }
      else if (buf->bh_index != 0)
***************
*** 1321,1331 ****
  free_typebuf(void)
  {
      if (typebuf.tb_buf == typebuf_init)
! 	EMSG2(_(e_intern2), "Free typebuf 1");
      else
  	vim_free(typebuf.tb_buf);
      if (typebuf.tb_noremap == noremapbuf_init)
! 	EMSG2(_(e_intern2), "Free typebuf 2");
      else
  	vim_free(typebuf.tb_noremap);
  }
--- 1321,1331 ----
  free_typebuf(void)
  {
      if (typebuf.tb_buf == typebuf_init)
! 	internal_error("Free typebuf 1");
      else
  	vim_free(typebuf.tb_buf);
      if (typebuf.tb_noremap == noremapbuf_init)
! 	internal_error("Free typebuf 2");
      else
  	vim_free(typebuf.tb_noremap);
  }
***************
*** 4868,4874 ****
  			c1 = 'l';
  			break;
  		    default:
! 			EMSG(_("E228: makemap: Illegal mode"));
  			return FAIL;
  		}
  		do	/* do this twice if c2 is set, 3 times with c3 */
--- 4868,4874 ----
  			c1 = 'l';
  			break;
  		    default:
! 			IEMSG(_("E228: makemap: Illegal mode"));
  			return FAIL;
  		}
  		do	/* do this twice if c2 is set, 3 times with c3 */
*** ../vim-8.0.0073/src/gui_beval.c	2016-09-09 22:00:25.000000000 +0200
--- src/gui_beval.c	2016-11-10 18:24:37.550411433 +0100
***************
*** 218,224 ****
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	EMSG(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
--- 218,224 ----
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	IEMSG(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
*** ../vim-8.0.0073/src/gui_w32.c	2016-10-12 14:19:55.746357751 +0200
--- src/gui_w32.c	2016-11-10 18:24:37.550411433 +0100
***************
*** 8620,8626 ****
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	EMSG(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
--- 8620,8626 ----
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	IEMSG(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
*** ../vim-8.0.0073/src/hangulin.c	2016-08-29 22:42:20.000000000 +0200
--- src/hangulin.c	2016-11-10 18:24:37.550411433 +0100
***************
*** 590,596 ****
  	    return AUTOMATA_CORRECT_NEW;
  
  	default:
! 	    EMSG(_("E256: Hangul automata ERROR"));
  	    break;
      }
      return AUTOMATA_ERROR; /* RrEeAaLlLlYy EeRrRrOoRr */
--- 590,596 ----
  	    return AUTOMATA_CORRECT_NEW;
  
  	default:
! 	    IEMSG(_("E256: Hangul automata ERROR"));
  	    break;
      }
      return AUTOMATA_ERROR; /* RrEeAaLlLlYy EeRrRrOoRr */
*** ../vim-8.0.0073/src/hashtab.c	2016-08-29 22:42:20.000000000 +0200
--- src/hashtab.c	2016-11-10 18:31:48.775700031 +0100
***************
*** 210,216 ****
      hi = hash_lookup(ht, key, hash);
      if (!HASHITEM_EMPTY(hi))
      {
! 	EMSG2(_(e_intern2), "hash_add()");
  	return FAIL;
      }
      return hash_add_item(ht, hi, key, hash);
--- 210,216 ----
      hi = hash_lookup(ht, key, hash);
      if (!HASHITEM_EMPTY(hi))
      {
! 	internal_error("hash_add()");
  	return FAIL;
      }
      return hash_add_item(ht, hi, key, hash);
*** ../vim-8.0.0073/src/if_cscope.c	2016-11-06 14:46:40.644143343 +0100
--- src/if_cscope.c	2016-11-10 19:59:00.346602378 +0100
***************
*** 1792,1798 ****
  	cs_print_tags_priv(mp, cp, cnt);
  	break;
      default:	/* should not reach here */
! 	(void)EMSG(_("E570: fatal error in cs_manage_matches"));
  	return NULL;
      }
  
--- 1792,1798 ----
  	cs_print_tags_priv(mp, cp, cnt);
  	break;
      default:	/* should not reach here */
! 	IEMSG(_("E570: fatal error in cs_manage_matches"));
  	return NULL;
      }
  
*** ../vim-8.0.0073/src/json.c	2016-11-06 14:17:13.182972857 +0100
--- src/json.c	2016-11-10 18:31:52.663675557 +0100
***************
*** 328,334 ****
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "json_encode_item()");
  	    return FAIL;
      }
      return OK;
--- 328,334 ----
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    internal_error("json_encode_item()");
  	    return FAIL;
      }
      return OK;
*** ../vim-8.0.0073/src/memfile.c	2016-08-29 22:42:20.000000000 +0200
--- src/memfile.c	2016-11-10 18:24:37.550411433 +0100
***************
*** 482,488 ****
      flags = hp->bh_flags;
  
      if ((flags & BH_LOCKED) == 0)
! 	EMSG(_("E293: block was not locked"));
      flags &= ~BH_LOCKED;
      if (dirty)
      {
--- 482,488 ----
      flags = hp->bh_flags;
  
      if ((flags & BH_LOCKED) == 0)
! 	IEMSG(_("E293: block was not locked"));
      flags &= ~BH_LOCKED;
      if (dirty)
      {
*** ../vim-8.0.0073/src/memline.c	2016-08-29 22:42:20.000000000 +0200
--- src/memline.c	2016-11-10 19:28:51.582093727 +0100
***************
*** 333,339 ****
  	goto error;
      if (hp->bh_bnum != 0)
      {
! 	EMSG(_("E298: Didn't get block nr 0?"));
  	goto error;
      }
      b0p = (ZERO_BL *)(hp->bh_data);
--- 333,339 ----
  	goto error;
      if (hp->bh_bnum != 0)
      {
! 	IEMSG(_("E298: Didn't get block nr 0?"));
  	goto error;
      }
      b0p = (ZERO_BL *)(hp->bh_data);
***************
*** 383,389 ****
  	goto error;
      if (hp->bh_bnum != 1)
      {
! 	EMSG(_("E298: Didn't get block nr 1?"));
  	goto error;
      }
      pp = (PTR_BL *)(hp->bh_data);
--- 383,389 ----
  	goto error;
      if (hp->bh_bnum != 1)
      {
! 	IEMSG(_("E298: Didn't get block nr 1?"));
  	goto error;
      }
      pp = (PTR_BL *)(hp->bh_data);
***************
*** 401,407 ****
  	goto error;
      if (hp->bh_bnum != 2)
      {
! 	EMSG(_("E298: Didn't get block nr 2?"));
  	goto error;
      }
  
--- 401,407 ----
  	goto error;
      if (hp->bh_bnum != 2)
      {
! 	IEMSG(_("E298: Didn't get block nr 2?"));
  	goto error;
      }
  
***************
*** 950,956 ****
  
      b0p = (ZERO_BL *)(hp->bh_data);
      if (ml_check_b0_id(b0p) == FAIL)
! 	EMSG(_("E304: ml_upd_block0(): Didn't get block 0??"));
      else
      {
  	if (what == UB_FNAME)
--- 950,956 ----
  
      b0p = (ZERO_BL *)(hp->bh_data);
      if (ml_check_b0_id(b0p) == FAIL)
! 	IEMSG(_("E304: ml_upd_block0(): Didn't get block 0??"));
      else
      {
  	if (what == UB_FNAME)
***************
*** 2450,2456 ****
  	    /* Avoid giving this message for a recursive call, may happen when
  	     * the GUI redraws part of the text. */
  	    ++recursive;
! 	    EMSGN(_("E315: ml_get: invalid lnum: %ld"), lnum);
  	    --recursive;
  	}
  errorret:
--- 2450,2456 ----
  	    /* Avoid giving this message for a recursive call, may happen when
  	     * the GUI redraws part of the text. */
  	    ++recursive;
! 	    IEMSGN(_("E315: ml_get: invalid lnum: %ld"), lnum);
  	    --recursive;
  	}
  errorret:
***************
*** 2485,2491 ****
  		/* Avoid giving this message for a recursive call, may happen
  		 * when the GUI redraws part of the text. */
  		++recursive;
! 		EMSGN(_("E316: ml_get: cannot find line %ld"), lnum);
  		--recursive;
  	    }
  	    goto errorret;
--- 2485,2491 ----
  		/* Avoid giving this message for a recursive call, may happen
  		 * when the GUI redraws part of the text. */
  		++recursive;
! 		IEMSGN(_("E316: ml_get: cannot find line %ld"), lnum);
  		--recursive;
  	    }
  	    goto errorret;
***************
*** 2900,2906 ****
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		EMSG(_("E317: pointer block id wrong 3"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		return FAIL;
  	    }
--- 2900,2906 ----
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		IEMSG(_("E317: pointer block id wrong 3"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		return FAIL;
  	    }
***************
*** 3042,3048 ****
  	 */
  	if (stack_idx < 0)
  	{
! 	    EMSG(_("E318: Updated too many blocks?"));
  	    buf->b_ml.ml_stack_top = 0;	/* invalidate stack */
  	}
      }
--- 3042,3048 ----
  	 */
  	if (stack_idx < 0)
  	{
! 	    IEMSG(_("E318: Updated too many blocks?"));
  	    buf->b_ml.ml_stack_top = 0;	/* invalidate stack */
  	}
      }
***************
*** 3220,3226 ****
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		EMSG(_("E317: pointer block id wrong 4"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		return FAIL;
  	    }
--- 3220,3226 ----
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		IEMSG(_("E317: pointer block id wrong 4"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		return FAIL;
  	    }
***************
*** 3432,3438 ****
  
  	hp = ml_find_line(buf, lnum, ML_FIND);
  	if (hp == NULL)
! 	    EMSGN(_("E320: Cannot find line %ld"), lnum);
  	else
  	{
  	    dp = (DATA_BL *)(hp->bh_data);
--- 3432,3438 ----
  
  	hp = ml_find_line(buf, lnum, ML_FIND);
  	if (hp == NULL)
! 	    IEMSGN(_("E320: Cannot find line %ld"), lnum);
  	else
  	{
  	    dp = (DATA_BL *)(hp->bh_data);
***************
*** 3674,3680 ****
  	pp = (PTR_BL *)(dp);		/* must be pointer block */
  	if (pp->pb_id != PTR_ID)
  	{
! 	    EMSG(_("E317: pointer block id wrong"));
  	    goto error_block;
  	}
  
--- 3674,3680 ----
  	pp = (PTR_BL *)(dp);		/* must be pointer block */
  	if (pp->pb_id != PTR_ID)
  	{
! 	    IEMSG(_("E317: pointer block id wrong"));
  	    goto error_block;
  	}
  
***************
*** 3719,3729 ****
  	if (idx >= (int)pp->pb_count)	    /* past the end: something wrong! */
  	{
  	    if (lnum > buf->b_ml.ml_line_count)
! 		EMSGN(_("E322: line number out of range: %ld past the end"),
  					      lnum - buf->b_ml.ml_line_count);
  
  	    else
! 		EMSGN(_("E323: line count wrong in block %ld"), bnum);
  	    goto error_block;
  	}
  	if (action == ML_DELETE)
--- 3719,3729 ----
  	if (idx >= (int)pp->pb_count)	    /* past the end: something wrong! */
  	{
  	    if (lnum > buf->b_ml.ml_line_count)
! 		IEMSGN(_("E322: line number out of range: %ld past the end"),
  					      lnum - buf->b_ml.ml_line_count);
  
  	    else
! 		IEMSGN(_("E323: line count wrong in block %ld"), bnum);
  	    goto error_block;
  	}
  	if (action == ML_DELETE)
***************
*** 3817,3823 ****
  	if (pp->pb_id != PTR_ID)
  	{
  	    mf_put(mfp, hp, FALSE, FALSE);
! 	    EMSG(_("E317: pointer block id wrong 2"));
  	    break;
  	}
  	pp->pb_pointer[ip->ip_index].pe_line_count += count;
--- 3817,3823 ----
  	if (pp->pb_id != PTR_ID)
  	{
  	    mf_put(mfp, hp, FALSE, FALSE);
! 	    IEMSG(_("E317: pointer block id wrong 2"));
  	    break;
  	}
  	pp->pb_pointer[ip->ip_index].pe_line_count += count;
*** ../vim-8.0.0073/src/message.c	2016-09-09 14:10:47.000000000 +0200
--- src/message.c	2016-11-10 19:31:12.797194172 +0100
***************
*** 662,667 ****
--- 662,668 ----
      return msg_attr(s, attr);
  }
  
+ 
  /*
   * Print an error message with one "%s" and one string argument.
   */
***************
*** 671,676 ****
--- 672,755 ----
      return emsg3(s, a1, NULL);
  }
  
+ /*
+  * Print an error message with one or two "%s" and one or two string arguments.
+  * This is not in message.c to avoid a warning for prototypes.
+  */
+     int
+ emsg3(char_u *s, char_u *a1, char_u *a2)
+ {
+     if (emsg_not_now())
+ 	return TRUE;		/* no error messages at the moment */
+     vim_snprintf((char *)IObuff, IOSIZE, (char *)s, a1, a2);
+     return emsg(IObuff);
+ }
+ 
+ /*
+  * Print an error message with one "%ld" and one long int argument.
+  * This is not in message.c to avoid a warning for prototypes.
+  */
+     int
+ emsgn(char_u *s, long n)
+ {
+     if (emsg_not_now())
+ 	return TRUE;		/* no error messages at the moment */
+     vim_snprintf((char *)IObuff, IOSIZE, (char *)s, n);
+     return emsg(IObuff);
+ }
+ 
+ /*
+  * Same as emsg(...), but abort on error when ABORT_ON_INTERNAL_ERROR is
+  * defined. It is used for internal errors only, so that they can be
+  * detected when fuzzing vim.
+  */
+     void
+ iemsg(char_u *s)
+ {
+     msg(s);
+ #ifdef ABORT_ON_INTERNAL_ERROR
+     abort();
+ #endif
+ }
+ 
+ 
+ /*
+  * Same as emsg2(...) but abort on error when ABORT_ON_INTERNAL_ERROR is
+  * defined. It is used for internal errors only, so that they can be
+  * detected when fuzzing vim.
+  */
+     void
+ iemsg2(char_u *s, char_u *a1)
+ {
+     emsg2(s, a1);
+ #ifdef ABORT_ON_INTERNAL_ERROR
+     abort();
+ #endif
+ }
+ 
+ /*
+  * Same as emsgn(...) but abort on error when ABORT_ON_INTERNAL_ERROR is
+  * defined. It is used for internal errors only, so that they can be
+  * detected when fuzzing vim.
+  */
+     void
+ iemsgn(char_u *s, long n)
+ {
+     emsgn(s, n);
+ #ifdef ABORT_ON_INTERNAL_ERROR
+     abort();
+ #endif
+ }
+ 
+ /*
+  * Give an "Internal error" message.
+  */
+     void
+ internal_error(char *where)
+ {
+     IEMSG2(_(e_intern2), where);
+ }
+ 
  /* emsg3() and emsgn() are in misc2.c to avoid warnings for the prototypes. */
  
      void
*** ../vim-8.0.0073/src/misc2.c	2016-10-30 21:57:48.074395566 +0100
--- src/misc2.c	2016-11-10 18:25:56.829912944 +0100
***************
*** 918,924 ****
      {
  	/* Don't hide this message */
  	emsg_silent = 0;
! 	EMSGN(_("E341: Internal error: lalloc(%ld, )"), size);
  	return NULL;
      }
  
--- 918,924 ----
      {
  	/* Don't hide this message */
  	emsg_silent = 0;
! 	IEMSGN(_("E341: Internal error: lalloc(%ld, )"), size);
  	return NULL;
      }
  
***************
*** 1075,1081 ****
      p_ea = FALSE;
      if (first_tabpage->tp_next != NULL)
  	do_cmdline_cmd((char_u *)"tabonly!");
!     if (firstwin != lastwin)
  	do_cmdline_cmd((char_u *)"only!");
  # endif
  
--- 1075,1081 ----
      p_ea = FALSE;
      if (first_tabpage->tp_next != NULL)
  	do_cmdline_cmd((char_u *)"tabonly!");
!     if (!ONE_WINDOW)
  	do_cmdline_cmd((char_u *)"only!");
  # endif
  
***************
*** 6040,6071 ****
  }
  #endif
  
- /*
-  * Print an error message with one or two "%s" and one or two string arguments.
-  * This is not in message.c to avoid a warning for prototypes.
-  */
-     int
- emsg3(char_u *s, char_u *a1, char_u *a2)
- {
-     if (emsg_not_now())
- 	return TRUE;		/* no error messages at the moment */
-     vim_snprintf((char *)IObuff, IOSIZE, (char *)s, a1, a2);
-     return emsg(IObuff);
- }
- 
- /*
-  * Print an error message with one "%ld" and one long int argument.
-  * This is not in message.c to avoid a warning for prototypes.
-  */
-     int
- emsgn(char_u *s, long n)
- {
-     if (emsg_not_now())
- 	return TRUE;		/* no error messages at the moment */
-     vim_snprintf((char *)IObuff, IOSIZE, (char *)s, n);
-     return emsg(IObuff);
- }
- 
  #if defined(FEAT_SPELL) || defined(FEAT_PERSISTENT_UNDO) || defined(PROTO)
  /*
   * Read 2 bytes from "fd" and turn them into an int, MSB first.
--- 6040,6045 ----
*** ../vim-8.0.0073/src/option.c	2016-11-10 18:16:30.081477202 +0100
--- src/option.c	2016-11-10 18:32:36.615398904 +0100
***************
*** 5615,5621 ****
  	flagp = insecure_flag(idx, opt_flags);
  	return (*flagp & P_INSECURE) != 0;
      }
!     EMSG2(_(e_intern2), "was_set_insecurely()");
      return -1;
  }
  
--- 5615,5621 ----
  	flagp = insecure_flag(idx, opt_flags);
  	return (*flagp & P_INSECURE) != 0;
      }
!     internal_error("was_set_insecurely()");
      return -1;
  }
  
***************
*** 5696,5702 ****
  	if (idx < 0)	/* not found (should not happen) */
  	{
  	    EMSG2(_(e_intern2), "set_string_option_direct()");
! 	    EMSG2(_("For option %s"), name);
  	    return;
  	}
      }
--- 5696,5702 ----
  	if (idx < 0)	/* not found (should not happen) */
  	{
  	    EMSG2(_(e_intern2), "set_string_option_direct()");
! 	    IEMSG2(_("For option %s"), name);
  	    return;
  	}
      }
***************
*** 9375,9381 ****
  		    ret = NULL;
  		break;
  	    default:
! 		EMSG2(_(e_intern2), "option_iter_next()");
  		return NULL;
  	}
      }
--- 9375,9381 ----
  		    ret = NULL;
  		break;
  	    default:
! 		internal_error("option_iter_next()");
  		return NULL;
  	}
      }
***************
*** 10496,10502 ****
  #ifdef FEAT_SIGNS
  	case PV_SCL:	return (char_u *)&(curwin->w_p_scl);
  #endif
! 	default:	EMSG(_("E356: get_varp ERROR"));
      }
      /* always return a valid pointer to avoid a crash! */
      return (char_u *)&(curbuf->b_p_wm);
--- 10496,10502 ----
  #ifdef FEAT_SIGNS
  	case PV_SCL:	return (char_u *)&(curwin->w_p_scl);
  #endif
! 	default:	IEMSG(_("E356: get_varp ERROR"));
      }
      /* always return a valid pointer to avoid a crash! */
      return (char_u *)&(curbuf->b_p_wm);
*** ../vim-8.0.0073/src/quickfix.c	2016-11-06 15:25:37.697627447 +0100
--- src/quickfix.c	2016-11-10 18:32:41.083370781 +0100
***************
*** 3231,3237 ****
      {
  	if (buf != curbuf)
  	{
! 	    EMSG2(_(e_intern2), "qf_fill_buffer()");
  	    return;
  	}
  
--- 3231,3237 ----
      {
  	if (buf != curbuf)
  	{
! 	    internal_error("qf_fill_buffer()");
  	    return;
  	}
  
*** ../vim-8.0.0073/src/regexp.c	2016-10-02 16:51:32.744592886 +0200
--- src/regexp.c	2016-11-10 19:30:29.309471156 +0100
***************
*** 335,345 ****
--- 335,347 ----
  /* Used for an error (down from) vim_regcomp(): give the error message, set
   * rc_did_emsg and return NULL */
  #define EMSG_RET_NULL(m) return (EMSG(m), rc_did_emsg = TRUE, (void *)NULL)
+ #define IEMSG_RET_NULL(m) return (IEMSG(m), rc_did_emsg = TRUE, (void *)NULL)
  #define EMSG_RET_FAIL(m) return (EMSG(m), rc_did_emsg = TRUE, FAIL)
  #define EMSG2_RET_NULL(m, c) return (EMSG2((m), (c) ? "" : "\\"), rc_did_emsg = TRUE, (void *)NULL)
  #define EMSG2_RET_FAIL(m, c) return (EMSG2((m), (c) ? "" : "\\"), rc_did_emsg = TRUE, FAIL)
  #define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_("E369: invalid item in %s%%[]"), reg_magic == MAGIC_ALL)
  
+ 
  #define MAX_LIMIT	(32767L << 16L)
  
  static int re_multi_type(int);
***************
*** 2043,2049 ****
        case Magic(')'):
  	if (one_exactly)
  	    EMSG_ONE_RET_NULL;
! 	EMSG_RET_NULL(_(e_internal));	/* Supposed to be caught earlier. */
  	/* NOTREACHED */
  
        case Magic('='):
--- 2045,2051 ----
        case Magic(')'):
  	if (one_exactly)
  	    EMSG_ONE_RET_NULL;
! 	IEMSG_RET_NULL(_(e_internal));	/* Supposed to be caught earlier. */
  	/* NOTREACHED */
  
        case Magic('='):
***************
*** 5070,5076 ****
  		}
  		else
  		{
! 		    EMSG(_(e_internal));	    /* Shouldn't happen */
  		    status = RA_FAIL;
  		}
  	    }
--- 5072,5078 ----
  		}
  		else
  		{
! 		    internal_error("BRACE_LIMITS");
  		    status = RA_FAIL;
  		}
  	    }
*** ../vim-8.0.0073/src/spell.c	2016-10-15 17:06:42.090912729 +0200
--- src/spell.c	2016-11-10 18:32:45.507342935 +0100
***************
*** 6428,6434 ****
      sfwordnr = soundfold_find(slang, goodword);
      if (sfwordnr < 0)
      {
! 	EMSG2(_(e_intern2), "add_sound_suggest()");
  	return;
      }
  
--- 6428,6434 ----
      sfwordnr = soundfold_find(slang, goodword);
      if (sfwordnr < 0)
      {
! 	internal_error("add_sound_suggest()");
  	return;
      }
  
*** ../vim-8.0.0073/src/undo.c	2016-11-05 14:58:30.767225798 +0100
--- src/undo.c	2016-11-10 18:33:12.555172690 +0100
***************
*** 2582,2588 ****
  	    if (uhp == NULL || uhp->uh_walk != mark)
  	    {
  		/* Need to redo more but can't find it... */
! 		EMSG2(_(e_intern2), "undo_time()");
  		break;
  	    }
  	}
--- 2582,2588 ----
  	    if (uhp == NULL || uhp->uh_walk != mark)
  	    {
  		/* Need to redo more but can't find it... */
! 		internal_error("undo_time()");
  		break;
  	    }
  	}
***************
*** 2654,2660 ****
  #ifdef FEAT_AUTOCMD
  	    unblock_autocmds();
  #endif
! 	    EMSG(_("E438: u_undo: line numbers wrong"));
  	    changed();		/* don't want UNCHANGED now */
  	    return;
  	}
--- 2654,2660 ----
  #ifdef FEAT_AUTOCMD
  	    unblock_autocmds();
  #endif
! 	    IEMSG(_("E438: u_undo: line numbers wrong"));
  	    changed();		/* don't want UNCHANGED now */
  	    return;
  	}
***************
*** 3234,3240 ****
  {
      if (curbuf->b_u_newhead == NULL || curbuf->b_u_newhead->uh_entry == NULL)
      {
! 	EMSG(_("E439: undo list corrupt"));
  	return NULL;
      }
      return curbuf->b_u_newhead->uh_entry;
--- 3234,3240 ----
  {
      if (curbuf->b_u_newhead == NULL || curbuf->b_u_newhead->uh_entry == NULL)
      {
! 	IEMSG(_("E439: undo list corrupt"));
  	return NULL;
      }
      return curbuf->b_u_newhead->uh_entry;
***************
*** 3266,3272 ****
  	uep->ue_bot = uep->ue_top + uep->ue_size + 1 + extra;
  	if (uep->ue_bot < 1 || uep->ue_bot > curbuf->b_ml.ml_line_count)
  	{
! 	    EMSG(_("E440: undo line missing"));
  	    uep->ue_bot = uep->ue_top + 1;  /* assume all lines deleted, will
  					     * get all the old lines back
  					     * without deleting the current
--- 3266,3272 ----
  	uep->ue_bot = uep->ue_top + uep->ue_size + 1 + extra;
  	if (uep->ue_bot < 1 || uep->ue_bot > curbuf->b_ml.ml_line_count)
  	{
! 	    IEMSG(_("E440: undo line missing"));
  	    uep->ue_bot = uep->ue_top + 1;  /* assume all lines deleted, will
  					     * get all the old lines back
  					     * without deleting the current
*** ../vim-8.0.0073/src/userfunc.c	2016-08-29 22:42:21.000000000 +0200
--- src/userfunc.c	2016-11-10 18:33:33.335041901 +0100
***************
*** 2771,2777 ****
  #ifdef EXITFREE
  	if (!entered_free_all_mem)
  #endif
! 	    EMSG2(_(e_intern2), "func_unref()");
      }
      if (fp != NULL && --fp->uf_refcount <= 0)
      {
--- 2771,2777 ----
  #ifdef EXITFREE
  	if (!entered_free_all_mem)
  #endif
! 	    internal_error("func_unref()");
      }
      if (fp != NULL && --fp->uf_refcount <= 0)
      {
***************
*** 2814,2820 ****
      else if (isdigit(*name))
  	/* Only give an error for a numbered function.
  	 * Fail silently, when named or lambda function isn't found. */
! 	EMSG2(_(e_intern2), "func_ref()");
  }
  
  /*
--- 2814,2820 ----
      else if (isdigit(*name))
  	/* Only give an error for a numbered function.
  	 * Fail silently, when named or lambda function isn't found. */
! 	internal_error("func_ref()");
  }
  
  /*
*** ../vim-8.0.0073/src/vim.h	2016-10-15 19:33:47.264689748 +0200
--- src/vim.h	2016-11-10 18:24:37.562411357 +0100
***************
*** 1623,1628 ****
--- 1623,1631 ----
  #define EMSG3(s, p, q)		    emsg3((char_u *)(s), (char_u *)(p), (char_u *)(q))
  #define EMSGN(s, n)		    emsgn((char_u *)(s), (long)(n))
  #define EMSGU(s, n)		    emsgu((char_u *)(s), (long_u)(n))
+ #define IEMSG(s)		    iemsg((char_u *)(s))
+ #define IEMSG2(s, p)		    iemsg2((char_u *)(s), (char_u *)(p))
+ #define IEMSGN(s, n)		    iemsgn((char_u *)(s), (long)(n))
  #define OUT_STR(s)		    out_str((char_u *)(s))
  #define OUT_STR_NF(s)		    out_str_nf((char_u *)(s))
  #define MSG_PUTS(s)		    msg_puts((char_u *)(s))
*** ../vim-8.0.0073/src/window.c	2016-11-10 18:16:30.085477176 +0100
--- src/window.c	2016-11-10 18:33:40.198998700 +0100
***************
*** 2538,2544 ****
  		;
  	    if (ptp == NULL)
  	    {
! 		EMSG2(_(e_intern2), "win_close_othertab()");
  		return;
  	    }
  	    ptp->tp_next = tp->tp_next;
--- 2538,2544 ----
  		;
  	    if (ptp == NULL)
  	    {
! 		internal_error("win_close_othertab()");
  		return;
  	    }
  	    ptp->tp_next = tp->tp_next;
*** ../vim-8.0.0073/src/proto/misc2.pro	2016-09-12 13:04:13.000000000 +0200
--- src/proto/misc2.pro	2016-11-10 18:33:58.170885586 +0100
***************
*** 99,106 ****
  void sort_strings(char_u **files, int count);
  int pathcmp(const char *p, const char *q, int maxlen);
  int filewritable(char_u *fname);
- int emsg3(char_u *s, char_u *a1, char_u *a2);
- int emsgn(char_u *s, long n);
  int get2c(FILE *fd);
  int get3c(FILE *fd);
  int get4c(FILE *fd);
--- 99,104 ----
*** ../vim-8.0.0073/src/proto/message.pro	2016-09-12 13:04:12.000000000 +0200
--- src/proto/message.pro	2016-11-10 19:31:16.885168138 +0100
***************
*** 11,16 ****
--- 11,22 ----
  void do_perror(char *msg);
  int emsg(char_u *s);
  int emsg2(char_u *s, char_u *a1);
+ int emsg3(char_u *s, char_u *a1, char_u *a2);
+ int emsgn(char_u *s, long n);
+ void iemsg(char_u *s);
+ void iemsg2(char_u *s, char_u *a1);
+ void iemsgn(char_u *s, long n);
+ void internal_error(char *where);
  void emsg_invreg(int name);
  char_u *msg_trunc_attr(char_u *s, int force, int attr);
  char_u *msg_may_trunc(int force, char_u *s);
*** ../vim-8.0.0073/src/Makefile	2016-10-15 17:06:42.094912699 +0200
--- src/Makefile	2016-11-10 19:56:03.919720882 +0100
***************
*** 681,686 ****
--- 681,690 ----
  #LEAK_CFLAGS = -DEXITFREE
  #LEAK_LIBS = -lccmalloc
  
+ # Uncomment this line to have Vim call abort() when an internal error is
+ # detected.  Useful when using a tool to find errors.
+ #ABORT_CLFAGS = -DABORT_ON_INTERNAL_ERROR
+ 
  #####################################################
  ###  Specific systems, check if yours is listed!  ### {{{
  #####################################################
***************
*** 1409,1415 ****
  PRE_DEFS = -Iproto $(DEFS) $(GUI_DEFS) $(GUI_IPATH) $(CPPFLAGS) $(EXTRA_IPATHS)
  POST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(EXTRA_DEFS)
  
! ALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(SANITIZER_CFLAGS) $(LEAK_CFLAGS) $(POST_DEFS)
  
  # Exclude $CFLAGS for osdef.sh, for Mac 10.4 some flags don't work together
  # with "-E".
--- 1413,1419 ----
  PRE_DEFS = -Iproto $(DEFS) $(GUI_DEFS) $(GUI_IPATH) $(CPPFLAGS) $(EXTRA_IPATHS)
  POST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(EXTRA_DEFS)
  
! ALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(SANITIZER_CFLAGS) $(LEAK_CFLAGS) $(ABORT_CLFAGS) $(POST_DEFS)
  
  # Exclude $CFLAGS for osdef.sh, for Mac 10.4 some flags don't work together
  # with "-E".
*** ../vim-8.0.0073/src/version.c	2016-11-10 18:16:30.085477176 +0100
--- src/version.c	2016-11-10 19:41:18.085342236 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     74,
  /**/

-- 
Me?  A skeptic?  I trust you have proof.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
