#! /bin/sh -
#  Copyright (C) 2016-2018 Matias Fonzo <selk@dragora.org>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

# EXIT STATUS
# 0  = Successful completion
# 1  = Minor common errors (e.g: help usage, support not available)
# 2  = Command execution error
# 3  = Integrity check error for compressed files
# 4  = File empty, not regular, or expected
# 5  = Empty or not defined variable
# 6  = Package already installed
# 10 = Network manager error

#### Functions

usage()
{
    printf "%s\n" \
     "Qi - A practical and user-friendly package manager."              \
     ""                                                                 \
     "Usage: $PROGRAM [OPTION...] [FILE]..."                            \
     ""                                                                 \
     "Operation mode:"                                                  \
     "  -b          Build packages using recipes"                       \
     "  -c          Create .tlz package from directory"                 \
     "  -d          Delete packages"                                    \
     "  -i          Install packages"                                   \
     "  -o          Resolve build order through .order files"           \
     "  -u          Update packages (implies -i, -d with -p)"           \
     "  -x          Extract packages for debugging purposes"            \
     ""                                                                 \
     "Common options:"                                                  \
     "  -N          Don't read the configuration file"                  \
     "  -P  <DIR>   Package directory for (de)installations;"           \
     "              only valid for -i, -d, or -u options"               \
     "  -t  <DIR>   Target directory for symbolic links;"               \
     "              only valid for -i, -d, or -u options"               \
     "  -k          Keep (don't delete) srcdir or destdir"              \
     "              Keep (don't delete) package directory"              \
     "              this refers to the -b, -d or -u options"            \
     "  -p          Prune conflicts on package (de)installation"        \
     "  -v          be verbose (a 2nd -v gives more)"                   \
     ""                                                                 \
     "Options for 'build' mode (-b):"                                   \
     "  -O  <DIR>   Where the produced packages are written"            \
     "  -W  <DIR>   Where archives, patches, and recipes are expected"  \
     "  -Z  <DIR>   Where (compressed) sources will be found"           \
     "  -a          Architecture to use"                                \
     "  -f          Force proceeding with a recipe"                     \
     "  -j          Parallel jobs for the compiler"                     \
     "  -1          Increment release number (release + 1)"             \
     "  -n          Don't create a .tlz package"                        \
     ""                                                                 \
     "Other options:"                                                   \
     "  -h          Display this help and exit"                         \
     "  -V          Output version information"                         \
     ""                                                                 \
     "Some influential environment variables:"                          \
     "  TMPDIR      Temporary directory for sources"                    \
     "  QICFLAGS    C compiler flags"                                   \
     "  QICXXFLAGS  C++ compiler flags"                                 \
     "  QILDFLAGS   Linker flags"                                       \
     ""                                                                 \
     "With no FILE, or when FILE is -, read standard input."            \
     ""
}

version()
{
    printf "%s\n" \
     "$PROGRAM @VERSION@" \
     "Copyright (C) 2016-2018 Matias Andres Fonzo." \
     "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>" \
     "This is free software: you are free to change and redistribute it." \
     "There is NO WARRANTY, to the extent permitted by law."
}

warn()
{
    printf "%s\n" "$@" 1>&2
}

is_readable()
{
    if test -e "$1"
    then
        if ! test -r "$1"
        then
            echo "${PROGRAM}: cannot read ${1}: Permission denied" 1>&2
            return 1
        fi
    else
        echo "${PROGRAM}: cannot access ${1}: No such file or directory" 1>&2
        return 1
    fi
    return 0
}

# Portable alternative to the file operator -nt (among shells)
is_newer()
{
    if test -n "$(find $1 -prune -newer $2 -print)"
    then
        return 0
    fi
    return 1
}

# Determine whether $2 matches pattern $1
fnmatch()
{
    case $2 in
    $1)
        return 0
        ;;
    *)
        return 1
        ;;
    esac
}

chkstatus_or_exit()
{
    status=$?

    if test $status -ne 0
    then
        echo "Return status = $status" 1>&2
        exit ${1-2};	# If not given, defaults to 2
    fi

    unset status
}

readconfig()
{
    if test $RC = RC
    then
        is_readable "$HOME/.qirc" 2> /dev/null && RCFILE="$HOME/.qirc";

        echo "Processing \`${RCFILE}' ..."

        test -f "$RCFILE" || {
            warn "${RCFILE} is not a regular file."
            return 1
        }

        # Parse config file
        while IFS='=' read -r variable value
        do
            case $variable in
            \#* | "")	# Ignore commented or blank lines
                continue
                ;;
            esac

            # Set variable name avoiding code execution
            eval "$variable=\${value}"
        done < "$RCFILE"
    fi
}

#### Mode functions

build_mode()
{
    recipe=$1

    # A recipe is any valid regular file, the current working directory
    # has priority over the working tree (or where the recipes reside).
    # The 'worktree' is the second place where to find a recipe.  Also,
    # we complete the possibility of using the directory name to invoke
    # a recipe if it contains "recipe" as valid file name.

    if test ! -f "$recipe"
    then
        if test -f "${recipe}/recipe"
        then
            recipe="${recipe}/recipe"
        elif test -f "${worktree}/recipes/${recipe}/recipe"
        then
            recipe="${worktree}/recipes/${recipe}/recipe"
        fi
    fi

    test -f "$recipe" || {
        warn "${PROGRAM}: \`${recipe}' is not a regular file."
        exit 4
    }

    # Complain if the file name is not "recipe"

    if test "${recipe##*/}" = recipe
    then
        true
    else
        warn "${PROGRAM}: \`${recipe}' is not a valid recipe name."
        exit 4
    fi

    # Start preparations to import the recipe

    # Separate the directory name from the filename,
    # getting its absolute path name and base name

    CWD=$(CDPATH= cd -P -- $(dirname -- "$recipe") && printf "$PWD")
    recipe=$(basename -- "$recipe")

    # Check readability for load the recipe on success

    is_readable "${CWD}/$recipe" || exit 4

    # Make tail directories if needed
    test -d "${worktree}/archive"  || mkdir -p -- "${worktree}/archive"
    test -d "${worktree}/patches"  || mkdir -p -- "${worktree}/patches"
    test -d "${worktree}/recipes"  || mkdir -p -- "${worktree}/recipes"
    test -d "$tardir"              || mkdir -p -- "$tardir"

    # Variables treatment for the current and next recipe.
    #
    # Unset special variables that can only be predefined on
    # the recipe and not coming from ${sysconfdir}/qirc

    unset srcdir destdir pkgname pkgversion program version release \
          fetch description homepage license replace keep_srcdir

    # The following variables must be restored later
    save_arch="${save_arch:=$arch}"
    save_jobs="${save_jobs:=$jobs}"

    unset arch jobs

    # The following variables can not be redefined on the recipe
    readonly outdir worktree netget rsync

    # Recommended practices is to set variables in front of
    # `configure'/make(1), see documentation of Qi for details.
    unset CFLAGS CXXFLAGS LDFLAGS

    # Load recipe

    echo "{@} Building from ${CWD}/$recipe ..."
    . "${CWD}/$recipe"

    # Check for required variables
    if test -z "$program"
    then
        warn "${recipe}: The variable 'program' is not defined."
        exit 5
    fi
    if test -z "$version"
    then
        warn "${recipe}: The variable 'version' is not defined."
        exit 5
    fi
    if test -z "$release"
    then
        warn "${recipe}: The variable 'release' is not defined."
        exit 5
    fi

    # Pre-settings before to start building

    # Increment the release number if the option was given
    if test "$opt_incr_release" = opt_incr_release
    then
        release=$(( release + 1 ))
    fi

    # Allow the dot as definition for 'tardir'
    if test "$tardir" = .
    then
        tardir="$CWD"
    fi

    # Set default values for the following special variables

    pkgname="${pkgname:=$program}"
    pkgversion="${pkgversion:=$version}"
    srcdir="${srcdir:=${program}-$version}"
    destdir="${destdir:=${TMPDIR}/package-$pkgname}"

    # Restore default values if they were not given on the recipe
    arch="${arch:=$save_arch}"
    jobs="${jobs:=$save_jobs}"

    # Complete package name adding "pkgversion-arch+release"
    full_pkgname=$pkgname-${pkgversion}-${arch}+${release}

    # If a package is going to be created, the existence of a
    # previous build of the package is detected and reported.
    # Under normal conditions, the recipe is built as long as
    # it is newer than the package produced; if not, we warn
    # the user about it.  Rebuilding the package is also
    # possible (through the force ;-)

    if test "$opt_nopkg" != opt_nopkg && \
     { test "$opt_force" != opt_force && \
       test -r "${outdir}/${full_pkgname}.tlz" ; }
    then
        if is_newer "${CWD}/$recipe" "${outdir}/${full_pkgname}.tlz"
        then
            warn \
             ""                                                          \
             "The recipe is NEWER than the detected package:"            \
             ""                                                          \
             "$( stat -c "%y %n" "${CWD}/$recipe" )"                     \
             "$( stat -c "%y %n" "${outdir}/${full_pkgname}.tlz" )"      \
             ""                                                          \
             "    This recipe will be processed."                        \
             ""
        elif test "$_opt_ignoreqsts" = _opt_ignoreqsts
        then
            warn "Recipe for '${full_pkgname}.tlz':  Ignored." ""
            return 0
        else
            warn \
             ""                                                          \
             "The recipe ALREADY produced the package:"                  \
             "$( stat -c "%y %n" "${outdir}/${full_pkgname}.tlz" )"      \
             ""                                                          \
             "But the recipe is still older than the produced package:"  \
             "$( stat -c "%y %n" "${CWD}/$recipe" )"                     \
             ""                                                          \
             "    Probably nothing has changed."                         \
             ""

            # In non-interactive mode, the user is asked about
            # rebuilding the package.  In interactive mode,
            # the user need to pass the option explicitly.

            if test ! -t 0
            then
                printf "%b" \
                 "Do you want to rebuild this package?\n"   \
                 "1) Yes, built it\n"                       \
                 "2) No, skipt it [default]\n"              \
                 "3) Resume, skipping completed recipes\n"  \
                 "Choose an option number: " > /dev/tty
                IFS= read -r REPLY < /dev/tty || chkstatus_or_exit
                case $REPLY in
                1*)
                    echo "$REPLY" > /dev/tty
                    unset REPLY
                    ;;
                3*)
                    unset REPLY
                    echo "Building unprocessed and/or modified recipes ..." > /dev/tty
                    echo ""
                    _opt_ignoreqsts=_opt_ignoreqsts
                    readonly _opt_ignoreqsts
                    return 0
                    ;;
                *)
                    unset REPLY
                    echo "Recipe for '${full_pkgname}.tlz':  Cancelled." > /dev/tty
                    echo ""
                    return 0
                    ;;
                esac
            else
                warn "Use the -f option to re-process ${CWD}/$recipe." ""
                return 6;
            fi
        fi
    fi

    # Fetch remote sources

    echo "Fetching remote sources if needed ..."
    if test -n "$fetch"
    then
        for origin in $fetch
        do
            _source="${origin##*/}"

            echo "Looking for \"$_source\" ..."

            echo "Verifying checksum file \"${_source}.sha256\" from '${tardir}'"
            if test -e "${tardir}/${_source}.sha256"
            then
                ( cd -- "$tardir" && sha256sum - ) < "${tardir}/${_source}.sha256"
                chkstatus_or_exit
                continue;
            else
                warn "${_source}.sha256: Checksum file does not exist, yet."
            fi

            # Download the source or resume it if allowed

            if test ! -e "${tardir}/$_source"
            then
                warn "    Can't find $_source in ${tardir};" \
                     "attempting to get it from ${origin%/*} ..."
            fi

            case $origin in
            rsync://*)
                    (
                        cd -- "$tardir" && $rsync $origin || chkstatus_or_exit
                        sha256sum $_source > ${_source}.sha256
                    )
                ;;
            *://*)
                    (
                        cd -- "$tardir" && $netget $origin || chkstatus_or_exit
                        sha256sum $_source > ${_source}.sha256
                    )
                ;;
            *)
                warn "${PROGRAM}: Unrecognized protocol for ${origin}."
                exit 4
            esac
        done
        unset origin _source
    else
        warn "The variable 'fetch' is empty."
    fi

    # Prepare special directories for build the source,
    # the destination and the output of the package

    echo "Preparing directories ..."

    if test -d "${TMPDIR}/$srcdir" && test -z "$keep_srcdir"
    then
        rm -rf -- "${TMPDIR}/$srcdir" || chkstatus_or_exit
        echo "removed directory: '${TMPDIR}/$srcdir'"
    fi
    mkdir -p -- "${TMPDIR}/$srcdir" || chkstatus_or_exit

    if test -d "$destdir"
    then
        rm -rf -- "$destdir" || chkstatus_or_exit
        echo "removed directory: '$destdir'"
    fi
    mkdir -p -- "$destdir" || chkstatus_or_exit
    echo "mkdir: created directory '$destdir'"

    if test ! -d "$outdir"
    then
        mkdir -p -- "$outdir" || chkstatus_or_exit
        echo "mkdir: created directory '$outdir'"
    fi

    # Set sane permissions for '${TMPDIR}/$srcdir'
    echo "${TMPDIR}/${srcdir}: Changing file mode bits to u+w,go-w,a+rX-s ..."
    chmod -R u+w,go-w,a+rX-s "${TMPDIR}/$srcdir" || chkstatus_or_exit

    echo "Entering to 'TMPDIR': $TMPDIR ..."
    cd -- "$TMPDIR" || chkstatus_or_exit

    # Set trap before to run the build() function in order
    # to catch the return status, exit code 2 if fails

    trap 'chkstatus_or_exit 2' EXIT HUP INT QUIT ABRT TERM

    echo "Running build() ..."
    build ; set +e ; unset build

    # Reset given signals
    trap - EXIT HUP INT QUIT ABRT TERM

    # If 'destdir' is empty, the package won't be created
    if rmdir -- "$destdir" 2> /dev/null
    then
        warn "${full_pkgname}.tlz won't be created: 'destdir' was empty."
        opt_nopkg=opt_nopkg
    fi

    # Create (make) the package

    if test "$opt_nopkg" != opt_nopkg
    then
        # Edit the recipe when 'release' is incremented
        if test "$opt_incr_release" = opt_incr_release
        then
            echo ",s/^\(release\)=.*/\1=${release}/"$'\nw' | \
             ed "${CWD}/$recipe" || chkstatus_or_exit
        fi

        mkdir -p -- "${destdir}/var/lib/qi" || chkstatus_or_exit

        # Include a recipe copy into the package
        cp -p "${CWD}/$recipe" \
              "${destdir}/var/lib/qi/${full_pkgname}.recipe" && \
        chmod 644 "${destdir}/var/lib/qi/${full_pkgname}.recipe" || chkstatus_or_exit

        # Detect post-install script for inclusion

        if test -f "${CWD}/post-install"
        then
            echo "${CWD}/post-install:  Detected."
            cp -p "${CWD}/post-install" \
                  "${destdir}/var/lib/qi/${full_pkgname}.sh" && \
            chmod 644 "${destdir}/var/lib/qi/${full_pkgname}.sh" || chkstatus_or_exit
        fi

        # Detect declared package names for later replacement

        if test -n "$replace"
        then
            warn \
             "The following package names has been declared for replacement:" \
             "    $replace"

            rm -f "${destdir}/var/lib/qi/${full_pkgname}.replace"
            for item in $replace
            do
                echo "$replace" >> "${destdir}/var/lib/qi/${full_pkgname}.replace"
            done
            unset item
        fi

        # Create meta file for the package information
        echo "Creating meta file ${full_pkgname}.tlz.txt ..."
        do_meta > "${outdir}/${full_pkgname}.tlz.txt" || chkstatus_or_exit

        # Make a copy of it for the database
        cp -p "${outdir}/${full_pkgname}.tlz.txt" \
              "${destdir}/var/lib/qi/${full_pkgname}.txt" || chkstatus_or_exit

        # Produce the package
        cd -- "$destdir" && create_mode "${outdir}/${full_pkgname}.tlz"
    fi

    # Back to the current working directory
    cd -- "$CWD" || chkstatus_or_exit

    # Delete 'srcdir' or 'destdir' if -k is not given
    if test "$opt_keep" != opt_keep
    then
        echo "Deleting temporary directories ..."

        if test -z "$keep_srcdir"
        then
            rm -rf -- "${TMPDIR}/${srcdir%%/*}" || chkstatus_or_exit
            echo "removed directory: '${TMPDIR}/${srcdir%%/*}'"
        else
            warn "The variable 'keep_srcdir' is set:" \
                 "'${TMPDIR}/${srcdir%%/*}' will not be deleted."
        fi

        if test -d "$destdir"
        then
            rm -rf -- "$destdir" || chkstatus_or_exit
            echo "removed directory: '$destdir'"
        fi   
    fi

    # Install or update the package if -i or -u was passed
    if test "$opt_install" = opt_install && test "$opt_nopkg" != opt_nopkg
    then
        install_mode "${outdir}/${full_pkgname}.tlz"
    elif test "$opt_update" = opt_update && test "$opt_nopkg" != opt_nopkg
    then
        upgrade_mode "${outdir}/${full_pkgname}.tlz"
    fi

    echo ""
    echo "All done for ${CWD}/${recipe}."
    echo ""
}

create_mode()
{
    directory=$(dirname -- "$1")
    name=$(basename -- "$1")

    # Perform sanity checks

    is_readable "$directory" || exit 4

    # Check again to find out if it is a valid directory
    test -d "$directory" || {
        warn "${PROGRAM}: Package directory '$name' does not exist."
        exit 4
    }

    test "$directory" = . && {
        warn "${PROGRAM}: Cannot create package on current working directory."
        exit 4
    }

    test "$name" = "${name%.tlz}" && {
        warn \
         "${PROGRAM}: Package format '$name' not supported." \
         "It should be \`name-version-architecture+release.tlz'"
        exit 4
    }

    echo "{#} Creating package $name at $directory ..."

    ( umask 022 ; tar cvf - ./* | lzip -9cvv ) > "${directory}/$name"
    chkstatus_or_exit 3

    echo "Package created \"${directory}/${name}\"."

    echo "${directory}/$name: Creating SHA256 checksum ..."
    ( cd -- "$directory" && sha256sum $name > ${name}.sha256 )

    # Remove used variables
    unset directory name
}

delete_mode()
{
    expunge=$1

    echo "<<< Deleting package $expunge ..."

    # If package is not a fully qualified directory, prepend it with
    # the value of packagedir.  The solely '/' does not qualify here.

    if ! fnmatch '/?*' "$expunge"
    then
        expunge=$(basename -- "$expunge" .tlz)
        expunge="${packagedir}/$expunge"
    fi

    # Complain if the package directory does not exist

    test -d "$expunge" || {
        warn "${PROGRAM}: Package directory '$expunge' does not exist."
        exit 4
    }

    # Complain if the package directory cannot be well-read

    is_readable "$expunge" || exit 4

    # Ignore some signals up to completing the deinstallation
    trap "" HUP INT QUIT ABRT TERM

    # Remove package from Graft control

    # Scan for possible conflicts, stop if arise
    if test "$opt_prune" != opt_prune
    then
        echo "Checking for possible conflicts ..."
        if graft -d -n -t "$targetdir" "$expunge" 2>&1 | grep ^CONFLICT
        then
            warn \
             ""                                                \
             "    A conflict occurred during uninstallation;"  \
             "the package will be PRESERVED (unless the -p option is given)."
            exit 6
        fi
    else
        # Remove objects (files, links or directories) from the target
        # directory that are in conflict with the package directory
        echo "Pruning any conflict ..."
        graft -p -D -u -t "$targetdir" "$expunge"
        chkstatus_or_exit 2
    fi

    echo "Disabling links ..."
    graft -d -D -u $graft_v -t "$targetdir" "$expunge"
    chkstatus_or_exit 2

    # Delete package directory
    if test "$opt_keep" != opt_keep
    then
        echo "Deleting package directory, if present ..."

        if test -d "$expunge"
        then
            rm -rf -- "$expunge" || chkstatus_or_exit
            echo "removed directory: '$expunge'"
        fi
    fi

    # Reset given signals
    trap - HUP INT QUIT ABRT TERM

    # Remove used variables
    unset expunge
}

install_mode()
{
    # Complain if the package cannot be well-read

    is_readable "$1" || exit 4

    # Complain if the package does not end in .tlz

    if ! fnmatch '*.tlz' "$1"
    then
        warn "${PROGRAM}: \`${1}' does not end in .tlz"
        exit 4
    fi

    # Make preparations to install the package

    echo ">>> Installing package $1 ..."

    # Get the filename
    name=$(basename -- "$1" .tlz)

    echo "Checking tarball integrity ..."
    tar -tf "$1" > /dev/null
    chkstatus_or_exit 3

    # Create package directory using 'name'
    if ! test -d "${packagedir}/$name"
    then
        mkdir -p -- "${packagedir}/$name" || chkstatus_or_exit
        echo "mkdir: created directory '${packagedir}/$name'"
    fi

    # Ignore some signals up to completing the installation
    trap "" HUP INT QUIT ABRT TERM

    echo "Decompressing $1 ..."
    ( cd -- "${packagedir}/$name" && lzip -cd - | tar xpf - ) < "$1"
    chkstatus_or_exit 3

    # Transite package to Graft control

    # Scan for possible conflicts, stop if arise
    if test "$opt_prune" != opt_prune
    then
        echo "Checking for possible conflicts ..."
        if graft -i -n -t "$targetdir" "${packagedir}/$name" 2>&1 | grep ^CONFLICT
        then
            warn \
             ""                                              \
             "    A conflict occurred during installation;"  \
             "the package won't be LINKED (unless the -p option is given)."
            exit 6
        fi
    else
        # Remove objects (files, links or directories) from the target
        # directory that are in conflict with the package directory
        echo "Pruning any conflict ..."
        graft -p -D -u -t "$targetdir" "${packagedir}/$name"
        chkstatus_or_exit 2
    fi

    echo "Enabling symbolic links ..."
    graft -i -P $graft_v -t "$targetdir" "${packagedir}/$name"
    chkstatus_or_exit 2

    # Avoid unnecessary runs coming from the upgrade_mode(),
    # this is when the incoming package is **pre-installed**

    if test "$_isUpgrade" != isUpgrade.true
    then
        # Show package description
        if test -r "${packagedir}/${name}/var/lib/qi/${name}.txt"
        then
            grep '^#' "${packagedir}/${name}/var/lib/qi/${name}.txt"
        elif test -r "${1}.txt"
        then
            # From the external meta file
            grep '^#' "${1}.txt"
        else
            warn "Description file not found for '$name'."
        fi

        # Check and run the post-install script if exist
        if test -r "${packagedir}/${name}/var/lib/qi/${name}.sh"
        then
            echo "Running post-install script for \`${name}' ..."
            (
                cd -- "${targetdir}"/ && \
                 . "${packagedir}/${name}/var/lib/qi/${name}.sh"
            )
        fi

        # Check if there are declared package names for replacement
        if test -r "${packagedir}/${name}/var/lib/qi/${name}.replace"
        then
            while read -r line
            do
                for replace in "${packagedir}/$(pkgbase $line)"-*
                do
                    warn "" "*** Replacing package \`${replace}' ..."

                    test -e "$replace" || {
                        warn "WARNING: declared package does not exist."
                        continue;
                    }

                    # The search for the package to be replaced can not be
                    # the same to the temporary location coming from upgrade
                    test "$replace" = "$PRVLOC" && continue;

                    opt_force=opt_force opt_keep=opt_keep.off \
                     delete_mode "$replace" > /dev/null
                done
            done < "${packagedir}/${name}/var/lib/qi/${name}.replace"
            unset line
        fi
    fi

    # Reset given signals
    trap - HUP INT QUIT ABRT TERM

    # Remove used variables
    unset name
}

resolve_mode() {
    # Complain if the file cannot be well-read

    is_readable "$1" || exit 4

    # Complain if the file does not end in .order

    if ! fnmatch '*.order' "$1"
    then
        warn "${PROGRAM}: \`${1}' does not end in .order"
        exit 4
    fi

    # Get a clean list of the file while prints its content in reverse order,
    # lines containing: colons, comments, parentheses, end of line, and blank
    # lines, are removed.  The parentheses are used to insert a reference.
    # The last `awk' in the pipe: removes nonconsecutive lines, duplicate.
    awk \
    '{ gsub( /:|^#(.*)$|\([^)]*)|^$/,"" ); for( i=NF; i > 0; i-- ) print $i }' \
     "$1" | awk '!s[$0]++'
}

upgrade_mode()
{
    # Complain if the package is not a regular file

    test -f "$1" || {
        warn "${PROGRAM}: \`${1}' is not a regular file."
        exit 4
    }

    # Get the filename
    incoming=$(basename -- "$1" .tlz)

    # Prepare the package to install it in a temporary location

    # Set random directory using packagedir as prefix and 'incoming' as suffix
    PRVLOC=$(mktemp -dp "$packagedir" ${incoming}.XXXXXXXXXXXX) || exit 2

    # Pre-install the package in the custom 'packagedir'

    save_packagedir="$packagedir"
    packagedir="$PRVLOC"

    echo "Pre-installing package using temporary location ..."
    opt_prune=opt_prune		# Turn on prune operation.
    _isUpgrade=_isUpgrade.true install_mode "$1" > /dev/null
    _isUpgrade=_isUpgrade.false

    # Restore variable before looking for old packages
    packagedir=$save_packagedir
    unset save_packagedir

    echo "Looking for other installations under the same name ..."
    for long_name in "${packagedir}/$(pkgbase $incoming)"*
    do
        found="${long_name##*/}"

        # The search for the package to be deleted can not be
        # the same to the temporary location
        test "$long_name" = "$PRVLOC" && continue;

        fnmatch "$(pkgbase $found)*" "$incoming" || continue;

        echo "${long_name}:  Detected."

        # A package directory is preserved if -k is given
        delete_mode "$long_name" > /dev/null
    done
    unset long_name found

    # Re-install the package removing the temporary location

    install_mode "$1"
    opt_prune=opt_prune.off	# Turn off prune operation.

    echo "Deleting temporary location ..."
    rm -rf -- "$PRVLOC" && echo "removed directory: '$PRVLOC'"

    echo ""
    echo "Successful upgrade to '${incoming}'."

    # Remove remaining variables
    unset incoming PRVLOC
}

extract_mode()
{
    # Perform sanity checks before package extraction

    is_readable "$1" || exit 4

    test -f "$1" || {
        warn "${PROGRAM}: \`${1}' is not a regular file."
        exit 4
    }

    # Preparations to extract the package

    name=$(basename -- "$1" .tlz)

    # Set random directory using 'name' as prefix
    PRVDIR="${TMPDIR}/${name}.${RANDOM-0}$$"

    # Trap to remove 'PRVDIR' on disruptions
    trap "rm -rf -- $PRVDIR" HUP INT ABRT TERM

    # Create 'PRVDIR' removing access for all but user
    ( umask 077 ; mkdir -- $PRVDIR )
    mkdir -p -m 700 -- $PRVDIR

    # Extract the package

    echo "Extracting package $name on $PRVDIR ..."
    ( umask 000 ; cd -- $PRVDIR && lzip -cd - | tar xf - ) < "$1"
    if test $? -ne 0
    then
        # Try to remove (empty) 'PRVDIR' on failure
        rmdir -- $PRVDIR
        exit 3;
    fi

    # Reset given signals
    trap - HUP INT ABRT TERM

    # Remove used variables
    unset name PRVDIR
}

#### Extra functions used in the modes

pkgbase()
{
    string=$(basename -- "$1" .tlz)

    # Take and count the dashes only

    dashes=$(echo "$string" | tr -cd '-')
    dashes="${#dashes}"

    # Match cases to print the package name
    case $dashes in
    1)
        # NAME-VERSION
        echo "${string%-*}"
        ;;
    *)
        # NAME_[-LONG]-VERSION-ARCH+release
        echo "${string%-*-*}"
        ;;
    esac

    unset string dashes
}

unpack()
{
    for file in "$@"
    do
        case $file in
        *.tar)
            tar tf "$file" > /dev/null && \
            tar xpf "$file"
            chkstatus_or_exit 3
            ;;
        *.tar.gz | *.tgz | *.tar.Z )
            gzip -cd "$file" | tar tf - > /dev/null && \
            gzip -cd "$file" | tar xpf -
            chkstatus_or_exit 3
            ;;
        *.tar.bz2 | *.tbz2 | *.tbz )
            bzip2 -cd "$file" | tar tf - > /dev/null && \
            bzip2 -cd "$file" | tar xpf -
            chkstatus_or_exit 3
            ;;
        *.tar.lz | *.tlz )
            lzip -cd "$file" | tar tf - > /dev/null && \
            lzip -cd "$file" | tar xpf -
            chkstatus_or_exit 3
            ;;
        *.tar.xz | *.txz )
            xz -cd "$file" | tar tf - > /dev/null && \
            xz -cd "$file" | tar xpf -
            chkstatus_or_exit 3
            ;;
        *.zip | *.ZIP )
            unzip -t "$file" > /dev/null && \
            unzip "$file" > /dev/null
            chkstatus_or_exit 3
            ;;
        *.gz)
            gzip -t "$file" && \
            gzip -cd "$file" > "$(basename -- $file .gz)"
            chkstatus_or_exit 3
            ;;
        *.Z)
            gzip -t "$file" && \
            gzip -cd "$file" > "$(basename -- $file .Z)"
            chkstatus_or_exit 3
            ;;
        *.bz2)
            bzip2 -t "$file" && \
            bzip2 -cd "$file" > "$(basename -- $file .bz2)"
            chkstatus_or_exit 3
            ;;
        *.lz)
            lzip -t "$file" && \
            lzip -cd "$file" > "$(basename -- $file .lz)"
            chkstatus_or_exit 3
            ;;
        *.xz)
            xz -t "$file" && \
            xz -cd "$file" > "$(basename -- $file .lz)"
            chkstatus_or_exit 3
            ;;
        *)
            warn "${PROGRAM}: cannot unpack ${file}: Unsupported extension"
            exit 1
        esac
    done
    unset file
}

do_meta()
{
    # Extract information from the recipe to create the meta file.
    #
    # The package description is pre-formatted in 78 columns,
    # the '#' character and a space is added as prefix to conform
    # 80 columns in total

    cat << EOF
$(echo "$description" | fold -w 78 | awk '$0="# " $0')

QICFLAGS="$QICFLAGS"
QICXXFLAGS="$QICXXFLAGS"
QILDFLAGS="$QILDFLAGS"
program=$program
version=$version
release=$release
blurb="$(echo "$description" | sed -e '/^$/d;2q')"
homepage="$homepage"
license="$license"
fetch="$fetch"
replace="$replace"

EOF
}

#### Default values

PROGRAM="${0##*/}"
packagedir=@PACKAGEDIR@
targetdir=@TARGETDIR@
RC=RC
RCFILE=@SYSCONFDIR@/qirc
opt_update=opt_update.off
opt_force=opt_force.off
opt_keep=opt_keep.off
opt_incr_release=opt_incr_release.off
opt_nopkg=opt_nopkg.off
opt_prune=opt_prune.off
arch="$(uname -m)" || chkstatus_or_exit
jobs=1
mode=""
verbose=0
graft_v=-v
_isUpgrade=_isUpgrade.false
_opt_ignoreqsts=_opt_ignoreqsts.off
TMPDIR="${TMPDIR:=/usr/src/qi/build}"
QICFLAGS="${QICFLAGS:=-g0 -Os}"
QICXXFLAGS="${QICXXFLAGS:=$QICFLAGS}"
QILDFLAGS="${QILDFLAGS:=-s}"
worktree=/usr/src/qi
tardir=${worktree}/sources
outdir=/var/cache/qi/packages
netget="wget -c -w1 -t3 --no-check-certificate"
rsync="rsync -v -a -L -z -i --progress"
configure_args="--prefix=@PREFIX@ --libexecdir=@LIBEXECDIR@ --bindir=@BINDIR@ --sbindir=@SBINDIR@ --sysconfdir=@SYSCONFDIR@ --localstatedir=@LOCALSTATEDIR@"
infodir=@INFODIR@
mandir=@MANDIR@
docdir=@DOCDIR@

#### Parse options

while getopts :bcdiouxNP:t:fkvO:W:Z:a:j:1nphV name
do
    case $name in
    b)
        if test -z "$mode"
        then
            readconfig
            mode=build_mode
        fi
        ;;
    c)
        mode=create_mode
        ;;
    d)
        readconfig
        mode=delete_mode
        ;;
    i)
        if test -z "$mode"
        then
            readconfig
            mode=install_mode
        fi
        if test "$mode" = build_mode
        then
            opt_install=opt_install
        fi
        ;;
    o)
        mode=resolve_mode
        ;;
    u)
        if test -z "$mode"
        then
            readconfig
            mode=upgrade_mode
        fi
        if test "$mode" = build_mode
        then
            opt_update=opt_update
        fi
        ;;
    x)
        mode=extract_mode
        ;;
    N)
        RC=RC.off
        ;;
    P)
        packagedir="$OPTARG"
        ;;
    t)
        targetdir="$OPTARG"
        ;;
    f)
        opt_force=opt_force
        ;;
    k)
        opt_keep=opt_keep
        ;;
    v)
        verbose=$(( verbose + 1 ))
        ;;
    O)
        outdir="$OPTARG"
        ;;
    W)
        worktree="$OPTARG"
        ;;
    Z)
        tardir="$OPTARG"
        ;;
    a)
        arch="$OPTARG"
        ;;
    j)
        jobs="$OPTARG"
        ;;
    1)
        opt_incr_release=opt_incr_release
        ;;
    n)
        opt_nopkg=opt_nopkg
        ;;
    p)
        opt_prune=opt_prune
        ;;
    h)
        usage
        exit 0
        ;;
    V)
        version
        exit 0
        ;;
    :)
        warn "Option '-${OPTARG}' requires an argument"
        usage
        exit 1
        ;;
    \?)
        warn "Illegal option -- '-${OPTARG}'"
        usage
        exit 1
        ;;
    esac
done
shift $(( OPTIND - 1 ))

if test $# -eq 0
then
    usage
    exit 1
fi

## Program sanity check
for need in awk basename bzip2 chmod cp dirname find fold graft grep \
            lzip mkdir mktemp rm rmdir sed sha256sum stat tar
do
    if ! type $need 1> /dev/null 2> /dev/null
    then
        warn "${PROGRAM}: cannot operate without ${need}(1): Check your PATH"
        exit 2
    fi
done
unset need

# Determine verbosity level/flag

if test "$verbose" -gt 1
then
    graft_v=-V
fi

# Read standard input if FILE is -, or when FILE
# is not connected to a terminal.

if test "$1" = - || test ! -t 0
then
    # Unset positional parameters setting $# to zero
    set --

    # Assign remaining arguments to the positional parameters
    while read -r input
    do
        set -- "$@" "$input"
    done
fi

# We need at least one operating mode
if test -z "$mode"
then
    usage
    exit 4
fi

# Ensure 'TMPDIR' creation to prefix temporary files

if test ! -d "$TMPDIR"
then
    mkdir -p -- "$TMPDIR" || chkstatus_or_exit
fi
readonly TMPDIR

# Remove write permission for group and other
umask 022

# Process each package or recipe provided on the command-line

for package in "$@"
do
    $mode "$package"
done

