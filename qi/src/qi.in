#! /bin/sh -
#  Copyright (C) 2016-2017 Matias Fonzo <selk@dragora.org>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

# EXIT STATUS
# 0  = Successful completion
# 1  = Minor common errors (e.g: help usage, support not available)
# 2  = Command execution error
# 3  = Integrity check error for compressed files
# 4  = File empty, not regular, or expected
# 5  = Empty or not defined variable
# 6  = Package already installed
# 10 = Network manager error

# Override locale settings
LC_ALL=C
export LC_ALL

#### Functions

usage()
{
    printf "%s\n" \
     "Qi - A practical and user-friendly package manager."              \
     ""                                                                 \
     "Usage: $PROGRAM [OPTION...] [FILE]..."                            \
     ""                                                                 \
     "Operation mode:"                                                  \
     "  -b          build packages using recipes"                       \
     "  -c          create .tlz package from directory"                 \
     "  -d          delete packages"                                    \
     "  -i          install packages"                                   \
     "  -o          resolve build order through .order files"           \
     "  -u          update packages"                                    \
     "  -x          extract packages for debugging purposes"            \
     ""                                                                 \
     "Common options:"                                                  \
     "  -N          don't read the configuration file"                  \
     "  -P  <DIR>   directory for package (de)installation;"            \
     "              only valid for -i, -d, -or -u options"              \
     "  -T  <DIR>   target directory for symbolic links;"               \
     "              only valid for -i, -d, or -u options"               \
     "  -f          force rebuild the package of a recipe,"             \
     "              force the removal of a package on CONFLICT;"        \
     "              only valid for -b and -d options"                   \
     "  -k          keep (don't delete) srcdir or destdir;"             \
     "              this is when the option -b is used"                 \
     "              keep (don't delete) package directory;"             \
     "              this is when the option -d is used"                 \
     "  -v          be verbose (a 2nd -v gives more)"                   \
     ""                                                                 \
     "Options for 'build' mode (-b):"                                   \
     "  -O  <DIR>   where the produced packages are written"            \
     "  -W  <DIR>   where archives, patches, and recipes are expected"  \
     "  -Z  <DIR>   where the sources will be found"                    \
     "  -a          architecture to use"                                \
     "  -j          parallel jobs for the compiler"                     \
     "  -1          increment release number (release + 1)"             \
     "  -n          don't create a .tlz package"                        \
     ""                                                                 \
     "Other options:"                                                   \
     "  -h          display this help and exit"                         \
     "  -V          output version information"                         \
     ""                                                                 \
     "Some influential environment variables:"                          \
     "  TMPDIR      temporary directory for sources"                    \
     "  QICFLAGS    C compiler flags"                                   \
     "  QICXXFLAGS  C++ compiler flags"                                 \
     "  QILDFLAGS   linker flags"                                       \
     ""                                                                 \
     "When FILE is -, read standard input."                             \
     ""
}

version()
{
    printf "%s\n" \
     "$PROGRAM @VERSION@" \
     "Copyright (C) 2016-2017 Matias Andres Fonzo." \
     "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>" \
     "This is free software: you are free to change and redistribute it." \
     "There is NO WARRANTY, to the extent permitted by law."
}

warn()
{
    printf "%s\n" "$@" 1>&2
}

is_readable()
{
    if test -e "$1"
    then
        if ! test -r "$1"
        then
            echo "${PROGRAM}: cannot read ${1}: Permission denied" 1>&2
            return 1
        fi
    else
        echo "${PROGRAM}: cannot access ${1}: No such file or directory" 1>&2
        return 1
    fi
    return 0
}

# Determine whether $2 matches pattern $1
fnmatch()
{
    case $2 in
    $1)
        return 0
        ;;
    *)
        return 1
        ;;
    esac
}

checkstatus_or_exit()
{
    status=$?

    if test $status -ne 0
    then
        echo "Return status = $status" 1>&2
        exit ${1-2};	# If not given, defaults to 2
    fi

    unset status
}

readconfig()
{
    if test $RC = RC
    then
        is_readable "$HOME/.qirc" 2> /dev/null && RCFILE="$HOME/.qirc";

        echo "Processing \`${RCFILE}' ..."

        test -f "$RCFILE" || {
            warn "${RCFILE} is not a regular file."
            return 1
        }

        # Parse config file
        while IFS='=' read -r variable value
        do
            case $variable in
            \#* | "")	# Ignore commented or blank lines
                continue
                ;;
            esac

            # Set variable name avoiding code execution
            eval "$variable=\${value}"
        done < "$RCFILE"
    fi
}

#### Mode functions

build_mode()
{
    recipe=$1

    # A recipe is any valid regular file, the current working directory
    # has priority over the working tree (or where the recipes reside).
    # The 'worktree' is the second place where to find a recipe.  Also,
    # we complete the possibility of using the directory name to invoke
    # a recipe if it contains "recipe" as the file name.

    if test ! -f "$recipe"
    then
        if test -f "${PWD}/${recipe}/recipe"
        then
            recipe="${PWD}/${recipe}/recipe"
        elif test -f "${worktree}/$recipe"
        then
            recipe="${worktree}/$recipe"
        elif test -f "${worktree}/${recipe}/recipe"
        then
            recipe="${worktree}/${recipe}/recipe"
        elif test -f "${worktree}/recipes/${recipe}"
        then
            recipe="${worktree}/recipes/${recipe}"
        elif test -f "${worktree}/recipes/${recipe}/recipe"
        then
            recipe="${worktree}/recipes/${recipe}/recipe"
        fi
    fi

    # Perform sanity checks

    test -f "$recipe" || {
        warn "${PROGRAM}: \`${recipe}' is not a regular file."
        exit 4
    }

    # Start preparations to import the recipe

    # Separate the directory name from the filename,
    # getting its absolute path name and base name
    CWD=$(CDPATH= cd -P -- $(dirname -- "$recipe") && printf "$PWD")
    recipe=$(basename -- "$recipe")

    # Check readability for load the recipe on success

    is_readable "${CWD}/$recipe" || exit 4

    # Make tail directories if needed
    test -d "${worktree}/archive" || mkdir -p -- "${worktree}/archive"
    test -d "${worktree}/patches" || mkdir -p -- "${worktree}/patches"
    test -d "${worktree}/recipes" || mkdir -p -- "${worktree}/recipes"
    test -d "$tardir"             || mkdir -p -- "$tardir"

    # Variables treatment for the actual and the next recipe,
    # if there are more than one to process.
    #
    # Unset special variables that can only be predefined
    # in the recipe not coming from ${sysconfdir}/qirc

    unset srcdir destdir pkgname pkgversion program version release \
          fetch description homepage license replace

    # The following variables must be restored later
    save_arch="${save_arch:=$arch}"
    save_jobs="${save_jobs:=$jobs}"

    unset arch jobs

    # The following variables cannot be redefined in the recipe
    readonly outdir worktree netget rsync

    # Recommended practices is to set variables in front of `configure'
    # or in front of make(1).  Refer to the documentation of Qi.

    unset CFLAGS CXXFLAGS LDFLAGS

    # Load the recipe

    echo "Loading ${CWD}/$recipe ..."
    . "${CWD}/$recipe"

    # Check for required variables
    if test -z "$program"
    then
        warn "${recipe}: The variable 'program' is not defined."
        exit 5
    fi
    if test -z "$version"
    then
        warn "${recipe}: The variable 'version' is not defined."
        exit 5
    fi
    if test -z "$release"
    then
        warn "${recipe}: The variable 'release' is not defined."
        exit 5
    fi

    # Pre-settings before to start building

    # Increment the release number if the option was given
    if test "$opt_incr_release" = opt_incr_release
    then
        release=$(( release + 1 ))
    fi

    # Allow the dot as definition for 'tardir'
    if test "$tardir" = .
    then
        tardir="$CWD"
    fi

    # Set default values for the following special variables

    srcdir="${srcdir:=${program}-$version}"
    destdir="${destdir:=${TMPDIR}/package-$program}"
    pkgname="${pkgname:=$program}"
    pkgversion="${pkgversion:=$version}"

    # Restore default values if they were not given in the recipe
    arch="${arch:=$save_arch}"
    jobs="${jobs:=$save_jobs}"

    # Complete package name adding "pkgversion-arch+release"
    full_pkgname=$pkgname-${pkgversion}-${arch}+${release}

    # If a package is going to be created, the existence of a
    # previous build of the package is detected and reported.
    # Under normal conditions, the recipe is built as long as
    # it is newer than the package produced; if not, we warn
    # the user about it.  Rebuilding the package is also
    # possible (through the force ;-)

    if test "$opt_nopkg" != opt_nopkg
    then
        if test "$opt_force" != opt_force -a -r "${outdir}/${full_pkgname}.tlz"
        then
            if test "${CWD}/$recipe" -nt "${outdir}/${full_pkgname}.tlz"
            then
                warn \
                 ""                                                          \
                 "The recipe is newer than the detected package:"            \
                 ""                                                          \
                 "$( stat -c "%y %n" "${CWD}/$recipe" )"                     \
                 "$( stat -c "%y %n" "${outdir}/${full_pkgname}.tlz" )"      \
                 ""                                                          \
                 "This package is going to be built ..."                     \
                 ""
            else
                warn \
                 ""                                                          \
                 "The recipe already produced the package:"                  \
                 "$( stat -c "%y %n" "${outdir}/${full_pkgname}.tlz" )"      \
                 ""                                                          \
                 "But the recipe is still older than the produced package:"  \
                 "$( stat -c "%y %n" "${CWD}/$recipe" )"                     \
                 ""                                                          \
                 "    Probably nothing has changed."                         \
                 ""

                # In non-interactive mode, the user is asked about
                # rebuilding the package; in interactive mode,
                # the user need to pass the option explicitly

                if test ! -t 0
                then
                    printf "Do you want to rebuild this package? {y/N} " > /dev/tty
                    IFS= read -r REPLY < /dev/tty || exit 2
                    case $REPLY in
                    [yY]*)
                        echo "$REPLY" > /dev/tty
                        unset REPLY
                        ;;
                    *)
                        unset REPLY
                        echo "Recipe for '${full_pkgname}.tlz':  Cancelled." > /dev/tty
                        return 0
                        ;;
                    esac
                else
                    warn "See '$PROGRAM -h' for more information."
                    exit 6;
                fi
            fi
        fi
    fi

    # Fetch remote sources

    echo "Fetching remote sources if needed ..."
    if test -n "$fetch"
    then
        for origin in $fetch
        do
            _source=$(basename -- "$origin")

            echo "Looking for ${tardir}/$_source ..."
            test -e "${tardir}/$_source" && continue

            # Download the source if does not exist

            warn "Cannot find $_source in $tardir:" \
                 "attempting to get it from ${origin%/*} ..."

            case $origin in
            rsync://*)
                    (
                        cd -- "$tardir" && $rsync $origin && \
                        sha256sum $_source > ${_source}.sha256
                    )
                ;;
            *://*)
                    (
                        cd -- "$tardir" && $netget $origin && \
                        sha256sum $_source > ${_source}.sha256
                    )
                ;;
            *)
                warn "${PROGRAM}: Unrecognized protocol for $origin"
                exit 4
            esac
        done
        unset origin _source
    else
        warn "${recipe}: The variable 'fetch' is empty."
    fi

    # Prepare special directories for build the source,
    # the destination and the output of the package

    echo "Preparing directories ..."

    if test -d "${TMPDIR}/$srcdir"
    then
        rm -rf -- "${TMPDIR}/$srcdir" || exit 2
        echo "removed directory: '${TMPDIR}/$srcdir'"
    fi
    mkdir -p -- "${TMPDIR}/$srcdir" || exit 2
    echo "mkdir: created directory '${TMPDIR}/$srcdir'"

    if test -d "$destdir"
    then
        rm -rf -- "$destdir" || exit 2
        echo "removed directory: '$destdir'"
    fi
    mkdir -p -- "$destdir" || exit 2
    echo "mkdir: created directory '$destdir'"

    if test ! -d "$outdir"
    then
        mkdir -p -- "$outdir" || exit 2
        echo "mkdir: created directory '$outdir'"
    fi

    # Set sane permissions for '${TMPDIR}/$srcdir'
    echo "${TMPDIR}/${srcdir}: Changing file mode bits to u+w,go-w,a+rX-s ..."
    chmod -R u+w,go-w,a+rX-s "${TMPDIR}/$srcdir" || exit 2

    # Enter to 'TMPDIR' and run the main function in order to make the package

    echo "Entering to 'TMPDIR': $TMPDIR ..."
    cd -- "$TMPDIR" || exit 2

    # Set trap before to run the build() function in order
    # to catch the return status, exit code is 2 in failure

    trap 'checkstatus_or_exit 2' EXIT HUP INT QUIT ABRT TERM

    echo "Running build() ..."
    build

    # Reset given signals
    trap - EXIT HUP INT QUIT ABRT TERM

    # Restore shell option (just in case)
    set +e

    # Remove build() function
    unset build

    # If 'destdir' is empty, the package won't be created
    if rmdir -- "$destdir" 2> /dev/null
    then
        warn "${full_pkgname}.tlz won't be created: 'destdir' was empty."
        opt_nopkg=opt_nopkg
    fi

    # Create (make) the package

    if test "$opt_nopkg" != opt_nopkg
    then
        # Edit the recipe when 'release' is incremented
        if test "$opt_incr_release" = opt_incr_release
        then
            echo ",s/^\(release\)=.*/\1=${release}/"$'\nw' | \
             ed "${CWD}/$recipe" || exit 2
        fi

        mkdir -p -- "${destdir}/var/lib/qi" || exit 2

        # Include a recipe copy into the package
        cp -p "${CWD}/$recipe" \
              "${destdir}/var/lib/qi/${full_pkgname}.recipe" && \
        chmod 644 "${destdir}/var/lib/qi/${full_pkgname}.recipe" || exit 2

        # Detect post-install script for inclusion

        if test -f "${CWD}/post-install"
        then
            echo "${CWD}/post-install:  Detected."
            cp -p "${CWD}/post-install" \
                  "${destdir}/var/lib/qi/${full_pkgname}.sh" && \
            chmod 644 "${destdir}/var/lib/qi/${full_pkgname}.sh" || exit 2
        fi

        # Detect declared package names for later replacement

        if test -n "$replace"
        then
            rm -f "${destdir}/var/lib/qi/${full_pkgname}.replace"

            warn \
             "The following package names has been declared for replacement:" \
             "    $replace"

            for item in $replace
            do
                echo "$replace" >> "${destdir}/var/lib/qi/${full_pkgname}.replace"
            done
            unset item
        fi

        # Create meta file for the package information
        echo "Creating meta file ${full_pkgname}.tlz.txt ..."
        do_meta > "${outdir}/${full_pkgname}.tlz.txt" || exit 2

        # Make a copy of it for the database
        cp -p "${outdir}/${full_pkgname}.tlz.txt" \
              "${destdir}/var/lib/qi/${full_pkgname}.txt" || exit 2

        # Produce the package
        cd -- "$destdir" && create_mode "${outdir}/${full_pkgname}.tlz"
    fi

    # Back to the current working directory
    cd -- "$CWD" || exit 2

    # Delete 'srcdir' or 'destdir' if -k is not given
    if test "$opt_keep" != opt_keep
    then
        echo "Deleting temporary directories ..."

        rm -rf -- "${TMPDIR}/$srcdir" || exit 2
        echo "removed directory: '${TMPDIR}/$srcdir'"

        if test -d "$destdir"
        then
            rm -rf -- "$destdir" || exit 2
            echo "removed directory: '$destdir'"
        fi   
    fi

    # Install or update the package if -i or -u was given
    if test "$opt_install" = opt_install -a "$opt_nopkg" != opt_nopkg
    then
        echo ""
        install_mode "${outdir}/${full_pkgname}.tlz"
    elif test "$opt_update" = opt_update -a "$opt_nopkg" != opt_nopkg
    then
        echo ""
        upgrade_mode "${outdir}/${full_pkgname}.tlz"
    fi

    echo ""
    echo "All done for ${CWD}/${recipe}."
    echo ""
}

create_mode()
{
    directory=$(dirname -- "$1")
    name=$(basename -- "$1")

    # Perform sanity checks

    is_readable "$directory" || exit 4

    # Check again to find out if it is a valid directory
    test -d "$directory" || {
        warn "${PROGRAM}: Package directory '$name' does not exist."
        exit 4
    }

    test "$directory" = . && {
        warn "${PROGRAM}: Cannot create package on current working directory."
        exit 4
    }

    test "$name" = "${name%.tlz}" && {
        warn \
         "${PROGRAM}: Package format '$name' not supported." \
         "It should be \`name-version-architecture+release.tlz'"
        exit 4
    }

    echo "${directory}: Creating package $name ..."
    ( umask 022 ; tar cvf - ./* | lzip -9cvv ) > "${directory}/$name"
    checkstatus_or_exit 3

    echo "${directory}/$name: Creating SHA256 checksum ..."
    (
        cd -- "$directory" && \
        sha256sum $name > ${name}.sha256
    )

    # Remove used variables
    unset directory name
}

delete_mode()
{
    expunge=$1

    # If package is not a fully qualified directory, prepend it with
    # the value of packagedir.  The solely '/' does not qualify here.

    if ! fnmatch '/?*' "$expunge"
    then
        expunge=$(basename -- "$expunge" .tlz)
        expunge="${packagedir}/$expunge"
    fi

    # Complain if the package directory does not exist

    test -d "$expunge" || {
        warn "${PROGRAM}: Package directory '$expunge' does not exist."
        exit 4
    }

    # Complain if the package directory cannot be well-read

    is_readable "$expunge" || exit 4

    # Scan for possible conflicts, stop if arise
    if test "$opt_force" != opt_force
    then
        echo "Checking for possible conflicts ..."
        graft -d -n -t "$targetdir" "$expunge" > /dev/null
        checkstatus_or_exit 6
    fi

    # Ignore some signals up to completing the (de)installation
    trap "" HUP INT QUIT ABRT TERM

    # Remove package from Graft control

    # Remove objects (files, links or directories) from the target
    # directory that are in conflict with the package directory

    echo "Pruning any conflict ..."
    graft -p -D -u -t "$targetdir" "$expunge"
    checkstatus_or_exit 2

    echo "Disabling links ..."
    graft -d -u $graft_v -t "$targetdir" "$expunge"
    checkstatus_or_exit 2

    # Delete package directory
    if test "$opt_keep" != opt_keep
    then
        warn "Deleting package directory, if needed ..."

        if test -d "$expunge"
        then
            rm -rf -- "$expunge" || exit 2
            echo "removed directory: '$expunge'"
        else
            warn "Package directory '$expunge' is no longer there."
        fi
    fi

    # Reset given signals
    trap - HUP INT QUIT ABRT TERM

    # Remove used variables
    unset expunge
}

install_mode()
{
    # Complain if the package cannot be well-read

    is_readable "$1" || exit 4

    # Complain if the package does not end in .tlz

    if ! fnmatch '*.tlz' "$1"
    then
        warn "${PROGRAM}: \`${1}' does not end in .tlz"
        exit 4
    fi

    # Make preparations to install the package

    # Get the filename
    name=$(basename -- "$1" .tlz)

    echo "Checking tarball integrity ..."
    tar -tf "$1" > /dev/null
    checkstatus_or_exit 3

    # Create package directory using 'name'
    test -d "${packagedir}/$name" || {
        mkdir -p -- "${packagedir}/$name" || exit 2
        echo "mkdir: created directory '${packagedir}/$name'"
    }

    # Prepare to decompress the package

    # Ignore some signals up to completing the installation
    trap "" HUP INT QUIT ABRT TERM

    echo "Decompressing $1 ..."
    ( cd -- "${packagedir}/$name" && lzip -cd - | tar xpf - ) < "$1"
    checkstatus_or_exit 3

    # Transite package to Graft control

    # Remove objects (files, links or directories) from the target
    # directory that are in conflict with the package directory

    echo "Pruning any conflict ..."
    graft -p -D -u -t "$targetdir" "${packagedir}/$name"
    checkstatus_or_exit 2

    echo "Enabling symbolic links ..."
    graft -i -P $graft_v -t "$targetdir" "${packagedir}/$name"
    checkstatus_or_exit 2

    # Avoid unnecessary description and post-install execution coming
    # from the upgrade_mode() when a package is **pre-installed**
    if test "$_isUpgrade" != isUpgrade
    then
        # Show package description

        if test -r "${packagedir}/${name}/var/lib/qi/${name}.txt"
        then
            grep '^#' "${packagedir}/${name}/var/lib/qi/${name}.txt"
        elif test -r "${1}.txt"
        then
            # From the external meta file
            grep '^#' "${1}.txt"
        else
            warn "Description file not found for '$name'."
        fi

        # Check and run the post-install script if exist

        if test -r "${packagedir}/${name}/var/lib/qi/${name}.sh"
        then
            echo "Running post-install script for \`${name}' ..."
            (
                cd -- "${targetdir}"/ && /bin/sh \
                 "${packagedir}/${name}/var/lib/qi/${name}.sh"
            )
        fi

        # Check if there are declared package names for replacement

        if test -r "${packagedir}/${name}/var/lib/qi/${name}.replace"
        then
            short_name=$(pkgbase $name)

            while read -r line
            do
                for replace in "${packagedir}/${line}"*
                do
                    if test "$(pkgbase $replace)" = "$short_name"
                    then
                        continue;
                    fi

                    warn "Replacing package \`${replace}' ..."

                    opt_force=opt_force opt_keep=opt_keep.off \
                     delete_mode "$replace" > /dev/null
                done
            done < "${packagedir}/${name}/var/lib/qi/${name}.replace"

            unset short_name
        fi
    fi

    # Reset given signals
    trap - HUP INT QUIT ABRT TERM

    # Remove used variables
    unset name
}

resolve_mode() {
    # Complain if the file cannot be well-read

    is_readable "$1" || exit 4

    # Complain if the file does not end in .order

    if ! fnmatch '*.order' "$1"
    then
        warn "${PROGRAM}: \`${1}' does not end in .order"
        exit 4
    fi

    # Get a clean list of the file while prints its content in reverse order,
    # lines containing: colons, comments, parentheses, end of line, and blank
    # lines, are removed.  The parentheses are used to insert a reference.
    # The last `awk' in the pipe: removes nonconsecutive lines, duplicate.
    awk \
    '{ gsub( /:|^#(.*)$|\([^)]*)|^$/,"" ); for( i=NF; i > 0; i-- ) print $i }' \
     "$1" | awk '!s[$0]++'
}

upgrade_mode()
{
    # Complain if the package is not a regular file

    test -f "$1" || {
        warn "${PROGRAM}: \`${1}' is not a regular file."
        exit 4
    }

    # Get the filename
    incoming=$(basename -- "$1" .tlz)

    # Prepare the package to install it in a temporary location

    # Set random directory using packagedir as prefix and 'incoming' as suffix
    PRVDIR=$(mktemp -dp "$packagedir" ${incoming}.XXXXXXXXXXXX) || exit 2

    # Pre-install the package in the custom 'packagedir'

    save_packagedir="$packagedir"
    packagedir="$PRVDIR"

    echo "Pre-installing package into $packagedir ..."
    _isUpgrade=isUpgrade install_mode "$1" > /dev/null
    unset _isUpgrade

    # Remove old package names if the option -k was not given

    # Restore 'packagedir' first
    packagedir=$save_packagedir
    unset save_packagedir

    echo "Searching for previous installations under the same package name ..."
    short_name=$(pkgbase $incoming)

    for long_name in "${packagedir}/$short_name"*
    do
        # The search of the package to remove cannot be the
        # same to the installation of the temporary package
        if test "$long_name" = "$PRVDIR"
        then
            continue;
        fi

        if test "$short_name" = "$(pkgbase $long_name)"
        then
            echo "${long_name}:  Detected."
            delete_mode "$long_name" > /dev/null 2>&1
        fi
    done

    unset short_name long_name

    # Re-install the package removing the temporary location

    echo "Upgrading to $incoming ..."
    install_mode "$1"

    echo "Deleting temporary location ..."
    rm -rf -- "$PRVDIR" && echo "removed directory: '$PRVDIR'"

    # Remove remaining variables
    unset incoming PRVDIR
}

extract_mode()
{
    # Perform sanity checks before package extraction

    is_readable "$1" || exit 4

    test -f "$1" || {
        warn "${PROGRAM}: \`${1}' is not a regular file."
        exit 4
    }

    # Preparations to extract the package

    name=$(basename -- "$1" .tlz)

    # Set random directory using 'name' as prefix
    PRVDIR="${TMPDIR}/${name}.${RANDOM-0}$$"

    # Trap to remove 'PRVDIR' on disruptions
    trap "rm -rf -- $PRVDIR" HUP INT ABRT TERM

    # Create 'PRVDIR' removing access for all but user
    ( umask 077 ; mkdir -- $PRVDIR )
    mkdir -p -m 700 -- $PRVDIR

    # Extract the package

    echo "Extracting package $name on $PRVDIR ..."
    ( umask 000 ; cd -- $PRVDIR && lzip -cd - | tar xf - ) < "$1"
    if test $? -ne 0
    then
        # Try to remove (empty) 'PRVDIR' on failure
        rmdir -- $PRVDIR
        exit 3;
    fi

    # Reset given signals
    trap - HUP INT ABRT TERM

    # Remove used variables
    unset name PRVDIR
}

#### Extra functions used in the modes

pkgbase()
{
    string=$(basename -- "$1" .tlz)

    # Take and count the dashes only

    dashes=$(echo "$string" | tr -cd '-')
    dashes="${#dashes}"

    # Match cases to print the package name
    case $dashes in
    0 | "")
        # NAME or null
        echo "$string"
        ;;
    1)
        # NAME-VERSION
        echo "${string%-*}"
        ;;
    2 | 3)
        # NAME_[-LONG]-VERSION-ARCH+release
        echo "${string%-*-*}"
        ;;
    *)
        # NAME_[-LONG][-VERYLONG]-VERSION-ARCH+release
        echo "$string" | cut -f 1-$((dashes - 2)) -d -
        ;;
    esac

    unset string dashes
}

unpack()
{
    for file
    do
        case $file in
        *.tar | *.tar.* | *.t[gblx]z* )
            tar tf "$file" > /dev/null && tar xf "$file"
            checkstatus_or_exit 3
            ;;
        *.zip | *.ZIP )
            unzip -t "$file" && unzip "$file"
            checkstatus_or_exit 3
            ;;
        *.gz)
            gzip -t "$file" && gzip -cd "$file" > $(basename -- "$file" .gz)
            checkstatus_or_exit 3
            ;;
        *.bz2)
            bzip2 -t "$file" && bzip2 -cd "$file" > $(basename -- "$file" .bz2)
            checkstatus_or_exit 3
            ;;
        *.lz)
            lzip -t "$file" && lzip -cd "$file" > $(basename -- "$file" .lz)
            checkstatus_or_exit 3
            ;;
        *)
            warn "${PROGRAM}: cannot unpack ${file}: Unsupported extension"
            exit 1
        esac
    done
}

do_meta()
{
    # Extract information from the recipe to create the meta file.
    #
    # The package description is pre-formatted in 78 columns,
    # the '#' character and a space is added as prefix to conform
    # 80 columns in total.
    #
    # The 'depends' variable invokes to the resolve_mode() function
    # translating new lines into spaces, the last trailing whitespace
    # is removed.

    cat << EOF
$(echo "$description" | fold -w 78 | awk '$0="# " $0')

QICFLAGS="$QICFLAGS"
QICXXFLAGS="$QICXXFLAGS"
QILDFLAGS="$QILDFLAGS"
program=$program
version=$version
release=$release
blurb="$(echo "$description" | sed -e '/^$/d;2q')"
homepage="$homepage"
license="$license"
fetch="$fetch"
replace="$replace"
depends="$(resolve_mode "${CWD}/depends.order" 2> /dev/null | tr '\n' ' ' | sed -e 's/ *$//' || true)"

EOF
}

#### Default values

PROGRAM="${0##*/}"
VERSION=1.0-rc11
packagedir=@PACKAGEDIR@
targetdir=@TARGETDIR@
RC=RC
RCFILE=@SYSCONFDIR@/qirc
opt_update=""
opt_force=opt_force.off
opt_keep=opt_keep.off
opt_incr_release=opt_incr_release.off
opt_nopkg=opt_nopkg.off
arch="$(uname -m)" || exit 2
jobs=1
mode=""
verbose=0
graft_v=-v
_isUpgrade=""
TMPDIR="${TMPDIR:=/usr/src/qi/build}"
QICFLAGS="${QICFLAGS:=-g0 -Os}"
QICXXFLAGS="${QICXXFLAGS:=$QICFLAGS}"
QILDFLAGS="${QILDFLAGS:=-s}"
worktree=/usr/src/qi
tardir=${worktree}/sources
outdir=/var/cache/qi/packages
netget="wget -c -w1 -t3 --no-check-certificate"
rsync="rsync -v -a -L -z -i --progress"
configure_args="--prefix=@PREFIX@ --libexecdir=@LIBEXECDIR@ --bindir=@BINDIR@ --sbindir=@SBINDIR@ --sysconfdir=@SYSCONFDIR@ --localstatedir=@LOCALSTATEDIR@"
infodir=@INFODIR@
mandir=@MANDIR@
docdir=@DOCDIR@

#### Parse options

while getopts :bcdiouxNP:T:fkvO:W:Z:a:j:1nhV name
do
    case $name in
    b)
        if test -z "$mode"
        then
            readconfig
            mode=build_mode
        fi
        ;;
    c)
        mode=create_mode
        ;;
    d)
        readconfig
        mode=delete_mode
        ;;
    i)
        if test -z "$mode"
        then
            readconfig
            mode=install_mode
        fi
        if test "$mode" = build_mode
        then
            opt_install=opt_install
        fi
        ;;
    o)
        mode=resolve_mode
        ;;
    u)
        if test -z "$mode"
        then
            readconfig
            mode=upgrade_mode
        fi
        if test "$mode" = build_mode
        then
            opt_update=opt_update
        fi
        ;;
    x)
        mode=extract_mode
        ;;
    N)
        RC=RC.off
        ;;
    P)
        packagedir="$OPTARG"
        ;;
    T)
        targetdir="$OPTARG"
        ;;
    f)
        opt_force=opt_force
        ;;
    k)
        opt_keep=opt_keep
        ;;
    v)
        verbose=$(( verbose + 1 ))
        ;;
    O)
        outdir="$OPTARG"
        ;;
    W)
        worktree="$OPTARG"
        ;;
    Z)
        tardir="$OPTARG"
        ;;
    a)
        arch="$OPTARG"
        ;;
    j)
        jobs="$OPTARG"
        ;;
    1)
        opt_incr_release=opt_incr_release
        ;;
    n)
        opt_nopkg=opt_nopkg
        ;;
    h)
        usage
        exit 0
        ;;
    V)
        version
        exit 0
        ;;
    :)
        warn "Option '-${OPTARG}' requires an argument"
        usage
        exit 1
        ;;
    \?)
        warn "Illegal option -- '-${OPTARG}'"
        usage
        exit 1
        ;;
    esac
done
shift $(( OPTIND - 1 ))

if test $# -eq 0
then
    usage
    exit 1
fi

## Program sanity check
for need in awk basename bzip2 chmod cp dirname fold graft grep gzip \
            lzip mkdir mktemp rm rmdir sed sha256sum stat tar unzip
do
    if ! type $need 1> /dev/null 2> /dev/null
    then
        warn "${PROGRAM}: cannot operate without ${need}(1): Check your PATH"
        exit 2
    fi
done
unset need

# Determine verbosity level/flag

if test "$verbose" -gt 1
then
    graft_v=-V
fi

# Read standard input if FILE is -, or when FILE
# is not connected to a terminal.

if test "$1" = - -o ! -t 0
then
    # Unset positional parameters setting $# to zero
    set --

    # Assign remaining arguments to the positional parameters
    while read -r input
    do
        set -- "$@" "$input"
    done
fi

# We need at least one operating mode
if test -z "$mode"
then
    usage
    exit 4
fi

# Ensure 'TMPDIR' creation to prefix temporary files

if test ! -d "$TMPDIR"
then
    mkdir -p -- "$TMPDIR" || exit 2
fi
readonly TMPDIR

# Remove write permission for group and other
umask 022

# Process each package or recipe provided on the command-line

for package in "$@"
do
    $mode "$package"
done

